## 1 从5随机到7随机及其扩展

给定一个等概率随机产生1~5的随机函数rand1To5，除此之外，不能使用任何额外的随机机制，请用rand1To5实现等概率随机产生1~7的随机函数rand1To7.

```java
public class Code_01_RandNum {
	// 等概率随机产生1~5的随机数
	public int rand1To5() {
		return (int) (Math.random() * 5) + 1;
	}
	public int rand1To7() {
		int num = 0;
		do {
			num = (rand1To5() - 1) * 5 + rand1To5() - 1; // 两个随机函数是独立的
		} while (num > 20); // 超过20重新随机
		return num % 7 + 1;
	}
}
```

给定一个以p概率产生0，以1-p概率产生1的随机函数rand01p，除此之外，不能使用任何额外的随机机制，请用rand01p实现等概率随机产生1~6的随机函数rand1To6.

```java
public class Code_01_RandNum {

	// 以p的概率产生0，以1-p的概率产生1
	public int rand01p() {
		double p = 0.83; // 可随意改变
		return Math.random() < p ? 0 : 1;
	}

	// 等概率产生0和1
	public int rand01() {
		int num;
		do {
			num = rand01p();
		} while (num == rand01p()); // 产生01和10的概率都是p(1-p)
		return num;
	}

	// 等概率随机产生0~3的随机数
	public int rand0To3() {
		return rand01() * 2 + rand01();
	}

	// 等概率随机产生1~6的随机数
	public int rand1To6() {
		int num = 0;
		do {
			num = rand0To3() * 4 + rand0To3(); // 等概率产生0~15
		} while (num > 11);
		return num % 6 + 1;
	}
}
```

给定一个等概率随机产生1~M的随机函数rand1ToM，除此之外，不能使用任何额外的随机机制，有两个输入参数，分别为m和n，请用rand1ToM(m)实现等概率随机产生1~n的随机函数rand1ToN.

```java
public class Code_01_RandNum {

	// 等概率随机产生1~m的随机数
	public int rand1ToM(int m) {
		return (int) (Math.random() * m) + 1;
	}

	// 等概率随机产生1~n的随机数
	public int rand1ToN(int n, int m) {
		int[] nMsys = getMSysNum(n - 1, m);
		int[] randNum = getRanMSysNumLessN(nMsys, m);
		return getNumFromMSysNum(randNum, m) + 1;
	}

	// 把value变成m进制数
	public static int[] getMSysNum(int value, int m) {
		int[] res = new int[32];
		int index = res.length - 1;
		while (value != 0) {
			res[index--] = value % m;
			value = value / m;
		}
		return res;
	}

	// 等概率随机产生一个0~nMSys范围的数，只不过用m进制来表达
	public int[] getRanMSysNumLessN(int[] nMSys, int m) {
		int[] res = new int[nMSys.length];
		int start = 0;
		// 找到第一个不为0的位置
		while (nMSys[start] == 0) {
			start++;
		}
		int index = start;
		boolean lastEqual = true;
		// 遍历
		while (index != nMSys.length) {
			res[index] = rand1ToM(m) - 1; // 0~m-1
			if (lastEqual) {
				if (res[index] > nMSys[index]) {// 上一位相等且这一位大于则超过了n的范围重新开始
					index = start;
					lastEqual = true;
					continue;
				} else { // 设定前一位是否相等
					lastEqual = res[index] == nMSys[index];
				}
			}
			index++;
		}
		return res;
	}

	// 把m进制数转成十进制数
	public int getNumFromMSysNum(int[] mSysNum, int m) {
		int res = 0;
		for (int i = 0; i < mSysNum.length; i++) {
			res = res * m + mSysNum[i];
		}
		return res;
	}

}
```



## 2 一行代码求两个数的最大公约数

给定两个不等于0的整数M和N，求M和N的最大公约数。

```java
public class Code_02_Gcd {

	// 辗转相除法
	public int gcd(int m, int n) {
		return n == 0 ? m : gcd(n, m & n);
	}
}
```



## 3 有关阶乘的两个问题

给定一个非负整数N，返回N!果的末尾为0的数量。

```java
public class Code_03_ZeroNum {

	// 解法一：1~N的序列中因子5的个数
	public int zeroNum_1(int num) {
		if (num < 0) {
			return 0;
		}
		int res = 0;
		int cur = 0;
		for (int i = 5; i < num + 1; i += 5) {
			cur = i;
			while (cur % 5 == 0) { // 判断每个数因子5的个数
				res++;
				cur /= 5;
			}
		}
		return res;
	}

	// 解法二：z=n/5+n/(5^2)+n/(5^3)+...直到5^i>N
	public int zeroNum_2(int num) {
		if (num < 0) {
			return 0;
		}
		int res = 0;
		while (num != 0) {
			res += num / 5;
			num /= 5;
		}
		return res;
	}
}
```

给定一个非负整数N，如果用二进制数表达N！的结果，返回最低位的1在哪个位置上，认为最右的位置为位置0.

```java
public class Code_03_ZeroNum {

	// 解法一：1~N的序列中因子2的个数
	// z = N/2 + N/4 + N/8 + ...
	public int rightOne_1(int num) {
		if (num < 1) {
			return -1;
		}
		int res = 0;
		while (num != 0) {
			num >>>= 1;
			res += num;
		}
		return res;
	}

	// 解法二：可以证明z = N-m
	public int rightOne_2(int num) {
		if (num < 1) {
			return -1;
		}
		int ones = 0;
		int tmp = num;
		// 统计N的二进制中1的个数
		while (tmp != 0) {
			ones += (tmp & 1) != 0 ? 1 : 0;
			tmp >>>= 1;
		}
		return num - ones;
	}
}
```



## 4 判断一个点是否在矩形内部

在二维坐标系中，所有的值都是double类型，那么一个矩形可以由4个点代表，(x1,y1)为最左的点，(x2,y2)为最上的点，(x3,y3)为最下的点，(x4,y4)为最右的点。给定4个点代表的矩形，在给定一个点(x,y)，判断其是否在矩形中.

```java
public class Code_04_IsInside {

	// 矩形的边平行于坐标轴
	public boolean isInside(double x1, double y1, double x4, double y4, double x, double y) {
		if (x <= x1) {
			return false;
		}
		if (x >= x4) {
			return false;
		}
		if (y >= y1) {
			return false;
		}
		if (y <= y4) {
			return false;
		}
		return true;
	}

	public boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4,
			double x, double y) {
		if (y1 == y2) { // 平行的情况
			return isInside(x1, y1, x4, y4, x, y);
		}
		// 计算旋转角
		double l = Math.abs(y4 - y3);
		double k = Math.abs(x4 - x3);
		double s = Math.sqrt(k * k + l * l);
		double sin = l / s;
		double cos = k / s;
		// 计算旋转后的坐标
		// 坐标旋转公式：
		// x1 = xcos + ysin;
		// y1 = ycos - xsin;
		double x1R = cos * x1 + sin * y1;
		double y1R = -x1 * sin + y1 * cos;
		double x4R = cos * x4 + sin * y4;
		double y4R = -x4 * sin + y4 * cos;
		double xR = cos * x + sin * y;
		double yR = -x * sin + y * cos;
		return isInside(x1R, y1R, x4R, y4R, xR, yR);
	}
}
```



## 5 判断一个点是否在三角形内部

在二维坐标系中，所有的值都是double类型，那么一个三角形可以由3个点来代表，给定3个点代表的三角形，再给定一个点(x,y)，判断(x,y)是否在三角形中。

```java
public class Code_05_IsInside {

	// 向量叉乘的大小
	public double crossProduct(double x1, double y1, double x2, double y2) {
		return x1 * y2 - x2 * y1;
	}

	// 逆时针沿边走内部点始终在左边
	public boolean isInside(double x1, double y1, double x2, double y2, double x3, double y3, double x, double y) {
		// 如果三角形的点不是逆时针输入，改变一下顺序
		if (crossProduct(x3 - x1, y3 - y1, x2 - x1, y2 - y1) >= 0) {
			// 为正说明2在1->3边的左边
			double tmpx = x2;
			double tmpy = y2;
			x2 = x3;
			y2 = y3;
			x3 = tmpx;
			y3 = tmpy;
		}
		if (crossProduct(x2 - x1, y2 - y1, x - x1, y - y1) < 0) {
			return false;
		}
		if (crossProduct(x3 - x2, y3 - y2, x - x2, y - y2) < 0) {
			return false;
		}
		if (crossProduct(x1 - x3, y1 - y3, x - x3, y - y3) < 0) {
			return false;
		}
		return true;
	}
}
```



## 6 折纸问题

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开是凹下去的，即折痕突起的方向指向纸条的背面，如果折两次，会有3条折痕，方向分别是下、下、上。给定一个输入参数N，代表对折的次数，请从上到下打印所有折痕的方向。

```java
public class Code_06_PrintAllFolds {

	// 折痕是二叉树，特点是：根节点是下，每一个节点的左节点是下，右节点是上。该二叉树的中序遍历即为答案。
	public static void printAllFolds(int N) {
		printProcess(1, N, true);
	}

	public static void printProcess(int i, int N, boolean down) {
		if (i > N) {
			return;
		}
		printProcess(i + 1, N, true); // 左孩子向下
		System.out.println(down ? "down " : "up ");
		printProcess(i + 1, N, false); // 右孩子向上
	}

	public static void main(String[] args) {
		int N = 4;
		printAllFolds(N);
	}
}
```



## 7 蓄水池问题

有一个机器按自然数序列的方式吐出球，你有一个袋子最多只能装K个球，设计一种选择方式，使得当机器吐出第N号球的时候（N>K），你袋子的球数是K个，同时可以保证从1到N中的每一个，被选进袋子的概率都是K/N.

```java
public class Code_07_GetKNumsRand {

	// 随机函数决定一件事做还是不做
	public int rand(int max) {
		return (int) (Math.random() * max) + 1;
	}

	public int[] getKNumsRand(int k, int max) {
		if (max < 1 || k < 1) {
			return null;
		}
		int[] res = new int[Math.min(k, max)];
		for (int i = 0; i < res.length; i++) {
			res[i] = i + 1; // 前k个数直接进袋子
		}
		for (int i = k + 1; i < max + 1; i++) {
			if (rand(i) <= k) {// 决定i进不进袋子
				res[rand(k) - 1] = i; // i随机替换袋子中的一个
			}
		}
		return res;
	}
}
```



## 8 设计有setAll功能的哈希表

在哈希表的基础上，加一个setAll功能，就是把所有记录的value都设成统一的值。请设计并实现。

```java
import java.util.HashMap;

public class Code_08_HashMap {

	// 存入哈希表中的元素，加入了时间戳
	public class MyValue<V> {
		private V value;
		private long time;

		public MyValue(V value, long time) {
			this.value = value;
			this.time = time;
		}

		public V getValue() {
			return this.value;
		}

		public long getTime() {
			return this.time;
		}
	}

	public class MyHashMap<K, V> {
		private HashMap<K, MyValue<V>> baseMap;
		private long time;
		private MyValue<V> setAll;

		public MyHashMap() {
			this.baseMap = new HashMap<>();
			this.time = 0;
			this.setAll = new MyValue<V>(null, -1);
		}

		public boolean containsKey(K key) {
			return this.baseMap.containsKey(key);
		}

		public void put(K key, V value) {
			this.baseMap.put(key, new MyValue<V>(value, this.time++));
		}

		public void setAll(V value) {
			this.setAll = new MyValue<V>(value, this.time++);
		}

		public V get(K key) {
			if (this.containsKey(key)) {
				if (this.baseMap.get(key).getTime() > this.setAll.getTime()) {
					return this.baseMap.get(key).getValue();
				} else {
					return this.setAll.getValue();
				}
			} else {
				return null;
			}
		}
	}
}
```



## 9 最大的leftMax与rightMax之差的绝对值

 给定一个长度为N的整型数组arr，可以划分为左右两部分，左部分为arr[0...k]，右部分为arr[k+1...N-1]，k可以取值的范围是[0...N-2]。求这么多划分方案中，左部分的最大值减去右部分最大值的绝对值中，最大是多少？

```java
public class Code_09_MaxABS {

	public int maxABS_1(int[] arr) {
		int res = Integer.MIN_VALUE;
		int maxLeft = 0;
		int maxRight = 0;
		for (int i = 0; i < arr.length; i++) {
			// 找到左部分的最大值
			maxLeft = Integer.MIN_VALUE;
			for (int j = 0; j < i + 1; j++) {
				maxLeft = Math.max(arr[j], maxLeft);
			}
			// 找到右部分的最大值
			maxRight = Integer.MIN_VALUE;
			for (int j = i + 1; j < arr.length; j++) {
				maxRight = Math.max(arr[j], maxRight);
			}
			res = Math.max(Math.abs(maxLeft - maxRight), res);
		}
		return res;
	}

	public int maxABS_2(int[] arr) {
		int[] lArr = new int[arr.length]; // 左部分最大值
		int[] rArr = new int[arr.length]; // 右部分最大值
		lArr[0] = arr[0];
		rArr[arr.length - 1] = arr[arr.length - 1];
		for (int i = 1; i < rArr.length; i++) {
			lArr[i] = Math.max(lArr[i - 1], arr[i]);
		}
		for (int i = arr.length - 2; i > -1; i--) {
			rArr[i] = Math.max(rArr[i + 1], arr[i]);
		}
		int max = 0;
		for (int i = 0; i < rArr.length; i++) {
			max = Math.max(max, Math.abs(lArr[i] - rArr[i + 1]));
		}
		return max;
	}

	public int maxABS_3(int[] arr) {
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < arr.length; i++) {
			max = Math.max(arr[i], max);// 最大值不管左右都是最大
		}
		return max - Math.min(arr[0], arr[arr.length - 1]);// 只含有一个的时候尽量小
	}
}
```



## 10 设计可以变更的缓存结构

设计一种缓存结构，该结构在构造时确定大小，假设大小为K，并有两个功能：

- set(key,value)：将记录(key,value)插入该结构
- get(key)：返回key对应的value值

要求：

1. set和get方法的时间复杂度为o(1)
2. 某个key的set或get操作一旦发生，认为这个key的记录成为了最经常使用的
3. 当缓存的大小超过k时，移除最不经常使用的记录，即set或get最久远的

```java
import java.util.HashMap;

public class Code_10_MyCache {

	public class Node<V> {
		public V value;
		public Node<V> last;
		public Node<V> next;

		public Node(V value) {
			this.value = value;
		}
	}

	public class NodeDoubleLinkedList<V> {
		private Node<V> head;
		private Node<V> tail;

		public NodeDoubleLinkedList() {
			this.head = null;
			this.tail = null;
		}

		public void addNode(Node<V> newNode) {
			if (newNode == null) {
				return;
			}
			if (this.head == null) {
				this.head = newNode;
				this.tail = newNode;
			} else {
				this.tail.next = newNode;
				newNode.last = this.tail;
				this.tail = newNode;
			}
		}

		public void moveNodeToTail(Node<V> node) {
			if (this.tail == node) {
				return;
			}
			// 断开连接
			if (this.head == node) {
				this.head = node.next;
				this.head.last = null;
			} else {
				node.last.next = node.next;
				node.next.last = node.last;
			}
			node.last = this.tail;
			node.next = null;
			this.tail.next = node;
			this.tail = node;
		}

		public Node<V> removeHead() {
			if (this.head == null) {
				return null;
			}
			Node<V> res = this.head;
			if (this.head == this.tail) {
				this.head = null;
				this.tail = null;
			} else {
				this.head = res.next;
				res.next = null;
				this.head.last = null;
			}
			return res;
		}
	}

	public class MyCache<K, V> {
		private HashMap<K, Node<V>> keyNodeMap;
		private HashMap<Node<V>, K> nodeKeyMap;
		private NodeDoubleLinkedList<V> nodeList;
		private int capacity;

		public MyCache(int capacity) {
			if (capacity < 1) {
				throw new RuntimeException("should be more than 0.");
			}
			this.keyNodeMap = new HashMap<>();
			this.nodeKeyMap = new HashMap<>();
			this.nodeList = new NodeDoubleLinkedList<>();
			this.capacity = capacity;
		}

		public V get(K key) {
			if (this.keyNodeMap.containsKey(key)) {
				Node<V> res = this.keyNodeMap.get(key);
				this.nodeList.moveNodeToTail(res);
				return res.value;
			}
			return null;
		}

		public void set(K key, V value) {
			if (this.keyNodeMap.containsKey(key)) {
				Node<V> node = this.keyNodeMap.get(key);
				node.value = value;
				this.nodeList.moveNodeToTail(node);
			} else {
				Node<V> newNode = new Node<V>(value);
				this.keyNodeMap.put(key, newNode);
				this.nodeKeyMap.put(newNode, key);
				this.nodeList.addNode(newNode);
				if (this.keyNodeMap.size() == this.capacity + 1) {
					this.removeMostUnusedCache();
				}
			}
		}
		// 移除最不常使用的记录
		public void removeMostUnusedCache() {
			Node<V> removeNode = this.nodeList.removeHead();
			K removeKey = this.nodeKeyMap.get(removeNode);	//找到要删除的key
			this.nodeKeyMap.remove(removeNode);
			this.keyNodeMap.remove(removeKey);
		}
	}
}
```



## 11 设计RandomPool结构

设计一种结构，在该结构中有如下三个功能：

- insert(key)：将某个key加入到该结构，做到不重复插入
- delete(key)：将原本在结构中的某个key移除
- getRandom()：等概率随机返回结构中的任何一个key

```java
import java.util.HashMap;

public class Code_11_RandomPool {

	public class Pool<K> {
		private HashMap<K, Integer> keyIndexMap;
		private HashMap<Integer, K> indexKeyMap;
		private int size;

		public Pool() {
			this.keyIndexMap = new HashMap<>();
			this.indexKeyMap = new HashMap<>();
			this.size = 0;
		}

		public void insert(K key) {
			if (!this.keyIndexMap.containsKey(key)) {
				this.keyIndexMap.put(key, this.size);
				this.indexKeyMap.put(this.size++, key);
			}
		}

		public void delete(K key) {
			if (this.keyIndexMap.containsKey(key)) {
				int deleteIndex = this.keyIndexMap.get(key);
				int lastIndex = --this.size; // 最后一个索引
				K lastKey = this.indexKeyMap.get(lastIndex); // 最后一个key
				this.keyIndexMap.put(lastKey, deleteIndex);
				this.indexKeyMap.put(deleteIndex, lastKey);// 把最后一个放到删除的位置上
				this.keyIndexMap.remove(key);
				this.indexKeyMap.remove(lastIndex);// 删除最后一个
			}
		}

		public K getRandom() {
			if (this.size == 0) {
				return null;
			}
			int randomIndex = (int) (Math.random() * this.size);
			return this.indexKeyMap.get(randomIndex);
		}
	}
}
```



## 12 调整[0,x)区间上的数出现的概率

给定一个大于0的整数k，并且可以使用Math.random()函数，请实现一个函数依然返回在[0,1)范围上的数，但是在[0,1)区间上的数出现的概率为x^k(0<x<=1).

```java
public class Code_12_RandomXPowerK {

	// 调用k次Math.random函数
	public double randXPowerK(int k) {
		if (k < 1) {
			return 0;
		}
		double res = -1;
		for (int i = 0; i < k; i++) {
			res = Math.max(res, Math.random());
		}
		return res;
	}
}
```



## 13 路径数组变为统计数组

给定一个路径数组paths，表示一张图。path[i]==j代表城市i指向城市j，如果paths[i]==i则表示城市i是首都，一张图只会有一个首都且图中除首都指向自己外不会有环。

例如，paths=[9,1,4,9,0,4,8,9,0,1].

统计数组nums=[1,1,3,2,3,0,0,0,0,0]，nums[i]==j代表距离为i的城市有j座。

要实现一个void类型的函数，输入一个路径数组paths，直接在原数组上调整，使之变为nums数组。

```java
public class Code_13_PathsToNums {

	// 转换为距离数组
	// paths[i]==j代表城市i距离首都的距离为j（负值）
	public void pathsToDistans(int[] paths) {
		int cap = 0;
		for (int i = 0; i < paths.length; i++) {
			if (paths[i] == i) { // 首都
				cap = i;
			} else if (paths[i] > -1) {
				int curI = paths[i];
				paths[i] = -1; // 出发点暂设为-1
				int preI = i;
				while (paths[curI] != curI) { // 跳到首都为止
					if (paths[curI] > -1) { // 为正表示之前没有遍历过
						int nextI = paths[curI];// 下一个要跳的点
						paths[curI] = preI; // 设置为前一个点
						preI = curI;
						curI = nextI; // 继续下跳
					} else {
						break;
					}
				}
				int value = paths[curI] == curI ? 0 : paths[curI]; // 距离值
				while (paths[preI] != -1) { // 沿路径回跳
					int lastPreI = paths[preI];
					paths[preI] = --value; // 更新距离值
					curI = preI;
					preI = lastPreI;
				}
				paths[preI] = --value;
			}
		}
		paths[cap] = 0; // 首都值设为0
	}

	// 距离数组转成统计数组
	public void distansToNums(int[] disArr) {
		for (int i = 0; i < disArr.length; i++) {
			int index = disArr[i];
			if (index < 0) {
				disArr[i] = 0; // 先设为0表示开始统计
				while (true) {
					index = -index; // 转为正
					if (disArr[index] > -1) { // 正值表示遍历过
						disArr[index]++;
						break;
					} else { // 负值表示未遍历过
						int nextIndex = disArr[index];
						disArr[index] = 1;
						index = nextIndex;
					}
				}
			}
		}
		disArr[0] = 1; // 首都的距离才为1
	}

	public void pathsToNums(int[] paths) {
		if (paths == null || paths.length == 0) {
			return;
		}
		pathsToDistans(paths);
		distansToNums(paths);
	}
}
```



## 14 正数数组的最小不可组成和

给定一个正数数组arr，其中所有值都是整数，以下是最小不可组成和的概念：

- 把arr每个子集内的所有元素加起来会出现很多值，其中最小的记为min，最大的记为max
- 在区间[min,max]上，如果有数不可以被arr的某一个子集相加得到，那么其中最小的那个数是arr的最小不可组成和，如果其中所有的数都可以相加得到，那么max+1是arr的最小不可组成和

请写函数返回正数数组arr的最小不可组成和

```java
import java.util.HashSet;

public class Code_14_UnformedSum {

	public int unformedSum_1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		HashSet<Integer> set = new HashSet<>();
		process(arr, 0, 0, set);// 收集所有子集的和
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < arr.length; i++) {
			min = Math.min(min, arr[i]); // 找到最小值
		}
		for (int i = min + 1; i != Integer.MIN_VALUE; i++) {
			if (!set.contains(i)) { // 找到第一个不含的和
				return i;
			}
		}
		return 0;
	}

	public void process(int[] arr, int i, int sum, HashSet<Integer> set) {
		if (i == arr.length) {
			set.add(sum);
			return;
		}
		process(arr, i + 1, sum, set); // 包含当前数arr[i]的情况
		process(arr, i + 1, sum + arr[i], set);// 不包含当前数arr[i]的情况
	}

	// 动态规划
	public int unformedSum_2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 1;
		}
		int sum = 0; // 所有值的累加和
		int min = Integer.MAX_VALUE; // 最小值
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			min = Math.min(min, arr[i]);
		}
		boolean[] dp = new boolean[sum + 1];
		dp[0] = true;
		for (int i = 0; i < dp.length; i++) {
			for (int j = sum; j >= arr[i]; j--) {
				dp[j] = dp[j - arr[i]] ? true : dp[j];
			}
		}
		for (int i = min; i < dp.length; i++) {
			if (!dp[i]) {
				return i;
			}
		}
		return sum + 1;
	}
}
```

如果已知正数数组arr中肯定有1这个数，是否能更快的得到最小不可组成和。

```java
import java.util.Arrays;

public class Code_14_UnformedSum {

	public int unformedSum_3(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		Arrays.sort(arr); // 先排序
		int range = 0; // 当前[1,range]区间都可以被相加出来
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] > range + 1) {
				return range + 1;
			} else {
				range += arr[i];
			}
		}
		return range + 1;
	}
}
```



## 15 一种字符串和数字的对应关系

一个char类型的数组chs，其中所有的字符都不同。

例如，chs=['A','B','C',...'Z']，则字符串与整数的对应关系如下：

A,B...Z,AA,AB...AZ,BA,BB...ZZ,AAA...ZZZ...AAAA...

1,2...26,27,28...52,53,54...702,703....

给定一个数组chs，实现根据对应关系完成字符串与整数相互转换的两个函数。

```java
public class Code_15_StrToNum {

	public String getString(char[] chs, int n) {
		if (chs == null || chs.length == 0) {
			return "";
		}
		int cur = 1; // 当前位表示的大小
		int base = chs.length; // base伪进制
		int len = 0; // 转换后的长度
		// 处理后每一位都相当于加一
		while (n >= cur) {
			len++;
			n -= cur;
			cur *= base;
		}
		char[] res = new char[len];
		int index = 0;
		int nCur = 0;
		do {
			cur /= base; // 向低位退
			nCur = n / cur; // 能否包含当前位
			res[index++] = getKthCharAtChs(chs, nCur + 1);
			n %= cur; // 剩下部分
		} while (index != res.length);
		return String.valueOf(res);
	}

	// 获取chs数组中k个字符
	public char getKthCharAtChs(char[] chs, int k) {
		if (k < 1 || k > chs.length) {
			return 0;
		}
		return chs[k - 1];
	}

	public int getNum(char[] chs, String str) {
		if (chs == null || chs.length == 0) {
			return 0;
		}
		char[] strc = str.toCharArray();
		int base = chs.length;
		int cur = 1;
		int res = 0;
		for (int i = strc.length - 1; i != -1; i--) {
			res += getNthFromChar(chs, strc[i]) * cur;
			cur *= base;
		}
		return res;
	}

	// 找出字符ch代表的数字
	public int getNthFromChar(char[] chs, char ch) {
		int res = -1;
		for (int i = 0; i < chs.length; i++) {
			if (chs[i] == ch) {
				res = i + 1;
				break;
			}
		}
		return res;
	}
}
```



## 16 1到n中1出现的次数

给定一个整数n，返回从1到n的数字中1出现的个数。

```java
public class Code_16_GetOneNum {

	public int solution_1(int num) {
		if (num < 1) {
			return 0;
		}
		int count = 0;
		for (int i = 1; i != num + 1; i++) {
			count += get1Nums(i);
		}
		return count;
	}

	public int get1Nums(int num) {
		int res = 0;
		while (num != 0) {
			if (num % 10 == 1) {
				res++;
			}
			num /= 10;
		}
		return res;
	}

	public int solution_2(int num) {
		if (num < 1) {
			return 0;
		}
		int len = getLenOfNum(num);
		if (len == 1) { // 只有1位
			return 1;
		}
		int tmp1 = powerBaseOf10(len - 1);
		int first = num / tmp1; // 最高位
		int firstOneNum = first == 1 ? num % tmp1 + 1 : tmp1; // 为1取余，不为1取全部
		int otherOneNum = first * (len - 1) * (tmp1 / 10);// 最高位数字x除去最高位剩下的位数x某一位固定是1其他位数可以从0~9变化
		return firstOneNum + otherOneNum + solution_2(num % tmp1);
	}

	public int getLenOfNum(int num) {
		int len = 0;
		while (num != 0) {
			len++;
			num /= 10;
		}
		return len;
	}

	public int powerBaseOf10(int base) {
		return (int) Math.pow(10, base);
	}
}
```



## 17 从N个数中等概率打印M个数

给定一个长度为N且没有重复元素的数组arr和一个整数n，实现函数等概率随机打印arr中的M个数。

```java
public class Code_17_PrintRandM {

	public void printRandM(int[] arr, int m) {
		if (arr == null || arr.length == 0 || m < 0) {
			return;
		}
		m = Math.min(arr.length, m);
		int count = 0;
		int i = 0;
		while (count < m) {
			i = (int) (Math.random() * (arr.length - count));
			System.out.println(arr[i]);

		}
	}

	public void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}
}
```



## 18 判断一个数是否是回文数

给定一个32位整数num，判断num是否是回文数（负数考虑其绝对值）

```java
public class Code_18_IsPalindrome {

	public boolean isPalindrome(int n) {
		if (n == Integer.MIN_VALUE) {
			return false; // 绝对值会溢出单独考虑
		}
		n = Math.abs(n);
		int help = 1;
		while (n / help >= 10) {// 防止help溢出
			help *= 10;
		}
		while (n != 0) {
			if (n / help != n % 10) {
				return false;
			}
			n = (n % help) / 10;
			help /= 100;
		}
		return true;
	}
}
```



## 19 在有序旋转数组中找到最小值

有序旋转数组arr可能经过一次旋转处理，也可能没有，且arr可能存在重复的值。给定一个可能旋转后的有序数组arr，返回arr中的最小值。

```java
public class Code_19_GetMin {

	public int getMin(int[] arr) {
		int low = 0;
		int high = arr.length - 1;
		int mid = 0;
		while (low < high) {
			if (low == high - 1) {
				break;
			}
			if (arr[low] < arr[high]) {
				return arr[low];
			}
			// 利用二分查找
			mid = (low + high) / 2;
			if (arr[low] > arr[mid]) {
				high = mid;
				continue;
			}
			if (arr[mid] > arr[high]) {
				low = mid;
				continue;
			}
			// 此时arr[low]==arr[mid]==arr[high]
			while (low < mid) {
				if (arr[low] == arr[mid]) {
					low++;
				} else if (arr[low] < arr[mid]) {
					return arr[low];
				} else {
					high = mid;
					break;
				}
			}
		}
		return Math.min(arr[low], arr[high]);
	}
}
```



## 20 在有序旋转数组中找到一个数

有序旋转数组arr可能经过一次旋转处理，也可能没有，且arr可能存在重复的值。给定一个可能旋转后的有序数组arr，再给定一个数num，返回arr中是否含有num。

```java
public class Code_20_IsContains {

	public boolean isContains(int[] arr, int num) {
		int low = 0;
		int high = arr.length - 1;
		int mid = 0;
		while (low <= high) {
			mid = (low + high) / 2;
			if (arr[mid] == num) {
				return true;
			}
			if (arr[low] == arr[mid] && arr[mid] == arr[high] && arr[low] == arr[high]) { // 三个值都相等此时无法直接判断
				while (low != mid && arr[low] == arr[mid]) {
					low++;
				}
				if (low == mid) {
					low = mid + 1;// 在右半区
					continue;
				}
				// 此处arr[low]！=arr[mid]
			}
			if (arr[low] != arr[mid]) {
				if (arr[mid] > arr[low]) { // low...mid有序
					if (num >= arr[low] && num < arr[mid]) {
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				} else { // mid...high有序
					if (num > arr[mid] && num <= arr[high]) {
						low = mid + 1;
					} else {
						high = mid - 1;
					}
				}
			} else { // arr[mid] != arr[high]
				if (arr[mid] < arr[high]) { // mid...high有序
					if (num > arr[mid] && num <= arr[high]) {
						low = mid + 1;
					} else {
						high = mid - 1;
					}
				} else {// low...mid有序
					if (num >= arr[low] && num < arr[mid]) {
						high = mid - 1;
					} else {
						low = mid + 1;
					}
				}
			}
		}
		return false;
	}
}
```



## 21 数字的英文表达和中文表达

给定一个32位整数num，写两个函数分别返回num的英文与中文表达字符串。

```java
public class Code_21_NumExpress {

	public String num1To19(int num) {
		if (num < 1 || num > 19) {
			return "";
		}
		String[] names = { "one ", "two ", "three ", "four ", "five ", "six ", "seven ", "eight ", "nine ", "ten ",
				"eleven ", "twelve ", "thirteen ", "fourteen ", "fifteen ", "sixteen ", "seventeen ", "eighteen ",
				"nineteen " };
		return names[num - 1];
	}

	public String num1To99(int num) {
		if (num < 1 || num > 999) {
			return "";
		}
		if (num < 20) {
			return num1To19(num);
		}
		int high = num / 10;
		String[] tyNames = { "twenty ", "thirty ", "forty ", "fifty ", "sixty ", "seventy ", "eighty ", "ninety " };
		return tyNames[high - 2] + num1To19(num % 10);
	}

	public String num1To999(int num) {
		if (num < 1 || num > 99) {
			return "";
		}
		if (num < 100) {
			return num1To99(num);
		}
		int high = num / 100;
		return num1To19(high) + "hundred " + num1To99(num % 100);
	}

	public String getNumEngExp(int num) {
		if (num == 0) {
			return "zero";
		}
		String res = "";
		if (num < 0) {
			res = "Negative, ";
		}
		if (num == Integer.MIN_VALUE) {
			res += "two billion, ";
			num %= -2000000000;
		}
		num = Math.abs(num);
		int high = 1000000000;
		int highIndex = 0;
		String[] names = { "billion", "million", "thousand", "" };
		while (num != 0) {
			int cur = num / high;
			num %= high;
			if (cur != 0) {
				res += num1To999(cur);
				res += names[highIndex] + (num == 0 ? " " : ", ");
			}
			high /= 1000; // 3个数一组
			highIndex++;
		}
		return res;
	}
}
```

```java
public class Code_21_NumExpress {

	public String num1To9(int num) {
		if (num < 1 || num > 9) {
			return "";
		}
		String[] names = { "一", "二", "三", "四", "五", "六", "七", "八", "九" };
		return names[num - 1];
	}

	public String num1To99(int num, boolean hasBai) {
		if (num < 1 || num > 99) {
			return "";
		}
		if (num < 10) {
			return num1To9(num);
		}
		int shi = num / 10;
		if (shi == 1 && (!hasBai)) {
			return "十" + num1To9(num % 10); // 不含百位特殊处理以下
		} else {
			return num1To9(shi) + "十" + num1To9(num % 10);
		}
	}

	public String num1To999_c(int num) {
		if (num < 1 || num > 999) {
			return "";
		}
		if (num < 100) {
			return num1To99(num, false);
		}
		String res = num1To9(num / 100) + "百";
		int rest = num % 100;
		if (rest == 0) {
			return res;
		} else if (rest >= 10) {
			res += num1To99(rest, true);
		} else {
			res += "零" + num1To9(rest);
		}
		return res;
	}

	public String num1To9999(int num) {
		if (num < 1 || num > 9999) {
			return "";
		}
		if (num < 1000) {
			return num1To999_c(num);
		}
		String res = num1To9(num / 1000) + "千";
		int rest = num % 1000;
		if (rest == 0) {
			return res;
		} else if (rest >= 100) {
			res += num1To999_c(rest);
		} else {
			res += "零" + num1To99(rest, false);
		}
		return res;
	}

	public String num1To99999999(int num) {
		if (num < 1 || num > 99999999) {
			return "";
		}
		int wan = num / 10000;
		int rest = num % 10000;
		if (wan == 0) {
			return num1To9999(num);
		}
		String res = num1To9(num / 1000) + "千";
		if (rest == 0) {
			return res;
		} else {
			if (rest < 1000) {
				return res + "零" + num1To999_c(rest);
			} else {
				return res + num1To9999(rest);
			}
		}
	}

	public String getNumChiExp(int num) {
		if (num == 0) {
			return "零";
		}
		String res = num < 0 ? "负" : "";
		int yi = Math.abs(num / 100000000);
		int rest = Math.abs(num % 100000000);
		if (yi == 0) {
			return res + num1To99999999(num);
		}
		res += num1To9999(yi) + "亿";
		if (rest == 0) {
			return res;
		} else {
			if (rest < 10000000) {
				return res + "零" + num1To99999999(rest);
			} else {
				return res + num1To99999999(rest);
			}
		}
	}
}
```



## 22 分糖果问题

一群孩子做游戏，请你根据游戏得分发糖果，要求如下：

1. 每个孩子不管得分多少，起码分到1个糖果
2. 任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果

给定一个数组arr代表得分数组，请返回最少需要多少糖果。

```java
public class Code_22_Candy {

	public int candy(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		// 先处理开头的下坡
		int index = nextMinIndex(arr, 0);
		int res = rightCands(arr, 0, index++);
		int lbase = 1; // 上坡节点个数
		int next = 0;
		int rcands = 0; // 下坡分配糖果数
		int rbase = 0; // 下坡节点个数
		while (index != arr.length) {
			if (arr[index] > arr[index - 1]) { // 上坡
				res += ++lbase;
				index++;
			} else if (arr[index] < arr[index - 1]) { // 下坡
				next = nextMinIndex(arr, index - 1);
				rcands = rightCands(arr, index - 1, next++);
				rbase = next - index + 1;
				res += rcands + (rbase > lbase ? -lbase : -rbase); // 哪边大决定顶点数量
				lbase = 1;
				index = next;
			} else { // 相等值
				res += 1;
				lbase = 1;
				index++;
			}
		}
		return res;
	}

	// 找到下一个小值
	public int nextMinIndex(int[] arr, int start) {
		for (int i = start; i < arr.length - 1; i++) {
			if (arr[i] <= arr[i + 1]) {
				return i;
			}
		}
		return arr.length - 1;
	}

	// 计算下坡糖果数
	public int rightCands(int[] arr, int left, int right) {
		int n = right - left + 1;
		return n + n * (n - 1) / 2;
	}
}
```

在原题目两个规则不变的前提下再加一条：

3. 任意两个相邻的孩子之间如果得分一样，糖果数量必须相等

给定一个数组arr代表得分数组，请返回最少需要多少糖果。

```java
public class Code_22_Candy {

	public int candy2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int index = nextMinIndex2(arr, 0);
		int[] data = rightCandsAndBase(arr, 0, index++);
		int res = data[0];
		int lbase = 1;
		int same = 1; // 相同数字的数量
		int next = 0;
		while (index != arr.length) {
			if (arr[index] > arr[index - 1]) { // 上坡
				res += ++lbase;
				same = 1;
				index++;
			} else if (arr[index] < arr[index - 1]) { // 下坡
				next = nextMinIndex2(arr, index - 1);
				data = rightCandsAndBase(arr, index - 1, next++);
				if (data[1] <= lbase) { // 上坡较多
					res += data[0] - data[1];
				} else {// 下坡较多
					res += -lbase * same + data[0] - data[1] + data[1] * same;
				}
				index = next;
				lbase = 1;
				same = 1;
			} else {
				res += lbase; // 坡顶才会发生相等
				same++;
				index++;
			}
		}
		return res;
	}

	public int nextMinIndex2(int[] arr, int start) {
		for (int i = start; i < arr.length - 1; i++) {
			if (arr[i] < arr[i + 1]) { // 此处不包含等于
				return i;
			}
		}
		return arr.length - 1;
	}

	public int[] rightCandsAndBase(int[] arr, int left, int right) {
		int base = 1;
		int cands = 1;
		for (int i = right - 1; i >= left; i--) {
			if (arr[i] == arr[i + 1]) {
				cands += base; // 相等部分
			} else {
				cands += ++base;
			}
		}
		return new int[] { cands, base };
	}
}
```



## 23 一种消息接收并打印的结构设计

已知一个消息流会不断地吐出整数1~N，但不一定按照顺序吐出。如果上次打印的数为i，那么当i+1出现时，请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构。

```java
import java.util.HashMap;

public class Code_23_MessageBox {

	public class Node {
		public int num;
		public Node next;

		public Node(int num) {
			this.num = num;
		}
	}

	public class MessageBox {
		private HashMap<Integer, Node> headMap;
		private HashMap<Integer, Node> tailMap;
		private int lastPrint;

		public MessageBox() {
			headMap = new HashMap<>();
			tailMap = new HashMap<>();
			lastPrint = 0;
		}

		public void receive(int num) {
			if (num < 1) {
				return;
			}
			Node cur = new Node(num);
			headMap.put(num, cur);
			tailMap.put(num, cur);
			if (tailMap.containsKey(num - 1)) {
				tailMap.get(num - 1).next = cur;
				tailMap.remove(num - 1);
				headMap.remove(num);
			}
			if (headMap.containsKey(num + 1)) {
				cur.next = headMap.get(num + 1);
				tailMap.remove(num);
				headMap.remove(num + 1);
			}
			if (headMap.containsKey(lastPrint + 1)) {
				print();
			}
		}

		public void print() {
			Node node = headMap.get(++lastPrint);
			headMap.remove(lastPrint);
			while (node != null) {
				System.out.print(node.num + " ");
				node = node.next;
				lastPrint++;
			}
			tailMap.remove(--lastPrint);
			System.out.println();
		}
	}
}
```



## 24 设计一个没有扩容负担的堆结构

堆结构一般是使用固定长度的数组来实现的，存在扩容的负担，当固定长度数组耗尽时，就需要申请一个更大的固定数组，然后把原来数组的对象复制到新的数组中完成扩容，扩容行为的时间复杂度为o(N)，请设计一种没有扩容负担的堆结构，即在任何时刻有关堆的操作时间复杂度都不超过o(logN).

```java
import java.util.Comparator;

public class Code_24_MyHeap {

	public class Node<K> {
		public K value;
		public Node<K> left;
		public Node<K> right;
		public Node<K> parent;

		public Node(K data) {
			value = data;
		}
	}

	public class MyHeap<K> {
		private Node<K> head; // 堆头节点
		private Node<K> last; // 堆尾节点
		private long size; // 当前堆的大小
		private Comparator<K> comp;// 大根堆或小根堆

		public MyHeap(Comparator<K> comparator) {
			head = null;
			last = null;
			size = 0;
			comp = comparator;
		}

		public K getHead() {
			return head == null ? null : head.value;
		}

		public long getSize() {
			return size;
		}

		public boolean isEmpty() {
			return size == 0 ? true : false;
		}

		public void add(K value) {
			Node<K> newNode = new Node<K>(value);
			if (size == 0) { // 原本为空
				head = newNode;
				last = newNode;
				size++;
				return;
			}
			Node<K> node = last; // 完全二叉树最后一个节点
			Node<K> parent = node.parent;
			// 找到正确的位置并插入到新节点
			while (parent != null && node != parent.left) {
				node = parent;
				parent = node.parent;
			}
			Node<K> nodeToAdd = null;
			if (parent == null) { // last是当前层最后一个，新节点加入下一行
				nodeToAdd = mostLeft(head);
				nodeToAdd.left = newNode;
				newNode.parent = nodeToAdd;
			} else if (parent.right == null) {// last是左孩子，新节点插入到右孩子
				parent.right = newNode;
				newNode.parent = parent;
			} else { // last是右孩子且本层未满
				nodeToAdd = mostLeft(parent.right);// 右孩子的最左位置
				nodeToAdd.left = newNode;
				newNode.parent = nodeToAdd;
			}
			last = newNode;// 更新堆尾节点
			// 建堆过程及其调整
			heapInsertModify();
			size++;
		}

		public K popHead() {
			if (size == 0) {
				return null;
			}
			Node<K> res = head;
			if (size == 1) {
				head = null;
				last = null;
				size--;
				return res.value;
			}
			Node<K> oldLast = popLastAndSetPreviousLast();
			// 如果弹出堆尾节点后，堆的大小等于1的处理
			if (size == 1) {
				head = oldLast;
				last = oldLast;
				return res.value;
			}
			// 如果弹出堆尾节点后，堆的大小大于1的处理
			Node<K> headLeft = res.left;
			Node<K> headRight = res.right;
			// 将最后节点插入到头节点
			oldLast.left = headLeft;
			if (headLeft != null) {
				headLeft.parent = oldLast;
			}
			oldLast.right = headRight;
			if (headRight != null) {
				headRight.parent = oldLast;
			}
			res.left = null;
			res.right = null;
			head = oldLast;
			// 堆heapify过程
			heapify(oldLast);
			return res.value;
		}

		// 找到以node为头的子数中最左的节点
		private Node<K> mostLeft(Node<K> node) {
			while (node.left != null) {
				node = node.left;
			}
			return node;
		}

		// 找到以node为头的子数中最右的节点
		private Node<K> mostRight(Node<K> node) {
			while (node.right != null) {
				node = node.right;
			}
			return node;
		}

		// 建堆及调整的过程
		private void heapInsertModify() {
			Node<K> node = last;
			Node<K> parent = node.parent;
			if (parent != null && comp.compare(node.value, parent.value) < 0) {
				last = parent; // 更新尾节点
			}
			while (parent != null && comp.compare(node.value, parent.value) < 0) {
				swapClosedTwoNodes(node, parent);
				parent = node.parent;
			}
			if (head.parent != null) { // 更新头节点
				head = head.parent;
			}
		}

		// 交换相邻的两个节点
		private void swapClosedTwoNodes(Node<K> node, Node<K> parent) {
			if (node == null || parent == null) {
				return;
			}
			Node<K> parentParent = parent.parent;
			Node<K> parentLeft = parent.left;
			Node<K> parentRight = parent.right;
			Node<K> nodeleft = node.left;
			Node<K> nodeRight = node.right;
			node.parent = parentParent;
			// 插入到父节点的父节点上
			if (parentParent != null) {
				if (parent == parentParent.left) {
					parentParent.left = node;
				} else {
					parentParent.right = node;
				}
			}
			parent.parent = node;
			// 原节点的孩子接到父节点上
			if (nodeleft != null) {
				nodeleft.parent = parent;
			}
			if (nodeRight != null) {
				nodeRight.parent = parent;
			}
			if (node == parent.left) { // 原来的节点是左孩子
				node.left = parent;
				node.right = parentRight;
				if (parentRight != null) {
					parentRight.parent = node;
				}
			} else { // 原来的节点是右孩子
				node.left = parentLeft;
				node.right = parent;
				if (parentLeft != null) {
					parentLeft.parent = node;
				}
			}
			parent.left = nodeleft;
			parent.right = nodeRight;
		}

		// 在树中弹出堆尾节点，找到原来倒数第二节点设置成新的堆尾节点
		private Node<K> popLastAndSetPreviousLast() {
			Node<K> node = last;
			Node<K> parent = node.parent;
			while (parent != null && node != parent.right) {
				node = parent;
				parent = node.parent;
			}
			if (parent == null) {
				node = last;
				parent = node.parent;
				node.parent = null;
				if (node == parent.left) {
					parent.left = null;
				} else {
					parent.right = null;
				}
				last = mostRight(head);
			} else {
				Node<K> newLast = mostRight(parent.left);
				node = last;
				parent = node.parent;
				node.parent = null;
				if (node == parent.left) {
					parent.left = null;
				} else {
					parent.right = null;
				}
				last = newLast;
			}
			size--;
			return node;
		}

		// 堆heapify过程
		private void heapify(Node<K> node) {
			Node<K> left = node.left;
			Node<K> right = node.right;
			Node<K> most = node;
			while (left != null) {
				if (left != null && comp.compare(left.value, most.value) < 0) {
					most = left;
				}
				if (right != null && comp.compare(right.value, most.value) < 0) {
					most = right;
				}
				if (most != node) {
					swapClosedTwoNodes(most, node);
				} else {
					break;
				}
				left = node.left;
				right = node.right;
				most = node;
			}
			if (node.parent == last) { // 更新last
				last = node;
			}
			while (node.parent != null) { // 向上寻找头
				node = node.parent;
			}
			head = node; // 更新头节点
		}
	}
}
```



## 25 随时找到数据流的中位数

有一个源源不断地吐出整数地数据流，假设有足够地空间来保存吐出的数，请设计一种名为MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。

```java
import java.util.Comparator;
import java.util.PriorityQueue;

public class Code_25_MedianHolder {

	public class MedianHolder {
		private PriorityQueue<Integer> minHeap; // 小根堆
		private PriorityQueue<Integer> maxHeap; // 大根堆

		public MedianHolder() {
			this.minHeap = new PriorityQueue<Integer>(new MinHeapComparator());
			this.maxHeap = new PriorityQueue<Integer>(new MaxHeapComparator());
		}

		public void addNumber(Integer num) {
			if (this.maxHeap.isEmpty()) {
				this.maxHeap.add(num);
				return;
			}
			if (this.maxHeap.peek() >= num) {
				this.maxHeap.add(num);
			} else {
				if (this.minHeap.isEmpty()) {
					this.minHeap.add(num);
					return;
				}
				if (this.minHeap.peek() > num) {
					this.maxHeap.add(num);
				} else {
					this.minHeap.add(num);
				}
			}
			modifyTwoHeapSize();
		}

		// 得到数据流的中位数
		public Integer getMedian() {
			long maxHeapSize = this.maxHeap.size();
			long minHeapSize = this.minHeap.size();
			if (maxHeapSize + minHeapSize == 0) {
				return null;
			}
			Integer maxHeapHead = this.maxHeap.peek();
			Integer minHeapHead = this.minHeap.peek();
			if (((maxHeapSize + minHeapSize) & 1) == 0) { // 偶数个元素
				return (maxHeapHead + minHeapHead) / 2;
			} else if (maxHeapSize > minHeapSize) {
				return maxHeapHead;
			} else {
				return minHeapHead;
			}
		}

		private void modifyTwoHeapSize() {
			if (this.maxHeap.size() == this.minHeap.size() + 2) {
				this.minHeap.add(this.maxHeap.poll());
			}
			if (this.minHeap.size() == this.maxHeap.size() + 2) {
				this.maxHeap.add(this.minHeap.poll());
			}
		}
	}

	// 生成大根堆的比较器
	public class MaxHeapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o2 > o1 ? 1 : -1;
		}
	}

	// 生成小根堆的比较器
	public class MinHeapComparator implements Comparator<Integer> {
		@Override
		public int compare(Integer o1, Integer o2) {
			return o1 > o2 ? 1 : -1;
		}
	}

}
```



## 26 在两个长度相等的排序数组中找到中位数

给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的中位数。

```java
public class Code_26_GetUpMedian {

	public int getUpMedian(int[] arr1, int[] arr2) {
		if (arr1 == null || arr2 == null || arr1.length != arr2.length) {
			throw new RuntimeException("Your arr is invalid!");
		}
		int start1 = 0;
		int end1 = arr1.length - 1;
		int start2 = 0;
		int end2 = arr2.length - 1;
		int mid1 = 0;
		int mid2 = 0;
		int offset = 0;
		while (start1 < end1) {
			mid1 = (start1 + end1) / 2;
			mid2 = (start2 + end2) / 2;
			// 元素个数为奇数offset为0，元素个数为偶数offset为1
			offset = ((end1 - start1 + 1) & 1) ^ 1;
			if (arr1[mid1] > arr2[mid2]) {
				end1 = mid1;
				start2 = mid2 + offset;
			} else if (arr1[mid1] < arr2[mid2]) {
				start1 = mid1 + offset;
				end2 = mid2;
			} else {
				return arr1[mid1];
			}
		}
		return Math.min(arr1[start1], arr2[start2]);
	}
}
```



## 27 在两个排序数组中找到第K小的数

给定两个有序数组arr1和arr2，再给定一个整数k，返回所有的数中第K小的数。

```java
public class Code_27_FindKthNum {

	public int findKthNum(int[] arr1, int[] arr2, int kth) {
		if (arr1 == null || arr2 == null) {
			throw new RuntimeException("Your arr is invalid.");
		}
		if (kth < 1 || kth > arr1.length + arr2.length) {
			throw new RuntimeException("K is invalid.");
		}
		int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
		int[] shorts = arr1.length < arr2.length ? arr1 : arr2;
		int l = longs.length;
		int s = shorts.length;
		if (kth <= s) {
			return getUpMedian(shorts, 0, kth - 1, longs, 0, kth - 1);
		}
		if (kth > l) {
			if (shorts[kth - l - 1] >= longs[l - 1]) {
				return shorts[kth - l - 1];
			}
			if (longs[kth - s - 1] >= shorts[s - 1]) {
				return longs[kth - s - 1];
			}
			return getUpMedian(shorts, kth - 1, s - 1, longs, kth - s, l - 1);
		}
		if (longs[kth - s - 1] >= shorts[s - 1]) {
			return longs[kth - s - 1];
		}
		return getUpMedian(shorts, 0, s - 1, longs, kth - s, kth - 1);
	}

	public int getUpMedian(int[] arr1, int start1, int end1, int[] arr2, int start2, int end2) {
		int mid1 = 0;
		int mid2 = 0;
		int offset = 0;
		while (start1 < end1) {
			mid1 = (start1 + end1) / 2;
			mid2 = (start2 + end2) / 2;
			// 元素个数为奇数offset为0，元素个数为偶数offset为1
			offset = ((end1 - start1 + 1) & 1) ^ 1;
			if (arr1[mid1] > arr2[mid2]) {
				end1 = mid1;
				start2 = mid2 + offset;
			} else if (arr1[mid1] < arr2[mid2]) {
				start1 = mid1 + offset;
				end2 = mid2;
			} else {
				return arr1[mid1];
			}
		}
		return Math.min(arr1[start1], arr2[start2]);
	}
}
```



## 28 两个有序数组间相加和的TOP K问题

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组。

```java
import java.util.HashSet;

public class Code_28_TopKSum {

	public class HeapNode {
		public int row;
		public int col;
		public int value;

		public HeapNode(int row, int col, int value) {
			this.row = row;
			this.col = col;
			this.value = value;
		}
	}

	public int[] topKSum(int[] a1, int[] a2, int topK) {
		if (a1 == null || a2 == null || topK < 1) {
			return null;
		}
		topK = Math.min(topK, a1.length * a2.length);
		HeapNode[] heap = new HeapNode[topK + 1];
		int heapSize = 0;
		int headR = a1.length - 1;
		int headC = a2.length - 1;
		int uR = -1;
		int uC = -1;
		int lR = -1;
		int lC = -1;
		heapInsert(heap, heapSize++, headR, headC, a1[headR] + a2[headC]);
		HashSet<String> positionSet = new HashSet<String>();
		int[] res = new int[topK];
		int resIndex = 0;
		while (resIndex != topK) {
			HeapNode head = popHead(heap, heapSize--);
			res[resIndex++] = head.value;
			headR = head.row;
			headC = head.col;
			uR = headR - 1;
			uC = headC;
			if (headR != 0 && !isContains(uR, uC, positionSet)) {
				heapInsert(heap, heapSize++, uR, uC, a1[uR] + a2[uC]);
				addPositionToSet(uR, uC, positionSet);
			}
			lR = headR;
			lC = headC - 1;
			if (headC != 0 && !isContains(lR, lC, positionSet)) {
				heapInsert(heap, heapSize++, lR, lC, a1[lR] + a2[lC]);
				addPositionToSet(lR, lC, positionSet);
			}
		}
		return res;
	}

	// 弹出堆的头并调整结构
	public HeapNode popHead(HeapNode[] heap, int heapSize) {
		HeapNode res = heap[0];
		swap(heap, 0, heapSize - 1);
		heap[--heapSize] = null;
		heapify(heap, 0, heapSize);
		return res;
	}

	public void heapify(HeapNode[] heap, int index, int heapSize) {
		int left = index * 2 + 1;
		int right = index * 2 + 2;
		int largest = index;
		while (left < heapSize) {
			if (heap[left].value > heap[index].value) {
				largest = left;
			}
			if (right < heapSize && heap[right].value > heap[largest].value) {
				largest = right;
			}
			if (largest != index) {
				swap(heap, largest, index);
			} else {
				break;
			}
			index = largest;
			left = index * 2 + 1;
			right = index * 2 + 2;
		}
	}

	public void heapInsert(HeapNode[] heap, int index, int row, int col, int value) {
		heap[index] = new HeapNode(row, col, value);
		int parent = (index - 1) / 2;
		while (index != 0) {
			if (heap[index].value > heap[parent].value) {
				swap(heap, parent, index);
				index = parent;
				parent = (index - 1) / 2;
			} else {
				break;
			}
		}
	}

	public void swap(HeapNode[] heap, int index1, int index2) {
		HeapNode tmp = heap[index1];
		heap[index1] = heap[index2];
		heap[index2] = tmp;
	}

	// 堆中是否包含当前值的记录
	public boolean isContains(int row, int col, HashSet<String> set) {
		return set.contains(String.valueOf(row + "_" + col));
	}

	// 添加记录
	public void addPositionToSet(int row, int col, HashSet<String> set) {
		set.add(String.valueOf(row + "_" + col));
	}
}
```



## 29 出现次数的TOP K问题 

给定String类型的数组strArr，再给定整数k，请严格按照排名顺序打印出现次数的前k名的字符串。

```java
import java.util.HashMap;
import java.util.Map.Entry;

public class Code_29_TopKTimes {

	public class Node {
		public String str;
		public int times;

		public Node(String s, int t) {
			str = s;
			times = t;
		}
	}

	public void printTopKAndRank(String[] arr, int topK) {
		if (arr == null || topK < 1) {
			return;
		}
		HashMap<String, Integer> map = new HashMap<>();
		// 生成哈希表（字符串词频）
		for (int i = 0; i < arr.length; i++) {
			String cur = arr[i];
			if (!map.containsKey(cur)) {
				map.put(cur, 1);
			} else {
				map.put(cur, map.get(cur) + 1);
			}
		}
		Node[] heap = new Node[topK]; // 堆
		int index = 0;
		// 遍历哈希表，决定每条信息是否进堆
		for (Entry<String, Integer> entry : map.entrySet()) {
			String str = entry.getKey();
			int times = entry.getValue();
			Node node = new Node(str, times); // 入堆
			if (index != topK) {
				heap[index] = node;
				heapInsert(heap, index++);
			} else {
				if (heap[0].times < node.times) {
					heap[0] = node;
					heapify(heap, 0, topK);
				}
			}
		}
		// 把小根堆的所有元素按词频从大到小排序
		for (int i = index - 1; i != 0; i--) {
			swap(heap, 0, i);
			heapify(heap, 0, i);
		}
		// 严格按照排名打印k条记录
		for (int i = 0; i < heap.length; i++) {
			if (heap[i] == null) {
				break;
			} else {
				System.out.print("No." + (i + 1) + ": ");
				System.out.print(heap[i].str + ", times: ");
				System.out.println(heap[i].times);
			}
		}
	}

	public void heapInsert(Node[] heap, int index) {
		while (index != 0) {
			int parent = (index - 1) / 2;
			if (heap[index].times < heap[parent].times) {
				swap(heap, parent, index);
				index = parent;
			} else {
				break;
			}
		}
	}

	public void heapify(Node[] heap, int index, int heapSize) {
		int left = index * 2 + 1;
		int right = index * 2 + 2;
		int smallest = index;
		while (left < heapSize) {
			if (heap[left].times < heap[index].times) {
				smallest = left;
			}
			if (right < heapSize && heap[right].times < heap[smallest].times) {
				smallest = right;
			}
			if (smallest != index) {
				swap(heap, smallest, index);
			} else {
				break;
			}
			index = smallest;
			left = index * 2 + 1;
			right = index * 2 + 2;
		}
	}

	public void swap(Node[] heap, int index1, int index2) {
		Node tmp = heap[index1];
		heap[index1] = heap[index2];
		heap[index2] = tmp;
	}

}
```

设计并实现TopKRecord结构，可以不断地向其中加入字符串，并且可以根据字符串出现的情况随时打印加入次数最多前k个字符串，具体为：

1. k在TopKRecord实例生成时指定，并且不再变化（k是构造函数的参数）
2. 含有add(String str)方法，向TopKRecord中加入字符串。
3. 含有printTopK()方法，即打印加入次数最多的前k个字符串，打印有哪些字符串和对应的次数即可，不要求严格按排序打印。

```java
import java.util.HashMap;
import java.util.Map.Entry;

public class Code_29_TopKTimes {

	public class Node {
		public String str;
		public int times;

		public Node(String s, int t) {
			str = s;
			times = t;
		}
	}

	public class TopKRecord {
		private Node[] heap;
		private int index;
		private HashMap<String, Node> strNodeMap;
		private HashMap<Node, Integer> nodeIndexMap;

		public TopKRecord(int size) {
			heap = new Node[size];
			index = 0;
			strNodeMap = new HashMap<>();
			nodeIndexMap = new HashMap<>();
		}

		public void add(String str) {
			Node curNode = null;
			int preIndex = -1;
			if (!strNodeMap.containsKey(str)) {
				curNode = new Node(str, 1);
				strNodeMap.put(str, curNode);
				nodeIndexMap.put(curNode, -1);
			} else {
				curNode = strNodeMap.get(str);
				curNode.times++;
				preIndex = nodeIndexMap.get(curNode);
			}
			if (preIndex == -1) {
				if (index == heap.length) {
					if (heap[0].times < curNode.times) {
						nodeIndexMap.put(heap[0], -1);
						nodeIndexMap.put(curNode, 0);
						heap[0] = curNode;
						heapify(0, index);
					}
				} else {
					nodeIndexMap.put(curNode, index);
					heap[index] = curNode;
					heapInsert(index++);
				}
			} else {
				heapify(preIndex, index);
			}
		}

		public void printTopK() {
			System.out.println("TOP: ");
			for (int i = 0; i < heap.length; i++) {
				if (heap[i] == null) {
					break;
				}
				System.out.print("Str: " + heap[i].str);
				System.out.println(" Times: " + heap[i].times);
			}
		}

		private void heapInsert(int index) {
			while (index != 0) {
				int parent = (index - 1) / 2;
				if (heap[index].times < heap[parent].times) {
					swap(parent, index);
					index = parent;
				} else {
					break;
				}
			}
		}

		private void heapify(int index, int heapSize) {
			int left = index * 2 + 1;
			int right = index * 2 + 2;
			int smallest = index;
			while (left < heapSize) {
				if (heap[left].times < heap[index].times) {
					smallest = left;
				}
				if (right < heapSize && heap[right].times < heap[smallest].times) {
					smallest = right;
				}
				if (smallest != index) {
					swap(smallest, index);
				} else {
					break;
				}
				index = smallest;
				left = index * 2 + 1;
				right = index * 2 + 2;
			}
		}

		private void swap(int index1, int index2) {
			nodeIndexMap.put(heap[index1], index2);
			nodeIndexMap.put(heap[index2], index1);
			Node tmp = heap[index1];
			heap[index1] = heap[index2];
			heap[index2] = tmp;
		}

	}

}
```



## 30 Manacher算法

给定一个字符串str，返回str中最长回文子串的长度。

```
package chapter_09;

public class Code_30_Manacher {

	public static char[] manacherString(String str) {
		char[] charArr = str.toCharArray();
		char[] res = new char[str.length() * 2 + 1];
		int index = 0;
		// 用#填充字符串，以便统一处理奇偶情况
		for (int i = 0; i != res.length; i++) {
			res[i] = (i & 1) == 0 ? '#' : charArr[index++];
		}
		return res;
	}

	public static int maxLcpsLength(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		char[] charArr = manacherString(str);
		int[] pArr = new int[charArr.length]; // 记录每个位置的回文半径
		int index = -1; // 回文右边界的中心
		int pR = -1; // 回文右边界
		int max = Integer.MIN_VALUE; // 最大半径
		for (int i = 0; i != charArr.length; i++) {
			// i在右边界R的内部时
			pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;
			while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {
				// 尝试扩大
				if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
					pArr[i]++;
				else {
					break;
				}
			}
			// 更新回文右边界
			if (i + pArr[i] > pR) {
				pR = i + pArr[i];
				index = i;
			}
			max = Math.max(max, pArr[i]);
		}
		// 返回的是回文子串的长度
		return max - 1;
	}
}
```

给定一个字符串str，想通过添加字符的方式使得str整体都变成回文字符串，但要求只能在str的末尾添加字符，请返回在str后面添加的最短字符串。

```java
public class Code_30_Manacher {

	public static String shortestEnd(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		char[] charArr = manacherString(str);
		int[] pArr = new int[charArr.length];
		int index = -1;
		int pR = -1;
		int maxContainsEnd = -1;
		for (int i = 0; i != charArr.length; i++) {
			pArr[i] = pR > i ? Math.min(pArr[2 * index - i], pR - i) : 1;
			while (i + pArr[i] < charArr.length && i - pArr[i] > -1) {
				if (charArr[i + pArr[i]] == charArr[i - pArr[i]])
					pArr[i]++;
				else {
					break;
				}
			}
			if (i + pArr[i] > pR) {
				pR = i + pArr[i];
				index = i;
			}
			// 当回文右边界到最右停止
			if (pR == charArr.length) {
				maxContainsEnd = pArr[i];
				break;
			}
		}
		char[] res = new char[str.length() - maxContainsEnd + 1];
		for (int i = 0; i < res.length; i++) {
			// 将前半部分逆序，注意跳过填充字符#
			res[res.length - 1 - i] = charArr[i * 2 + 1];
		}
		return String.valueOf(res);
	}
}
```



## 31 KMP算法

给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有子串match，则返回match在str中的开始位置，不含有则返回-1。

```java
public class Code_31_KMP {

	public static int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] ss = s.toCharArray();
		char[] ms = m.toCharArray();
		int si = 0;
		int mi = 0;
		int[] next = getNextArray(ms);
		while (si < ss.length && mi < ms.length) {
			if (ss[si] == ms[mi]) {
				si++;
				mi++;
			} else if (next[mi] == -1) {
				// 不存在前后缀匹配则只能从头匹配
				// 此时m已经到了0位置还不匹配，只能从s的下一个开始匹配
				si++;
			} else {
				// m字符串不用退回到0位置
				mi = next[mi];
			}
		}
		// 返回匹配的位置
		return mi == ms.length ? si - mi : -1;
	}

	// 求最长前后缀匹配数组
	public static int[] getNextArray(char[] ms) {
		if (ms.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[ms.length];
		next[0] = -1; // 0位置默认-1
		next[1] = 0; // 1位置默认0
		int pos = 2;
		int cn = 0;// 需要和当前字符A比较的字符
		while (pos < next.length) {
			if (ms[pos - 1] == ms[cn]) {
				// 出现了前缀和后缀相等，则更新当前A位置的值
				next[pos++] = ++cn;
			} else if (cn > 0) {
				// 不断向前寻找匹配
				cn = next[cn];
			} else {
				// 当前字符A之前不存在前缀和后缀的匹配
				next[pos++] = 0;
			}
		}
		return next;
	}
}
```



## 32 丢棋子问题

一座大楼有0~N层，地面算作0层，最高的一层为第N层。已知棋子从第i层掉落可能摔碎也可能不会。给定整数N作为楼层数，再给定整数K作为棋子数，返回如果想找到棋子不会摔碎的最高层数，即使在最差的情况下仍的最少次数，一次只能仍一个棋子。

```java
public class Code_32_Chess {

	// 暴力递归
	public int solution_1(int nLevel, int kChess) {
		if (nLevel < 1 || kChess < 1) {
			return 0;
		}
		return Process_1(nLevel, kChess);
	}

	public int Process_1(int nLevel, int kChess) {
		if (nLevel == 0) {
			return 0;
		}
		if (kChess == 1) {
			return nLevel;
		}
		int min = Integer.MAX_VALUE;
		for (int i = 1; i != nLevel + 1; i++) {
			if (i == nLevel) {

			}
			min = Math.min(min, Math.max(Process_1(i - 1, kChess - 1), Process_1(nLevel - i, kChess)));
		}
		return min + 1;
	}

	// 动态规划
	public int solution_2(int nLevel, int kChess) {
		if (nLevel < 1 || kChess < 1) {
			return 0;
		}
		if (kChess == 1) {
			return nLevel;
		}
		int[][] dp = new int[nLevel + 1][kChess + 1];
		for (int i = 1; i < dp.length; i++) {
			dp[i][1] = i;
		}
		for (int i = 1; i < dp.length; i++) {
			for (int j = 2; j != dp[0].length; j++) {
				int min = Integer.MAX_VALUE;
				for (int k = 1; k != i + 1; k++) {
					min = Math.min(min, Math.max(dp[k - 1][j - 1], dp[i - k][j]));
				}
				dp[i][j] = min + 1;
			}
		}
		return dp[nLevel][kChess];
	}
}
```



## 33 画匠问题

给定一个整型数组arr，数组中的每个值都为正数，表示完成一幅画需要的时间，再给定一个整数num表示画匠的数量，每个画匠只能画连在一起的画作。所有的画家并行工作，请返回完成所有的画作需要的最少时间。

```java
public class Code_33_Painter {

	public int solution(int[] arr, int num) {
		if (arr == null || arr.length == 0 || num < 1) {
			throw new RuntimeException("err");
		}
		int[] sumArr = new int[arr.length];
		int[] map = new int[arr.length];
		sumArr[0] = arr[0];
		map[0] = arr[0];
		for (int i = 1; i < sumArr.length; i++) {
			sumArr[i] = sumArr[i - 1] + arr[i];
			map[i] = sumArr[i];
		}
		for (int i = 1; i < num; i++) {
			for (int j = map.length - 1; j > i - 1; j--) {
				int min = Integer.MAX_VALUE;
				for (int k = i - 1; k < j; k++) {
					int cur = Math.max(map[k], sumArr[j] - sumArr[k]);
					min = Math.min(min, cur);
				}
				map[j] = min;
			}
		}
		return map[arr.length - 1];
	}
}
```



## 34 邮局选址问题

一条直线上有居民点，邮局只能建在居民点上。给定一个有序整型数组arr，每个值表示居民点的一维坐标，再给定一个正数num，表示邮局的数量。选择num个居民点建立num个邮局，使所有的居民点到邮局的总距离最短，返回最短的总距离。

```java
public class Code_34_MinDistance {

	public int minDistances(int[] arr, int num) {
		if (arr == null || num < 1 || arr.length < num) {
			return 0;
		}
		int[][] w = new int[arr.length + 1][arr.length + 1];
		for (int i = 0; i < arr.length; i++) {
			for (int j = i + 1; j < arr.length; j++) {
				w[i][j] = w[i][j - 1] + arr[j] - arr[(i + j) / 2];
			}
		}
		int[][] dp = new int[num][arr.length];
		for (int j = 0; j < arr.length; j++) {
			dp[0][j] = w[0][j];
		}
		for (int i = 1; i < num; i++) {
			for (int j = i + 1; j < arr.length; j++) {
				dp[i][j] = Integer.MAX_VALUE;
				for (int k = 0; k <= j; k++) {
					dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + w[k + 1][j]);
				}
			}
		}
		return dp[num - 1][arr.length - 1];
	}
}
```

