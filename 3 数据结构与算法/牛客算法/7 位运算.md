## 1 不用额外变量交换两个整数的值

如何不用任何额外变量交换两个整数的值？

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

异或运算的特点：假设a异或b的结果记为c，那么a异或c的结果就是b，b异或c的结果就是a。

## 2 不用任何比较判断找出两个数中较大的数

给定两个32位整数a和b，返回a和b中较大的。要求不用任何比较判断。

```java
public class Code_02_GetMaxNum {

	// n返回1，1返回0
	public int flip(int n) {
		return n ^ 1;
	}

	// 返回n的符号
	public int sign(int n) {
		return flip((n >> 31) & 1);
	}
	
    // 存在溢出的情况
	public int getMax_1(int a, int b) {
		int c = a - b;
		int scA = sign(c);
		int scB = flip(scA);
		return a * scA + b * scB;
	}
}
```

```java
public class Code_02_GetMaxNum {
    
    // 不会发生溢出
    public int getMax_2(int a, int b) {
        int c = a - b;
        int sa = sign(a);
        int sb = sign(b);
        int sc = sign(c);
        int difSab = sa ^ sb; // a和b符号不同
        int sameSab = flip(difSab); // a和b符号相同
        int returnA = difSab * sa + sameSab * sc;
        int returnB = flip(returnA);
        return a * returnA + b * returnB;
    }
}
```

## 3 只用位运算不用算术运算实现整数的加减乘除运算

给定两个32位整数a和b，可正、可负、可0。不能使用算术运算符，分别实现a和b的加减乘除运算。要求不必对数据溢出进行处理。

```java
public class Code_03_BitOperation {

	public int add(int a, int b) {
		int sum = a;
		while (b != 0) { // 循环直到进位为0
			sum = a ^ b; // 不考虑进位相加
			b = (a & b) << 1; // 仅考虑进位
			a = sum;
		}
		return sum;
	}

	// 得到n的相反数
	public int negNum(int n) {
		return add(~n, 1);
	}

	public int minus(int a, int b) {
		return add(a, negNum(b));
	}

	public int multi(int a, int b) {
		int res = 0;
		while (b != 0) {
			if ((b & 1) != 0) { // 最低位为1
				res = add(res, a);
			}
			a <<= 1; // a左移1位（相当于x2）
			b >>>= 1; // b右移1位
		}
		return res;
	}

	public boolean isNeg(int n) {
		return n < 0;
	}

	public int div(int a, int b) {
		// 先把a和b转成正数
		int x = isNeg(a) ? negNum(a) : a;
		int y = isNeg(b) ? negNum(b) : b;
		int res = 0;
		for (int i = 31; i > -1; i = minus(i, 1)) {
			if ((x >> i) >= y) {
				res |= (1 << i);
				x = minus(x, y << i);
			}
		}
		return isNeg(a) ^ isNeg(b) ? negNum(res) : res;
	}

	public int divide(int a, int b) {
		if (b == 0) {
			throw new RuntimeException("divisor is 0.");
		}
		if (a == Integer.MIN_VALUE && b == Integer.MIN_VALUE) {
			return 1;
		} else if (b == Integer.MIN_VALUE) {
			return 0;
		} else if (a == Integer.MIN_VALUE) {
			int res = div(add(a, 1), b);
			return add(res, div(minus(a, multi(res, b)), b));
		} else {
			return div(a, b);
		}
	}
}
```



## 4 整数的二进制表达中有多少个1

给定一个32位整数n，可正可负可0，返回该整数二进制表达中1的个数。

```java
public class Code_04_Count1 {

	public int count1(int n) {
		int res = 0;
		while (n != 0) {
			res += n & 1;
			n >>>= 1;
		}
		return res;
	}

	public int count2(int n) {
		int res = 0;
		while (n != 0) {
			n &= (n - 1);
			res++;
		}
		return res;
	}

	public int count3(int n) {
		int res = 0;
		while (n != 0) {
			n -= n & (~n + 1);
			res++;
		}
		return res;
	}

	// 平行算法
	public int count4(int n) {
		n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);
		n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
		n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);
		n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);
		n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
		return n;
	}
}
```



## 5 在其他数都出现偶数次的数组中找到出现奇数次的数

给定一个整型数组arr，其中只有一个数出现了奇数次，其他的数都出现了偶数次，打印这个数。

```java
public class Code_05_PrintOddTimesNum {

	public void printOddTimesNum1(int[] arr) {
		int eO = 0;
		for (int cur : arr) {
			eO ^= cur;
		}
		System.out.println(eO);
	}
}
```

有两个数出现了奇数次，其他的数都出现了偶数次，打印这两个数。

```java
public class Code_05_PrintOddTimesNum {

	public void printOddTimesNum(int[] arr) {
		int eO = 0;
		int eOhasOne = 0;
		for (int curNum : arr) {
			eO ^= curNum;
		}
		int rightOne = eO & (~eO + 1);
		for (int cur : arr) {
			if ((cur & rightOne) != 0) {
				eOhasOne ^= cur;
			}
		}
		System.out.println(eOhasOne + " " + (eO ^ eOhasOne));
	}
}
```



## 6 在其他数都出现k次的数组中找出只出现一次的数

给定一个整型数组arr和一个大于1的整数k。已知arr中只有1个数出现了一次，其他的数都出现了k次，请返回只出现1次的数。

```java
public class Code_06_OnceNum {

	public int onceNum(int[] arr, int k) {
		int[] eO = new int[32];
		for (int i = 0; i < arr.length; i++) {
			setExclusiveOr(eO, arr[i], k);
		}
		int res = getNumFromKSysNum(eO, k);
		return res;
	}

	public void setExclusiveOr(int[] eO, int value, int k) {
		int[] curKSysNum = getKSysNumFromNum(value, k);
		for (int i = 0; i != eO.length; i++) {
			eO[i] = (eO[i] + curKSysNum[i]) % k;
		}
	}

	public int[] getKSysNumFromNum(int value, int k) {
		int[] res = new int[32];
		int index = 0;
		while (value != 0) {
			res[index++] = value % k;
			value = value / k;
		}
		return res;
	}

	public int getNumFromKSysNum(int[] eO, int k) {
		int res = 0;
		for (int i = eO.length - 1; i != -1; i--) {
			res = res * k + eO[i];
		}
		return res;
	}
}
```

