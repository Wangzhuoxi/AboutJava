# 1. 打印两个有序链表的公共部分

**题目**

给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。

```java
public class Code_01_PrintCommonPart {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public void printCommonPart(Node head1, Node head2) {
		System.out.print("Common Part: ");
		while (head1 != null && head2 != null) {
			if (head1.value < head2.value) {
				head1 = head1.next;
			} else if (head1.value > head2.value) {
				head2 = head2.next;
			} else {
				System.out.print(head1.value + " ");
				head1 = head1.next;
				head2 = head2.next;
			}
		}
	}

}
```



# 2. 在单链表和双链表中删除倒数第K个节点

**题目**

分别实现两个函数，一个可以删除单链表中倒数第K个节点，另一个可以删除双链表中倒数第K个节点。

**要求**

如果链表长度为N，时间复杂度要求o(N)，额外空间复杂度要求o(1)

```java
public class Code_02_RemoveLastKthNode {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node removeLastKthNode(Node head, int lastKth) {
		if (head == null || lastKth < 1) {
			return head;
		}
		Node cur = head;
		while (cur != null) {
			lastKth--;
			cur = cur.next;
		}
		// 要删除的是头节点
		if (lastKth == 0) {
			return head;
		}
		if (lastKth < 0) {
			cur = head;
			// K=0时移动到了要删除节点的前一个节点
			while (++lastKth != 0) {
				cur = cur.next;
			}
			cur.next = cur.next.next;
		}
		return head;
	}

	public class DoubleNode {
		public int value;
		public DoubleNode last;
		public DoubleNode next;

		public DoubleNode(int data) {
			this.value = data;
		}
	}

	public DoubleNode removeLastKthNode(DoubleNode head, int lastKth) {
		if (head == null || lastKth < 1) {
			return head;
		}
		DoubleNode cur = head;
		while (cur != null) {
			lastKth--;
			cur = cur.next;
		}
		if (lastKth == 0) {
			head = head.next;
			head.last = null;
		}
		if (lastKth < 0) {
			cur = head;
			while (++lastKth != 0) {
				cur = cur.next;
			}
			DoubleNode newNext = cur.next.next;
			cur.next = newNext;
			if (newNext != null) {
				newNext.last = cur;
			}
		}
		return head;
	}
}
```



# 3. 删除链表的中间节点和a/b处的节点

**题目**

给定链表的头节点head，实现删除链表的中间节点的函数。

给定链表的头节点head、整数a和b，实现删除位于a/b处节点的函数。

```java
public class Code_03_RemoveMidNode {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node removeMidNode(Node head) {
		if (head == null || head.next == null) {
			return head;
		}
		// 两个节点删除第一个
		if (head.next.next == null) {
			return head.next;
		}
		Node pre = head; // 慢指针
		Node cur = head.next.next; // 快指针
		while (cur.next != null && cur.next.next != null) {
			pre = pre.next;
			cur = cur.next.next;
		}
		pre.next = pre.next.next; // pre指向中间节点的前一个节点
		return head;
	}

	public Node removeByRatio(Node head, int a, int b) {
		if (a < 1 || a > b) {
			return head;
		}
		int n = 0; // 节点个数
		Node cur = head;
		while (cur != null) {
			n++;
			cur = cur.next;
		}
		// 返回大于或等于表达式的最小整数
		n = (int) Math.ceil(((double) (a * n)) / (double) b);
		if (n == 1) {
			head = head.next;
		}
		if (n > 1) {
			cur = head;
			while (--n != 1) {
				cur = cur.next;
			}
			cur.next = cur.next.next;
		}
		return head;
	}

}
```



# 4. 反转单向和双向链表

**题目**

分别实现反转单向链表和双向链表的函数。

**要求**

如果链表长度为N，时间复杂度要求o(N)，额外空间复杂度要求o(1)

```java
public class Code_04_ReverseList {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node reverseList(Node head) {
		Node pre = null;
		Node next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			pre = head;
			head = next;
		}
		return pre;
	}

	public class DoubleNode {
		public int value;
		public DoubleNode last;
		public DoubleNode next;

		public DoubleNode(int data) {
			this.value = data;
		}
	}

	public DoubleNode reverseList(DoubleNode head) {
		DoubleNode pre = null;
		DoubleNode next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			head.last = next;
			pre = head;
			head = next;
		}
		return pre;
	}

}
```



# 5. 反转部分单向链表

**题目**

给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。

**要求**

如果链表长度为N，时间复杂度要求o(N)，额外空间复杂度要求o(1)

如果不满足 1<=from<=to<=N，则不用调整

```java
public class Code_05_ReversePart {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node reversePart(Node head, int from, int to) {
		int len = 0;
		Node node1 = head;
		Node fPre = null;
		Node tPos = null;
		// 统计链表长度并找到frome-1节点和to+1节点
		while (node1 != null) {
			len++;
			fPre = len == from - 1 ? node1 : fPre;
			tPos = len == to + 1 ? node1 : tPos;
			node1 = node1.next;
		}
		if (from > to || from < 1 || to > len) {
			return head;
		}
		node1 = fPre == null ? head : fPre.next; // 指向反转部分的第一个节点
		// 反转部分链表
		Node node2 = node1.next;
		node1.next = tPos;
		Node next = null;
		while (node2 != tPos) {
			next = node2.next;
			node2.next = node1;
			node1 = node2;
			node2 = next;
		}
		// 重连前半部分返回原头部
		if (fPre != null) {
			fPre.next = node1;
			return head;
		}
		return node1; // 返回新头
	}

}
```



# 6. 环形单链表的约瑟夫问题

**题目**

N个人排成一个圆圈开始报数，数到m的人自杀，然后再由下一个人重新报1，依次下去，直到剩下最后一个人。

输入：一个环形单链表的头节点head和报数的值m

返回：最后生存下来的节点，且这个节点自己组成环形单向链表，其他节点都删掉。

**进阶**

如果链表长度为N，要求时间复杂度o(N)

```java
public class Code_06_JosephusKill {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node josephusKill_1(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node last = head;
		while (last.next != head) {
			last = last.next;
		}
		int count = 0;
		while (head != last) {
			if (++count == m) {
				last.next = head.next;
				count = 0;
			} else {
				last = last.next;
			}
			head = head.next;
		}
		return head;
	}

	public Node josephusKill_2(Node head, int m) {
		if (head == null || head.next == head || m < 1) {
			return head;
		}
		Node cur = head.next;
		int tmp = 1; 
		while (cur != head) {
			tmp++;
			cur = cur.next;
		}
		tmp = getLive(tmp, m);
		while (--tmp != 0) {
			head = head.next;
		}
		head.next = head;
		return head;
	}

	public int getLive(int i, int m) {
		if (i == 1) {
			return 1;
		}
        // 数学公式推断
		return (getLive(i - 1, m) + m - 1) % i + 1;
	}
}
```



# 7. 判断一个链表是否为回文结构

**题目**

给定一个单向链表的头节点head，请判断该链表是否为回文结构。

**进阶**

如果链表长度为N，时间复杂度要求o(N)，额外空间复杂度要求o(1)

```java
import java.util.Stack;

public class Code_07_IsPalindrome {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 方法一：利用栈的逆序性
	public boolean isPalindrome_1(Node head) {
		Stack<Node> stack = new Stack<>();
		Node cur = head;
		while (cur != null) {
			stack.push(cur);
			cur = cur.next;
		}
		while (head != null) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// 方法二：只有一半的节点入栈
	public boolean isPalindrome_2(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		// 快慢指针找到中点
		Node right = head.next; // 中点
		Node cur = head;
		while (cur.next != null && cur.next.next != null) {
			right = right.next;
			cur = cur.next.next;
		}
		Stack<Node> stack = new Stack<>();
		while (right != null) {
			stack.push(right);
			right = right.next;
		}
		while (!stack.isEmpty()) {
			if (head.value != stack.pop().value) {
				return false;
			}
			head = head.next;
		}
		return true;
	}

	// 方法三：不需要额外空间
	public boolean isPalindrome_3(Node head) {
		if (head == null || head.next == null) {
			return true;
		}
		// 快慢指针找到中点
		Node n1 = head;
		Node n2 = head;
		while (n2.next != null && n2.next.next != null) {
			n1 = n1.next; // n1->中部
			n2 = n2.next.next; // n2->结尾
		}
		// 反转右半区链表
		n2 = n1.next; // n2->右半区第一个节点
		n1.next = null; // mid.next->null
		Node n3 = null;
		while (n2 != null) {
			n3 = n2.next; // n3->保存下一个节点
			n2.next = n1; // 下一个反转节点
			n1 = n2; // n1移动
			n2 = n3; // n2移动
		}
		n3 = n1; // n3->保存最后一个节点
		n2 = head; // n2->左边第一个节点
		boolean res = true;
		// 两部分分别向中间移动判断
		while (n1 != null && n2 != null) {
			if (n1.value != n2.value) {
				res = false;
				break;
			}
			n1 = n1.next;
			n2 = n2.next;
		}
		// 恢复右半区的结构
		n1 = n3.next;
		n3.next = null;
		while (n1 != null) {
			n2 = n1.next;
			n1.next = n3;
			n3 = n1;
			n1 = n2;
		}
		return res;
	}

}
```



# 8. 将单向链表按某值划分为左边小、中间相等、右边大的形式

**题目**

给定一个单向链表的头节点head，节点的值类型是整数，再给定一个整数 pivot。实现一个调整链表的函数，将链表调整为左部分小于pivot的节点，中间部分等于pivot的节点，右部分大于pivot的节点，对调整后的节点顺序没有要求。

**进阶**

在原问题的要求上在增加如下两个要求：

- 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。
- 如果链表长度为N，时间复杂度要求o(N)，额外空间复杂度要求o(1)

```java
public class Code_08_ListPartition {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 原问题：转化为数组问题
	public Node listPartition_1(Node head, int pivot) {
		if (head == null) {
			return head;
		}
		// 遍历链表求长度
		Node cur = head;
		int n = 0;
		while (cur != null) {
			n++;
			cur = cur.next;
		}
		// 链表节点存入数组
		Node[] nodeArr = new Node[n];
		cur = head;
		int i = 0;
		for (i = 0; i < nodeArr.length; i++) {
			nodeArr[i] = cur;
			cur = cur.next;
		}
		// 通过数组归并
		arrPartition(nodeArr, pivot);
		// 重连链表节点
		for (i = 1; i < nodeArr.length; i++) {
			nodeArr[i - 1].next = nodeArr[i];
		}
		nodeArr[i - 1].next = null;
		return nodeArr[0];
	}

	// 归并过程
	public void arrPartition(Node[] nodeArr, int pivot) {
		int small = -1;
		int big = nodeArr.length;
		int index = 0;
		while (index != big) {
			if (nodeArr[index].value < pivot) {
				swap(nodeArr, ++small, index++);
			} else if (nodeArr[index].value == pivot) {
				index++;
			} else {
				swap(nodeArr, --big, index);
			}
		}
	}

	public void swap(Node[] nodeArr, int a, int b) {
		Node tmp = nodeArr[a];
		nodeArr[a] = nodeArr[b];
		nodeArr[b] = tmp;
	}

	// 进阶问题
	public Node listPartition_2(Node head, int pivot) {
		Node sH = null, sT = null; // 小的头尾
		Node eH = null, eT = null; // 相等的头尾
		Node bH = null, bT = null; // 大的头尾
		Node next = null; // 保存下一个节点
		// 所有的节点分进三个链表中
		while (head != null) {
			next = head.next;
			if (head.value < pivot) {
				if (sH == null) {
					sH = head;
					sT = head;
				} else {
					sT.next = head;
					sT = head;
				}
			} else if (head.value == pivot) {
				if (eH == null) {
					eH = head;
					eT = head;
				} else {
					eT.next = head;
					eT = head;
				}
			} else {
				if (bH == null) {
					bH = head;
					bT = head;
				} else {
					bT.next = head;
					bT = head;
				}
			}
			head = next;
		}
		// 小的和相等的重新连接
		if (sT != null) {
			sT.next = eH;
			eT = eT == null ? sT : eT;
		}
		// 所有的重新连接
		if (eT != null) {
			eT.next = bH;
		}
		return sH != null ? sH : eH != null ? eH : bH;
	}

}
```



# 9. 复制含有随机指针节点的链表

**题目**

给定一个由含有随机指针的Node节点类型组成的无环单向链表的头节点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。

**进阶**

不使用额外的数据机构，只使用有限几个变量，且在时间复杂度o(N)内完成

```java
import java.util.HashMap;

public class Code_09_CopyListWithRand {

	public class Node {
		public int value;
		public Node next;
		public Node rand;

		public Node(int data) {
			this.value = data;
		}
	}

	// 原问题：HashMap
	public Node copyListWithRand_1(Node head) {
		HashMap<Node, Node> map = new HashMap<>();
		Node cur = head;
		while (cur != null) {
			map.put(cur, new Node(cur.value));
			cur = cur.next;
		}
		cur = head;
		while (cur != null) {
			map.get(cur).next = map.get(cur.next);
			map.get(cur).rand = map.get(cur.rand);
			cur = cur.next;
		}
		return map.get(head);
	}

	// 进阶问题
	public Node copyListWithRand_2(Node head) {
		if (head == null) {
			return null;
		}
		Node cur = head;
		Node next = null;
		// 每个节点后面复制生成副本节点
		while (cur != null) {
			next = cur.next;
			cur.next = new Node(cur.value);
			cur.next.next = next;
			cur = next;
		}
		cur = head;
		Node curCopy = null;
		// 遍历设置每个副本节点的rand指针
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			curCopy.rand = cur.rand != null ? cur.rand.next : null;
			cur = next;
		}
		Node res = head.next; // 新链表的头节点
		cur = head;
		// 将所有的副本串联起来
		while (cur != null) {
			next = cur.next.next;
			curCopy = cur.next;
			cur.next = next;
			curCopy.next = next != null ? next.next : null;
			cur = next;
		}
		return res;
	}

}
```



# 10. 两个单链表生成相加链表

**题目**

假设链表中每一个节点的值都在0~9之间，那么链表整体就可以代表一个整数。

给定两个链表的头节点head1和head2，请生成代表两个整数相加值的结果链表。

```java
import java.util.Stack;

public class Code_10_AddLists {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 方法一：利用栈结构
	public Node addLists_1(Node head1, Node head2) {
		Stack<Integer> s1 = new Stack<>();
		Stack<Integer> s2 = new Stack<>();
		// 将两个链表代表的整数入栈
		while (head1 != null) {
			s1.push(head1.value);
			head1 = head1.next;
		}
		while (head2 != null) {
			s2.push(head2.value);
			head2 = head2.next;
		}
		int ca = 0; // 进位
		int n1 = 0;
		int n2 = 0;
		int n = 0;
		Node node = null;
		Node pre = null;
		while (!s1.isEmpty() || !s2.isEmpty()) {
			n1 = s1.isEmpty() ? 0 : s1.pop();
			n2 = s2.isEmpty() ? 0 : s2.pop();
			n = n1 + n2 + ca;
			pre = node; // 前一位
			node = new Node(n % 10);// 新产生的位
			node.next = pre;
			ca = n / 10; // 本次进位
		}
		// 最高进位
		if (ca == 1) {
			pre = node;
			node = new Node(1);
			node.next = pre;
		}
		return node;
	}

	// 方法二：利用链表的逆序求解，可以省掉用栈的空间
	public Node addLists_2(Node head1, Node head2) {
		head1 = reverseList(head1);
		head2 = reverseList(head2);
		int ca = 0;
		int n1 = 0;
		int n2 = 0;
		int n = 0;
		Node c1 = head1;
		Node c2 = head2;
		Node node = null;
		Node pre = null;
		while (c1 != null || c2 != null) {
			n1 = c1 != null ? c1.value : 0;
			n2 = c2 != null ? c2.value : 0;
			n = n1 + n2 + ca;
			pre = node;
			node = new Node(n % 10);
			node.next = pre;
			ca = n / 10;
			c1 = c1 != null ? c1.next : null;
			c2 = c2 != null ? c2.next : null;
		}
		if (ca == 1) {
			pre = node;
			node = new Node(1);
			node.next = pre;
		}
		reverseList(head1);
		reverseList(head2);
		return node;
	}

	public Node reverseList(Node head) {
		Node pre = null;
		Node next = null;
		while (head != null) {
			next = head.next;
			head.next = pre;
			pre = head;
			head = next;
		}
		return pre;
	}

}
```



# 11. 两个单链表相交的一系列问题

**题目**

单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交链表的第一个节点；如果不相交，返回null即可。

**要求**

如果链表1的长度为N，链表2的长度为M，时间复杂度请达到o(N+M)，额外空间复杂度请达到o(1)

```java
public class Code_11_GetIntersectNode {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 判断链表是否有环
	public Node getLoopNode(Node head) {
		if (head == null || head.next == null || head.next.next == null) {
			return null;
		}
		Node n1 = head.next; // 慢指针
		Node n2 = head.next.next; // 快指针
		// 有环一定会在环上相遇
		while (n1 != n2) {
			if (n2.next == null || n2.next.next == null) {
				return null; // 遍历到终点则无环
			}
			n2 = n2.next.next;
			n1 = n1.next;
		}
		n2 = head;
		// 在入环节点相遇
		while (n1 != n2) {
			n1 = n1.next;
			n2 = n2.next;
		}
		return n1;
	}

	// 两个无环节点相交
	public Node noLoop(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node cur1 = head1;
		Node cur2 = head2;
		int n = 0;
		// 统计两个节点长度的差值
		while (cur1.next != null) {
			n++;
			cur1 = cur1.next;
		}
		while (cur2.next != null) {
			n--;
			cur2 = cur2.next;
		}
		if (cur1 != cur2) {
			return null;
		}

		cur1 = n > 0 ? head1 : head2; // cur1指向长链表
		cur2 = cur1 == head1 ? head2 : head1; // cur2指向短链表
		n = Math.abs(n);
		// 长链表先走差值步
		while (n != 0) {
			n--;
			cur1 = cur1.next;
		}
		// 两链表同步移动
		while (cur1 != cur2) {
			cur1 = cur1.next;
			cur2 = cur2.next;
		}
		return cur1;
	}

	// 两个有环链表相交
	public Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
		Node cur1 = null;
		Node cur2 = null;
		if (loop1 == loop2) { // 情况1：先相交后入环则入环节点相同（和无环链表相交一样）
			cur1 = head1;
			cur2 = head2;
			int n = 0;
			while (cur1 != loop1) {
				n++;
				cur1 = cur1.next;
			}
			while (cur2 != loop2) {
				n--;
				cur2 = cur2.next;
			}
			cur1 = n > 0 ? head1 : head2;
			cur2 = cur1 == head1 ? head2 : head1;
			n = Math.abs(n);
			while (n != 0) {
				n--;
				cur1 = cur1.next;
			}
			while (cur1 != cur2) {
				cur1 = cur1.next;
				cur2 = cur2.next;
			}
			return cur1;
		} else {
			cur1 = loop1.next;
			while (cur1 != loop1) {
				if (cur1 == loop2) { // 两个入环节点相遇
					return loop1;
				}
				cur1 = cur1.next;
			}
			return null;
		}
	}

	public Node getIntersectNode(Node head1, Node head2) {
		if (head1 == null || head2 == null) {
			return null;
		}
		Node loop1 = getLoopNode(head1);
		Node loop2 = getLoopNode(head2);
		if (loop1 == null && loop2 == null) {
			return noLoop(head1, head2);
		}
		if (loop1 != null && loop2 != null) {
			return bothLoop(head1, loop1, head2, loop2);
		}
		// 一个有环一个无环则一定不相交
		return null;
	}
}
```



# 12. 将单链表的每K个节点之间逆序

**题目**

给定一个单链表的头节点head，实现一个调整单链表的函数，使得每K个节点之间逆序，如果最后不够K个节点一组，则不调整最后几个节点。

```java
import java.util.Stack;

public class Code_12_ReverseKNodes {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 方法一：利用栈结构
	public Node reverseKNodes_1(Node head, int K) {
		if (K < 2) {
			return head;
		}
		Stack<Node> stack = new Stack<>();
		Node newHead = head; // 新的头部
		Node cur = head;
		Node pre = null;
		Node next = null;
		while (cur != null) {
			next = cur.next;
			stack.push(cur);
			if (stack.size() == K) { // 达到了逆序的个数
				pre = resign_1(stack, pre, next);
				newHead = newHead == null ? cur : newHead;
			}
			cur = next;
		}
		return newHead;
	}

	public Node resign_1(Stack<Node> stack, Node left, Node right) {
		Node cur = stack.pop();
		if (left != null) {
			left.next = cur; // 和前一组相连
		}
		Node next = null;
		while (!stack.isEmpty()) {
			next = stack.pop();
			cur.next = next;
			cur = next;
		}
		cur.next = right; // 和后一组相连
		return cur; // 返回本组的最后一个节点
	}

	// 方法二：不需要额外结构，直接调整
	public Node reverseKNodes_2(Node head, int K) {
		if (K < 2) {
			return head;
		}
		Node cur = head;
		Node start = null;
		Node pre = null; // 前一组的最后一个节点
		Node next = null; // 后一组的第一个节点
		int count = 1;
		while (cur != null) {
			next = cur.next;
			if (count == K) {
				start = pre == null ? head : pre.next;
				head = pre == null ? cur : head;
				resign_2(pre, start, cur, next);
				pre = start; // pre指向前一部分最后一个节点
				count = 0;
			}
			count++;
			cur = next;
		}
		return head;
	}

	// 逆序部分链表
	public void resign_2(Node left, Node start, Node end, Node right) {
		Node pre = start;
		Node cur = start.next;
		Node next = null;
		while (cur != right) {
			next = cur.next;
			cur.next = pre;
			pre = cur;
			cur = next;
		}
		if (left != null) {
			left.next = end;
		}
		start.next = right;
	}

}
```



# 13. 删除无序单链表中值重复出现的节点

**题目**

给定一个无序单链表的头节点head，删除其中值重复出现的节点。

请按以下要求实现两种方法：

方法1：如果链表长度为N，时间复杂度o(N)

方法2：额外空间复杂度为o(1)

```java
import java.util.HashSet;

public class Code_13_RemoveRep {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 方法一：利用哈希表
	public void removeRep_1(Node head) {
		if (head == null) {
			return;
		}
		HashSet<Integer> set = new HashSet<>();
		Node pre = head;
		Node cur = head.next;
		set.add(head.value);
		while (cur != null) {
			if (set.contains(cur.value)) {
				pre.next = cur.next; // 跳过重复节点
			} else {
				set.add(cur.value);
				pre = cur;
			}
			cur = cur.next;
		}
	}

	// 方法二：类似选择排序
	// 时间o(N^2);空间o(1)
	public void removeRep_2(Node head) {
		Node cur = head;
		Node pre = null;
		Node next = null;
		while (cur != null) {
			pre = cur;
			next = cur.next;
			// 删除后面所有和cur相等的值
			while (next != null) {
				if (cur.value == next.value) {
					pre.next = next.next;
				} else {
					pre = next;
				}
				next = next.next;
			}
			cur = cur.next;
		}
	}
}
```



# 14. 在单链表中删除指定值的节点

**题目**

给定一个链表的头节点head和一个整数num，请实现函数将值为num的节点全部删除。

```java
import java.util.Stack;

public class Code_14_RemoveValue {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 方法一：利用栈结构
	// 时间o(N);空间o(N)
	public Node removeValue_1(Node head, int num) {
		Stack<Node> stack = new Stack<>();
		while (head != null) {
			if (head.value != num) { // 非指定值入栈
				stack.push(head);
			}
			head = head.next;
		}
		// 重新连接
		while (!stack.isEmpty()) {
			stack.peek().next = head;
			head = stack.pop(); // 栈底节点为头节点
		}
		return head;
	}

	// 方法二：直接调整
	// 时间o(N);空间o(1)
	public Node removeValue_2(Node head, int num) {
		// 找到第一个不是num的节点作为头节点
		while (head != null) {
			if (head.value != num) {
				break;
			}
			head = head.next;
		}
		Node pre = head; // 前一个不是num的节点
		Node cur = head;
		while (cur != null) {
			if (cur.value == num) {
				pre.next = cur.next;
			} else {
				pre = cur;
			}
			cur = cur.next;
		}
		return head;
	}
}
```



# 15. 将搜索二叉树转换成双向链表

**题目**

现有一棵搜索二叉树，请将其转换为一个有序的双向链表。

```java
import java.util.LinkedList;
import java.util.Queue;

public class Code_15_Convert {

	public class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int value) {
			this.value = value;
		}
	}

	// 方法一：利用队列收集中序遍历
	// 时间o(N),空间o(N)
	public Node convert_1(Node head) {
		Queue<Node> queue = new LinkedList<>();
		inOrderToQueue(head, queue);
		if (queue.isEmpty()) {
			return head;
		}
		head = queue.poll();
		Node pre = head;
		pre.left = null; // 头节点
		Node cur = null;
		while (!queue.isEmpty()) {
			cur = queue.poll();
			pre.right = cur;
			cur.left = pre;
			pre = cur;
		}
		pre.right = null;
		return head;
	}

	// 中序遍历入队
	public void inOrderToQueue(Node head, Queue<Node> queue) {
		if (head == null) {
			return;
		}
		inOrderToQueue(head.left, queue);
		queue.offer(head);
		inOrderToQueue(head.right, queue);
	}

	// 方法二：利用递归
	// 时间o(N),空间o(h)
	public Node convert_2(Node head) {
		if (head == null) {
			return null;
		}
		Node last = process(head); // 结尾右指针指向头节点
		head = last.right;
		last.right = null;
		return head;
	}

	public Node process(Node head) {
		if (head == null) {
			return null;
		}
		Node leftE = process(head.left); // 左子树的尾节点
		Node rightE = process(head.right); // 右子树的尾节点
		Node leftS = leftE != null ? leftE.right : null; // 左子树的头节点
		Node rightS = rightE != null ? rightE.right : null; // 右子树的头节点

		if (leftE != null && rightE != null) { // 两边都非空
			leftE.right = head;
			head.left = rightE;
			head.right = rightS;
			rightS.left = head;
			rightE.right = leftS; // 最大值的右指针指向最小值
			return rightE;
		} else if (leftE != null) { // 右子树为空
			leftE.right = head;
			head.left = leftE;
			head.right = leftS;
			return head;
		} else if (rightE != null) { // 左子树为空
			head.right = rightS;
			rightS.left = head;
			rightE.right = head;
			return rightE;
		} else { // 左右都为空
			head.right = head;
			return head;
		}
	}
}
```



# 16. 单链表的选择排序

**题目**

给定一个无序单链表的头节点head，实现单链表的选择排序。

**要求**

额外空间复杂度o(1)

```java
public class Code_16_SelectionSort {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node selectionSort(Node head) {
		Node tail = null; // 排序部分尾部
		Node cur = head; // 未排序部分头部
		Node smallPre = null; // 最小节点的前一个节点
		Node small = null; // 最小的节点
		while (cur != null) {
			small = cur;
			smallPre = getSmallestPreNode(cur);
			// 断开最小值连接
			if (smallPre != null) {
				small = smallPre.next;
				smallPre.next = small.next;
			}
			cur = cur == small ? cur.next : cur;
			// 插入到排序部分
			if (tail == null) {
				head = small;
			} else {
				tail.next = small;
			}
			tail = small;
		}
		return head;
	}

	// 获取未排序部分最小值的前一个节点
	public Node getSmallestPreNode(Node head) {
		Node smallPre = null;
		Node small = head;
		Node pre = head;
		Node cur = head.next;
		while (cur != null) {
			// 找到最小值
			if (cur.value < small.value) {
				small = cur;
				smallPre = pre;
			}
			pre = cur;
			cur = cur.next;
		}
		return smallPre;
	}

}
```



# 17. 一种怪异的节点删除方式

**题目**

链表节点值类型为int类型，给定一个链表的节点node，但不给定整个链表的头节点，如何在链表中删除node？

**要求**

时间复杂度o(1)

```java
public class Code_17_RemoveNodeWired {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public void removeNodeWired(Node node) {
		if (node == null) {
			return;
		}
		Node next = node.next;
		if (next == null) {
			throw new RuntimeException("can not remove last node.");
		}
        // 复制下一个节点的信息
		node.value = next.value;
		node.next = next.next;
	}
}
```



# 18. 向有序的环形单链表中插入新节点

**题目**

一个环形单链表从头节点head开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生成节点值为num的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。

```java
package chapter_02;

public class Code_18_InsertNum {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 时间复杂度o(N),空间复杂度o(1)
	public Node insertNum(Node head, int num) {
		Node node = new Node(num);
		if (head == null) {
			node.next = node;
			return node;
		}
		Node pre = head;
		Node cur = head.next;
		// 寻找插入位置
		while (cur != head) {
			if (pre.value <= node.value && cur.value >= node.value) {
				break;
			}
			pre = cur;
			cur = cur.next;
		}
		// 插入链表中
		pre.next = node;
		node.next = cur;
		return head.value < num ? head : node;
	}

}
```



# 19. 合并两个有序的单链表

**题目**

给定两个有序单链表的头节点head1和head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后链表的头节点。

```java
public class Code_19_Merge {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	// 时间复杂度o(N+M),空间复杂度o(1)
	public Node merge(Node head1, Node head2) {
		// 有一个为空直接返回
		if (head1 == null || head2 == null) {
			return head1 == null ? head2 : head1;
		}
		Node head = head1.value <= head2.value ? head1 : head2; // head指向小头部
		Node cur1 = head == head1 ? head1 : head2; // cur1指向小头
		Node cur2 = head == head1 ? head2 : head1; // cur2指向大头
		Node pre = null;
		Node next = null;
		while (cur1 != null && cur2 != null) {
			if (cur1.value <= cur2.value) {
				pre = cur1;
				cur1 = cur1.next;
			} else {
				next = cur2.next;
				pre.next = cur2;
				cur2.next = cur1;
				cur2 = next;
			}
		}
		// 连接剩下的部分
		pre = cur1 == null ? cur2 : cur1;
		return head;
	}

}
```



# 20. 按照左右半区的方式重新组合单链表

**题目**

给定一个单链表的头节点head，链表长度为N，

如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区。

左半区从左到右依次记为L1->L2...，右半区从左到右依次记为R1->R2...，请将单链表调整为L1->R1->L2->R2...的形式。

```java
public class Code_20_Relocate {

	public class Node {
		public int value;
		public Node next;

		public Node(int data) {
			this.value = data;
		}
	}

	public void relocate(Node head) {
		if (head == null || head.next == null) {
			return;
		}
		// 快慢指针找中点
		Node mid = head;
		Node right = head.next;
		while (right != null && right.next != null) {
			mid = mid.next;
			right = right.next.next;
		}
		right = mid.next; // 右半区第一个节点
		mid.next = null; // 断开左右半区
		mergeLR(head, right);
	}

	// 合并左右半区
	public void mergeLR(Node left, Node right) {
		Node next = null;
		while (left.next != null) {
			next = right.next;
			right.next = left.next;
			left.next = right;
			left = right.next;
			right = next;
		}
		// 最后一个
		left.next = right;
	}

}
```

