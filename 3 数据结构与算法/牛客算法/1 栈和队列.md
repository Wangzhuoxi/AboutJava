# 1. 设计一个有 getMin 功能的栈

**题目**

实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

**要求**

1. pop、push、getMin 操作的时间复杂度都是 O(1)
2. 设计的栈类型可以使用现成的栈结构

```java
import java.util.Stack;

public class Code_01_GetMin {

	class MyStack {
		private Stack<Integer> stackData; // 保存元素
		private Stack<Integer> stackMin;  // 保存最小值

		public MyStack() {
			this.stackData = new Stack<>();
			this.stackMin = new Stack<>();
		}

		public void push(int newNum) {
			if (this.stackMin.isEmpty()) {
				this.stackMin.push(newNum);
			} else if (newNum <= getMin()) {
				this.stackMin.push(newNum);
			}
			this.stackData.push(newNum);
		}

		public int pop() {
			if (stackData.isEmpty()) {
				throw new RuntimeException("the stack is empty.");
			}
			int value = this.stackData.pop();
			if (value == this.getMin()) {
				this.stackMin.pop();
			}
			return value;
		}

		public int getMin() {
			if (this.stackMin.isEmpty()) {
				throw new RuntimeException("the stack is empty.");
			}
            // stackMin的栈顶元素始终是当前stackData中的最小值
			return this.stackMin.peek();
		}
	}

}
```



# 2. 由两个栈组成的队列

**题目**

编写一个类，用两个栈实现队列，支持队列的基本操作（add、poll、peek）。

```java
import java.util.Stack;

public class Code_02_TwoStackQueue {

	class TwoStackQueue {
		private Stack<Integer> stackPush; // 压入栈
		private Stack<Integer> stackPop;  // 弹出栈

		public TwoStackQueue() {
			stackPush = new Stack<>();
			stackPop = new Stack<>();
		}

		public void add(int pushInt) {
			stackPush.push(pushInt);
		}

		// 压入栈向弹出栈转移的条件：弹出栈为空且一次转移完
		public int poll() {
			if (stackPop.isEmpty() && stackPush.isEmpty()) {
				throw new RuntimeException("Queue is empty!");
			} else if (stackPop.isEmpty()) {
				while (!stackPush.isEmpty()) {
					stackPop.push(stackPush.pop());
				}
			}
			return stackPop.pop();
		}

		public int peek() {
			if (stackPop.isEmpty() && stackPush.isEmpty()) {
				throw new RuntimeException("Queue is empty!");
			} else if (stackPop.isEmpty()) {
				while (!stackPush.isEmpty()) {
					stackPop.push(stackPush.pop());
				}
			}
			return stackPop.peek();
		}
	}

}
```



# 3. 如何仅用递归函数和栈操作逆序一个栈

**题目**

实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。

```java
import java.util.Stack;

public class Code_03_ReverseStack {

	// 将栈底元素返回并移除
	public int getAndRemoveLastElement(Stack<Integer> stack) {
		int result = stack.pop();
		if (stack.isEmpty()) {
			return result;
		} else {
			int last = getAndRemoveLastElement(stack);
			// 将非底的元素重新放回
			stack.push(result);
			return last;
		}
	}

	// 逆序一个栈
	public void reverse(Stack<Integer> stack) {
		if (stack.isEmpty()) {
			return;
		}
		int i = getAndRemoveLastElement(stack);
		reverse(stack);
		stack.push(i);
	}

}
```



# 4. 猫狗队列

**题目**

实现一种猫狗队列的结构，要求如下：

- 调用 add 方法将 cat 类或者 dog 类的实例放入队列中

- 调用 pollAll 方法将队列中所有的实例按照进队列的先后顺序依次弹出

- 调用 pollDog 方法将队列中的 dog 类实例按照进队列的先后顺序依次弹出

- 调用 pollCat 方法将队列中的 cat 类实例按照进队列的先后顺序依次弹出

- 调用 isEmpty 方法检查队列中是否还有 dog 或者 cat 类的实例
- 调用 isDogEmpty 方法检查队列中是否还有 dog 类的实例
- 调用 isCatEmpty 方法检查队列中是否还有 cat 类的实例

```java
import java.util.LinkedList;
import java.util.Queue;

public class Code_04_DogCatQueue {

	// 给定Pet类、Dog类和Cat类
	class Pet {
		private String type;

		public Pet(String type) {
			this.type = type;
		}

		public String getType() {
			return this.type;
		}
	}

	class Dog extends Pet {
		public Dog() {
			super("dog");
		}
	}

	class Cat extends Pet {
		public Cat() {
			super("cat");
		}
	}

	// Pet包装类
	class PetEnterQueue {
		private Pet pet;
		private long count;

		public PetEnterQueue(Pet pet, Long count) {
			this.pet = pet;
			this.count = count;
		}

		public Pet getPet() {
			return this.pet;
		}

		public Long getCount() {
			return this.count;
		}

		public String getEnterPetType() {
			return this.pet.getType();
		}
	}

	class DogCatQueue {
		private Queue<PetEnterQueue> dogQ;
		private Queue<PetEnterQueue> catQ;
		private long count;

		public DogCatQueue() {
			this.dogQ = new LinkedList<>();
			this.catQ = new LinkedList<>();
			this.count = 0;
		}

		public void add(Pet pet) {
			if (pet.getType().equals("dog")) {
				this.dogQ.add(new PetEnterQueue(pet, this.count++));
			} else if (pet.getType().equals("cat")) {
				this.catQ.add(new PetEnterQueue(pet, this.count++));
			} else {
				throw new RuntimeException("err,not dog or cat");
			}
		}

		public Pet pollAll() {
			if (!this.catQ.isEmpty() && !this.dogQ.isEmpty()) {
				if (this.catQ.peek().getCount() < this.dogQ.peek().getCount()) {
					return this.catQ.poll().getPet();
				} else {
					return this.dogQ.poll().getPet();
				}
			} else if (!this.catQ.isEmpty()) {
				return this.catQ.poll().getPet();
			} else if (!this.dogQ.isEmpty()) {
				return this.dogQ.poll().getPet();
			} else {
				throw new RuntimeException("Queue is empty.");
			}
		}

		public Cat pollCat() {
			if (!this.catQ.isEmpty()) {
				return (Cat) this.catQ.poll().getPet();
			} else {
				throw new RuntimeException("Cat queue is empty.");
			}
		}

		public Dog pollDog() {
			if (!this.dogQ.isEmpty()) {
				return (Dog) this.dogQ.poll().getPet();
			} else {
				throw new RuntimeException("Dog queue is empty.");
			}
		}

		public boolean isEmpty() {
			return this.catQ.isEmpty() && this.dogQ.isEmpty();
		}

		public boolean isDogEmpty() {
			return this.dogQ.isEmpty();
		}

		public boolean isCatEmpty() {
			return this.catQ.isEmpty();
		}
	}

}
```



# 5. 用一个栈实现另一个栈的排序

**题目**

一个栈中元素的类型为整数，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。

```java
import java.util.Stack;

public class Code_05_SortStackByStack {

	public void sortStackByStack(Stack<Integer> stack) {
		Stack<Integer> help = new Stack<>();
		while (!stack.isEmpty()) {
			int cur = stack.pop();
			// cur > help.peek
			while (!help.isEmpty() && help.peek() < cur) {
				stack.push(help.pop());
			}
			// cur <= help.peek
			help.push(cur);
		}
		while (!help.isEmpty()) {
			stack.push(help.pop());
		}
	}

}
```



# 6. 用栈来解决汉诺塔问题

**题目**

修改经典汉诺塔问题规则：限制不能从最左侧的塔直接移动到最右侧，也不能从最右侧直接移动到最左侧，必须经过中间。求当塔有 N 层的时候，打印最优移动过程和最优移动总步数。

```java
package chapter_01;

import java.util.Stack;

public class Code_06_HanoiProblem {

	// 方法一：递归
	public int hanoiProblem_1(int num, String left, String mid, String right) {
		if (num < 1) {
			return 0;
		}
		return process(num, left, mid, right, left, right);
	}

	public int process(int num, String left, String mid, String right, String from, String to) {
		if (num == 1) {
			if (from.equals(mid) || to.equals(mid)) { // 包含中间柱，只需一步
				System.out.println("Move 1 from " + from + " to " + to);
				return 1;
			} else { // 不包含中间柱，需要两步
				System.out.println("Move 1 from " + from + " to " + mid);
				System.out.println("Move 1 from " + mid + " to " + to);
				return 2;
			}
		}
		if (from.equals(mid) || to.equals(mid)) { // 三个步骤
			String another = (from.equals(left) || to.equals(left)) ? right : left;
			int part1 = process(num - 1, left, mid, right, from, another);
			int part2 = 1;
			System.out.println("Move " + num + " from " + from + " to " + to);
			int part3 = process(num - 1, left, mid, right, another, to);
			return part1 + part2 + part3;
		} else { // 五个步骤
			int part1 = process(num - 1, left, mid, right, from, to);
			int part2 = 1;
			System.out.println("Move " + num + " from " + from + " to " + mid);
			int part3 = process(num - 1, left, mid, right, to, from);
			int part4 = 1;
			System.out.println("Move " + num + " from " + mid + " to " + to);
			int part5 = process(num - 1, left, mid, right, from, to);
			return part1 + part2 + part3 + part4 + part5;
		}
	}

	public enum Action {
		No, LToM, MToL, MToR, RToM
	}

	// 方法二：非递归
	public int hanoiProblem_2(int num, String left, String mid, String right) {
		Stack<Integer> lS = new Stack<>();
		Stack<Integer> mS = new Stack<>();
		Stack<Integer> rS = new Stack<>();
		lS.push(Integer.MAX_VALUE);
		mS.push(Integer.MAX_VALUE);
		rS.push(Integer.MAX_VALUE);
		for (int i = num; i > 0; i--) {
			lS.push(i);
		}
		Action[] record = { Action.No };// 记录前一步动作
		int step = 0;
		// 每次的四个动作只能有一个满足原则要求
		while (rS.size() != num + 1) {
			step += fStackToStack(record, Action.MToL, Action.LToM, lS, mS, left, mid);
			step += fStackToStack(record, Action.LToM, Action.MToL, mS, lS, mid, left);
			step += fStackToStack(record, Action.MToR, Action.RToM, rS, mS, right, mid);
			step += fStackToStack(record, Action.RToM, Action.MToR, mS, rS, mid, right);
		}
		return step;
	}

	public int fStackToStack(Action[] record, Action preNoAct, Action nowAct, Stack<Integer> fStack,
			Stack<Integer> tStack, String from, String to) {
		// 1.小压大原则
		// 2.相邻不可逆原则
		if (record[0] != preNoAct && fStack.peek() < tStack.peek()) {
			tStack.push(fStack.pop());
			System.out.println("Move " + tStack.peek() + " from " + from + " to " + to);
			record[0] = nowAct;
			return 1;
		}
		return 0;
	}

}
```



# 7. 生成窗口最大值数组

**题目**

有一个整型数组 arr 和一个大小为 w 的窗口从数组的最左边滑到最右边，窗口每次向右滑动一个位置

如果数组长度为 n，窗口大小为 w，则一共产生 n-w+1 个窗口的最大值，输出窗口最大值数组

```java
import java.util.LinkedList;

public class Code_07_GetMaxWindow {

	public int[] getMaxWindow(int[] arr, int w) {
		if (arr == null || w < 1 || arr.length < w) {
			return null;
		}
		LinkedList<Integer> qmax = new LinkedList<>(); // 存放下标的队列
		int[] res = new int[arr.length - w + 1];
		int index = 0;

		for (int i = 0; i < arr.length; i++) {
			while (!qmax.isEmpty() && arr[qmax.peekLast()] < arr[i]) {
				qmax.pollLast();
			}
			qmax.addLast(i);
			if (qmax.peekFirst() < i - w) { // 看最大值是否过期
				qmax.pollFirst();
			}
			if (i > w - 1) {
				res[index++] = arr[qmax.peekFirst()];
			}
		}
		return res;
	}

}
```



# 8. 构造数组的 MaxTree

**题目**

一个数组的 MaxTree 定义如下：

- 数组必须没有重复元素
- MaxTree 是一颗二叉树，数组的每一个值对应一个二叉树节点
- 包含 MaxTree 树在内且在其中的每一颗子树上，值最大的节点都是树的头

给定一个没有重复元素的数组 arr，生成这个数组的 MaxTree，要求时间复杂度 o(N)，额外空间复杂度 o(N)

```java
import java.util.HashMap;
import java.util.Stack;

public class Code_08_GetMaxTree {

	public class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int data) {
			this.value = data;
		}
	}

	public Node getMaxTree(int[] arr) {
		Node[] nArr = new Node[arr.length]; // 二叉树节点数组
		for (int i = 0; i < arr.length; i++) {
			nArr[i] = new Node(arr[i]);
		}

		Stack<Node> stack = new Stack<>(); // 单调栈
		HashMap<Node, Node> lBigMap = new HashMap<>(); // 记录各元素的左侧第一个大于它的值
		HashMap<Node, Node> rBigMap = new HashMap<>(); // 记录各元素的右侧第一个大于它的值

		// 左->右：找到每个元素左边第一个比它大的人
		for (int i = 0; i < nArr.length; i++) {
			Node curNode = nArr[i];
			while ((!stack.isEmpty()) && stack.peek().value < curNode.value) {
				popStackSetMap(stack, lBigMap);
			}
			stack.push(curNode);
		}
		while (!stack.isEmpty()) {
			popStackSetMap(stack, lBigMap);
		}

		// 右->左：找到每个元素右边第一个比它大的人
		for (int i = nArr.length - 1; i >= 0; i--) {
			Node curNode = nArr[i];
			while ((!stack.isEmpty()) && stack.peek().value < curNode.value) {
				popStackSetMap(stack, rBigMap);
			}
			stack.push(curNode);
		}
		while (!stack.isEmpty()) {
			popStackSetMap(stack, rBigMap);
		}

		// 生成二叉树：一个数的父节点是左右第一个大于它的值中较小的那个
		Node head = null;
		for (int i = 0; i < nArr.length; i++) {
			Node curNode = nArr[i];
			Node leftBig = lBigMap.get(curNode);
			Node rightBig = rBigMap.get(curNode);
			if (leftBig == null && rightBig == null) {
				head = curNode;
			} else if (leftBig == null) {
				if (rightBig.left == null) {
					rightBig.left = curNode;
				} else {
					rightBig.right = curNode;
				}
			} else if (rightBig == null) {
				if (leftBig.left == null) {
					leftBig.left = curNode;
				} else {
					leftBig.right = curNode;
				}
			} else {
				Node parent = leftBig.value < rightBig.value ? leftBig : rightBig;
				if (parent.left == null) {
					parent.left = curNode;
				} else {
					parent.right = curNode;
				}
			}
		}
		return head;
	}

	// 弹出栈顶元素并设置元素的左右第一个大于值
	public void popStackSetMap(Stack<Node> stack, HashMap<Node, Node> map) {
		Node curNode = stack.pop();
		if (stack.isEmpty()) {
			map.put(curNode, null);
		} else {
			map.put(curNode, stack.peek());
		}
	}

}
```



# 9. 求最大子矩阵的大小

**题目**

给定一个整型矩阵 map，其中的值只有 0 和 1 两种，求其中全是 1 的所有矩形区域中，最大的矩形区域为 1 的数量，时间复杂度 o(N x M)

```java
import java.util.Stack;

public class Code_09_MaxRecSize {

	// 根据高度数组直方图，求出最大矩阵
	public int maxRecFromBottom(int[] height) {
		if (height == null || height.length == 0) {
			return 0;
		}
		int maxArea = 0;
		Stack<Integer> stack = new Stack<>(); // 单调栈（大到小）

		for (int i = 0; i < height.length; i++) {
			// 新值小于栈顶则出栈
			while (!stack.isEmpty() && height[i] <= height[stack.peek()]) {
				int j = stack.pop(); // 统计的是栈顶元素
				int k = stack.isEmpty() ? -1 : stack.peek();
				int curArea = (i - k - 1) * height[j];
				maxArea = Math.max(maxArea, curArea);
			}
			stack.push(i);
		}

		while (!stack.isEmpty()) {
			int j = stack.pop();
			int k = stack.isEmpty() ? -1 : stack.peek();
			int curArea = (height.length - k - 1) * height[j]; // 右侧都比当前值大
			maxArea = Math.max(maxArea, curArea);
		}
		return maxArea;
	}

	// 统计以每一行为底时，形成的高度数组直方图
	public int maxRectSize(int[][] map) {
		if (map == null || map.length == 0 || map[0].length == 0) {
			return 0;
		}
		int maxArea = 0;
		int[] height = new int[map[0].length];
		for (int i = 0; i < map.length; i++) {
			for (int j = 0; j < map[0].length; j++) {
				height[j] = map[i][j] == 0 ? 0 : height[j] + 1;
			}
			maxArea = Math.max(maxRecFromBottom(height), maxArea);
		}
		return maxArea;
	}
}
```



# 10. 最大值减去最小值大于或等于 num 的子数组数量

**题目**

给定数组 arr 和整数 num，返回有多少个子数组满足 max( arr[i...j] ) - min( arr[i...j] ) <= num

要求时间复杂度 o(N)

```java
import java.util.LinkedList;

public class Code_10_GetNum {

	public int getNum(int[] arr, int num) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		LinkedList<Integer> qmin = new LinkedList<>(); // 维护窗口最小值
		LinkedList<Integer> qmax = new LinkedList<>(); // 维护窗口最大值
		int i = 0;
		int j = 0;
		int res = 0;
		while (i < arr.length) { // 左边界
			while (j < arr.length) { // 右边界
				while (!qmin.isEmpty() && arr[qmin.peekLast()] >= arr[j]) {
					qmin.pollLast();
				}
				qmin.addLast(j);
				while (!qmax.isEmpty() && arr[qmax.peekLast()] <= arr[j]) {
					qmax.pollLast();
				}
				qmax.addLast(j);
				if (arr[qmax.getFirst()] - arr[qmin.getFirst()] > num) {
					break;
				}
				j++; // 扩充右边界
			}
			// 处理过期最值
			if (qmin.peekFirst() == i) {
				qmin.pollFirst();
			}
			if (qmax.peekFirst() == i) {
				qmax.pollFirst();
			}
			res += j - i; // i...j达标，其中的任何子数组都达标
			i++; // 扩充左边界
		}
		return res;
	}

}
```

