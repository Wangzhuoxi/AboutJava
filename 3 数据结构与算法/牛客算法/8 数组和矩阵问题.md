## 1 转圈打印矩阵

给定一个整数矩阵matrix，请按照转圈的方式打印它。要求额外空间复杂度o(1)。

```java
public class Code_01_SpiralOrderPrint {

	public static void spiralOrderPrint(int[][] matrix) {
		int tR = 0;
		int tC = 0;	//左上角
		int dR = matrix.length - 1;
		int dC = matrix[0].length - 1;	//右下角
		while (tR <= dR && tC <= dC) {
			printEdge(matrix, tR++, tC++, dR--, dC--);
		}
	}

	// 打印一圈
	public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
		if (tR == dR) { // 只有一行的情况
			for (int i = tC; i <= dC; i++) {
				System.out.print(m[tR][i] + " ");
			}
		} else if (tC == dC) { // 只有一列的情况
			for (int i = tR; i <= dR; i++) {
				System.out.print(m[i][tC] + " ");
			}
		} else { // 一圈的情况
			int curC = tC;
			int curR = tR;
			while (curC != dC) {
				System.out.print(m[tR][curC] + " ");
				curC++;
			}
			while (curR != dR) {
				System.out.print(m[curR][dC] + " ");
				curR++;
			}
			while (curC != tC) {
				System.out.print(m[dR][curC] + " ");
				curC--;
			}
			while (curR != tR) {
				System.out.print(m[curR][tC] + " ");
				curR--;
			}
		}
	}
}
```



## 2 将正方形矩阵顺时针转动90°

给定一个NxN的矩阵mattix，将这个矩阵调整成顺时针转动90°后的形式。要求额外空间复杂度o(1)。

```java
public class Code_02_RotateMatrix {

	public static void rotate(int[][] matrix) {
		int tR = 0;
		int tC = 0;
		int dR = matrix.length - 1;
		int dC = matrix[0].length - 1;
		while (tR < dR) {
			// 从外向内将矩阵旋转
			rotateEdge(matrix, tR++, tC++, dR--, dC--);
		}
	}

	// 旋转矩阵的一圈
	public static void rotateEdge(int[][] m, int tR, int tC, int dR, int dC) {
		int times = dC - tC; // 旋转次数
		int tmp = 0;
		// 旋转
		for (int i = 0; i != times; i++) {
			tmp = m[tR][tC + i];
			m[tR][tC + i] = m[dR - i][tC];
			m[dR - i][tC] = m[dR][dC - i];
			m[dR][dC - i] = m[tR + i][dC];
			m[tR + i][dC] = tmp;
		}
	}

}
```



## 3 之字形打印矩阵

给定一个矩阵matrix，按照之字形的方式打印这个矩阵，要求额外空间复杂度o(1)。

```java
public class Code_03_PrintMatrixZigZag {

	public static void printMatrixZigZag(int[][] matrix) {
		int aR = 0;
		int aC = 0;
		int bR = 0;
		int bC = 0;
		int endR = matrix.length - 1;
		int endC = matrix[0].length - 1;
		boolean fromUp = false; // 打印方向
		while (aR != endR + 1) {
			printLevel(matrix, aR, aC, bR, bC, fromUp);
			// A：先右移，到边界后下移
			aR = aC == endC ? aR + 1 : aR;
			aC = aC == endC ? aC : aC + 1;
			// B：先下移，到边界后右移
			bC = bR == endR ? bC + 1 : bC;
			bR = bR == endR ? bR : bR + 1;
			fromUp = !fromUp; // 翻转方向
		}
		System.out.println();
	}

	// 打印左下到右上的直线
	public static void printLevel(int[][] m, int aR, int aC, int bR, int bC, boolean f) {
		if (f) {
			while (aR != bR + 1) {
				System.out.print(m[aR++][aC--] + " ");
			}
		} else {
			while (bR != aR - 1) {
				System.out.print(m[bR--][bC++] + " ");
			}
		}
	}
}
```



## 4 找到无序数组中最小的k个数

给定一个无序的整型数组arr，找到其中最小的k个数。

```java
// 利用堆排序复杂度最低
public class Code_04_GetMinKNums {

	public int[] getMinKNumsByHeap(int[] arr, int k) {
		if (k < 1 || k > arr.length) {
			return arr;
		}
		int[] kHeap = new int[k]; // 大根堆
		// 先将前k个数入堆
		for (int i = 0; i != k; i++) {
			heapInsert(kHeap, arr[i], i);
		}
		// 判断后续数字是否小于当前最大值
		for (int i = k; i != arr.length; i++) {
			if (arr[i] < kHeap[0]) {
				kHeap[0] = arr[i];	//替换掉堆顶
				heapify(arr, 0, k);
			}
		}
		return kHeap;
	}

	// 向大根堆中添加数据
	public void heapInsert(int[] arr, int value, int index) {
		arr[index] = value;
		while (index != 0) {
			int parent = (index - 1) / 2;	//索引从0开始
			if (arr[parent] < arr[index]) {
				swap(arr, index, parent);
				index = parent;
			} else {
				break;
			}
		}
	}

	// 调整堆的结构使其重新符合条件
	public void heapify(int[] arr, int index, int heapSize) {
		int left = index * 2 + 1;
		int right = index * 2 + 2;
		int largest = index;
		while (left < heapSize) {
			if (arr[left] > arr[index]) {
				largest = left;
			}
			if (right < heapSize && arr[right] > arr[largest]) {
				largest = right;
			}
			if (largest != index) {
				swap(arr, largest, index);
			} else {
				break;
			}
			index = largest;
			left = index * 2 + 1;
			right = index * 2 + 2;
		}
	}

	public void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}
}
```



## 5 需要排序的最短子数组长度

给定一个无序数组arr，求出需要排序的最短子数组长度。

例如：arr=[1,5,3,4,2,6,7]返回4，因为只有[5,3,4,2]需要排序。

```java
public class Code_05_GetMinLength {

	public int getMinLength(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		int min = arr[arr.length - 1]; // 当前最小值
		int noMinIndex = -1; // 最左边出现arr[i]>min
		// 从右往左遍历找最小值
		for (int i = arr.length - 2; i != -1; i--) {
			if (arr[i] > min) {
				noMinIndex = i;
			} else {
				min = Math.min(min, arr[i]);
			}
		}
		// 说明整体有序直接返回
		if (noMinIndex == -1) {
			return 0;
		}
		int max = arr[0];
		int noMaxIndex = -1;
		// 从左往右遍历找最大值
		for (int i = 1; i != arr.length; i++) {
			if (arr[i] < max) {
				noMaxIndex = i;
			} else {
				max = Math.max(max, arr[i]);
			}
		}
		return noMaxIndex - noMinIndex + 1; // 中间部分就是需要排序的部分
	}
}
```



## 6 在数组中找到出现次数大于N/K的数

给定一个整型数组arr，打印其中出现次数大于一半的数，如果没有这样的数，打印提示信息。

```java
public class Code_06_PrintMajor {

	public void printHalfMajor(int[] arr) {
		int cand = 0; // 候选数
		int times = 0; // 出现的次数
		for (int i = 0; i < arr.length; i++) {
			if (times == 0) { // 等于0说明不超过一半
				cand = arr[i];
				times = 1;
			} else if (arr[i] == cand) {
				times++; // 重复值累加
			} else {
				times--; // 删除两个不同的值
			}
		}
		times = 0;
		// 最后需要判断一下
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] == cand) {
				times++;
			}
		}
		if (times > arr.length / 2) {
			System.out.println(cand);
		} else {
			System.out.println("no such number.");
		}
	}
}
```

给定一个整型数组arr，在给定一个整数K，打印所有出现次数大于N/K的数，如果没有这样的数，打印提示信息。

```java
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;

public class Code_06_PrintMajor {

	public void printKMajor(int[] arr, int K) {
		if (K < 2) {
			System.out.println("the value of K is invalid.");
		}
		HashMap<Integer, Integer> cands = new HashMap<Integer, Integer>();// 保存K个数出现次数
		for (int i = 0; i < arr.length; i++) {
			if (cands.containsKey(arr[i])) {
				cands.put(arr[i], cands.get(arr[i]) + 1);
			} else {
				if (cands.size() == K - 1) { // 同时删除K个数
					allCandsMinusOne(cands);
				} else {
					cands.put(arr[i], 1); // 添加未出现的数
				}
			}
		}
		HashMap<Integer, Integer> reals = getReals(arr, cands);
		boolean hasPrint = false; // 是否又符合条件的值
		// 再进行一次判断
		for (Entry<Integer, Integer> set : cands.entrySet()) {
			Integer key = set.getKey();
			if (reals.get(key) > arr.length / K) {
				hasPrint = true;
				System.out.print(key + " ");
			}
		}
		System.out.println(hasPrint ? "" : "no such number.");
	}

	// 将所有不同值都减一
	public void allCandsMinusOne(HashMap<Integer, Integer> map) {
		List<Integer> removeList = new LinkedList<Integer>();
		for (Entry<Integer, Integer> set : map.entrySet()) {
			Integer key = set.getKey();
			Integer value = set.getValue();
			if (value == 1) { // 减一后变为0则移除
				removeList.add(key);
			}
			map.put(key, value - 1);
		}
		for (Integer removeKey : removeList) {
			map.remove(removeKey);
		}
	}

	// 统计不同值出现的次数
	public HashMap<Integer, Integer> getReals(int[] arr, HashMap<Integer, Integer> cands) {
		HashMap<Integer, Integer> reals = new HashMap<Integer, Integer>();
		for (int i = 0; i < arr.length; i++) {
			int curNum = arr[i];
			if (cands.containsKey(curNum)) {
				if (reals.containsKey(curNum)) {
					reals.put(curNum, reals.get(curNum) + 1);
				} else {
					reals.put(curNum, 1);
				}
			}
		}
		return reals;
	}
}
```



## 7 在行列都排好的矩阵中找数

给定一个有NxM的整型矩阵matrix和一个整数K，matrix的每一行和每一列都是排好序的。实现一个函数，判断K是否在matrix中。

```java
public class Code_07_IsContains {

	public boolean isContains(int[][] matrix, int K) {
		int row = 0;
		int col = matrix[0].length - 1;
		while (row < matrix.length && col > -1) {
			if (matrix[row][col] == K) {
				return true;
			} else if (matrix[row][col] > K) {
				col--;
			} else {
				row++;
			}
		}
		return false;
	}
}
```



## 8 最长的可整合子数组的长度

可整合数组定义：如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。

给定一个整型数组arr，请返回其中最大可整合子数组的长度。

```java
import java.util.HashSet;

public class Code_08_GetLIL {

	public int getLIL(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int len = 0;
		int max = 0;
		int min = 0;
		HashSet<Integer> set = new HashSet<Integer>();
		for (int i = 0; i < arr.length; i++) {
			max = Integer.MIN_VALUE;
			min = Integer.MAX_VALUE;
			for (int j = i; j < arr.length; j++) {
				if (set.contains(arr[j])) {
					break; // 有重复值不满足条件
				}
				set.add(arr[j]);
				max = Math.max(max, arr[j]);
				min = Math.min(min, arr[j]);
				if (max - min == j - i) { // 判定条件
					len = Math.max(len, j - i + 1);
				}
			}
			set.clear();
		}
		return len;
	}
}
```



## 9 不重复打印排序数组中相加和为给定值的所有二元组和三元组

给定排序数组arr和整数k，不重复打印arr中所有相加和为k的不降序二元组。

```java
public class Code_09_PrintUniquePair {

	public void printUniquePair(int[] arr, int k) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int left = 0;
		int right = arr.length - 1;
		while (left < right) {
			if (arr[left] + arr[right] < k) {
				left++;
			} else if (arr[left] + arr[right] > k) {
				right--;
			} else {
				if (left == 0 || arr[left - 1] != arr[left]) { // 重复值只计算一次
					System.out.println(arr[left] + "," + arr[right]);
				}
				left++;
				right--;
			}
		}
	}
}
```

给定排序数组arr和整数k，不重复打印arr中所有相加和为k的不降序三元组。

```java
public class Code_09_PrintUniquePair {

	public void printUniqueTriad(int[] arr, int k) {
		if (arr == null || arr.length < 3) {
			return;
		}
		for (int i = 0; i < arr.length - 2; i++) {
			if (i == 0 || arr[i] != arr[i - 1]) {
				// 固定第一个，然后就是二元组问题
				printRest(arr, i, i + 1, arr.length - 1, k - arr[i]);
			}
		}
	}

	public void printRest(int[] arr, int f, int l, int r, int k) {
		while (l < r) {
			if (arr[l] + arr[r] < k) {
				l++;
			} else if (arr[l] + arr[r] > k) {
				r--;
			} else {
				if (l == f + 1 || arr[l - 1] != arr[l]) { // 重复值只计算一次
					System.out.println(arr[f] + "," + arr[l] + "," + arr[r]);
				}
				l++;
				r--;
			}
		}
	}
}
```



## 10 未排序正数数组中累加和为给定值的最长子数组长度

给定一个无序数组arr，其中每个值都是正数，再给定一个正数k。求arr的所有子数组中所有元素相加和为k的最长子数组长度。

```java
public class Code_10_GetMaxLength {

	public int getMaxLength(int[] arr, int k) {
		if (arr == null || arr.length == 0 || k <= 0) {
			return 0;
		}
		int left = 0;
		int right = 0;
		int sum = arr[0];
		int len = 0;
		while (right < arr.length) {
			if (sum == k) {	//找到一个满足条件的结果
				len = Math.max(len, right - left + 1);
				sum -= arr[left++]; // 左指针右移
			} else if (sum < k) {	//还需要再加
				right++; // 右指针右移
				if (right == arr.length) {
					break;
				}
				sum += arr[right];
			} else {	//需要减少
				sum -= arr[left++];
			}
		}
		return len;
	}
}
```



## 11 未排序数组中累加和为给定值的最长子数组系列问题

给定一个无序数组arr，其中元素可正可负可0，给定一个整数k。求arr所有的子数组中累加和为k的最长子数组长度。

```java
import java.util.HashMap;

public class Code_11_MaxLength {

	public int maxLength(int[] arr, int k) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		// 记录累加和key最早出现的位置value
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		map.put(0, -1); // 重要
		int len = 0;
		int sum = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			if (map.containsKey(sum - k)) {
				len = Math.max(i - map.get(sum - k), len);
			}
			if (!map.containsKey(sum)) {
				map.put(sum, i);
			}
		}
		return len;
	}
}
```

补充题目：给定一个无序数组arr，其中元素可正可负可0。求arr所有的子数组中正数和负数个数相等的最长子数组长度。

解答：先把数组arr中的正数全部变为1，负数全部变为-1，0不变，然后求累加和为0的最长子数组长度。

补充题目：给定一个无序数组arr，其中元素只是1或0。求arr所有的子数组中0和1个数相等的最长子数组长度。

解答：先把数组arr中的0全部变为-1，1不变，然后求累加和为0的最长子数组长度即可。



## 12 未排序数组中累加和小于或等于给定值的最长子数组长度

给定一个无序数组arr，其中元素可正可负可0，给定一个整数k。求arr所有的子数组中累加和小于或等于k的最长子数组长度。

```java
public class Code_12_MaxLengthLessthanK {

	public int maxLength(int[] arr, int k) {
		int[] h = new int[arr.length + 1]; // 目前为止的最大累加和（不降序）
		int sum = 0;
		h[0] = sum;
		// 初始化辅助数组
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			h[i + 1] = Math.max(sum, h[i]);
		}
		sum = 0;
		int res = 0;
		int pre = 0;
		int len = 0;
		for (int i = 0; i < arr.length; i++) {
			sum += arr[i];
			pre = getLessIndex(h, sum - k);
			len = pre == -1 ? 0 : i - pre + 1;
			res = Math.max(res, len);
		}
		return res;
	}

	// 找到累加和为sum的最早出现为止
	public int getLessIndex(int[] arr, int num) {
		int low = 0;
		int high = arr.length - 1;
		int mid = 0;
		int res = -1;	//-1代表找不到
		// 通过二分查找找到num
		while (low <= high) {
			mid = (low + high) / 2;
			if (arr[mid] >= num) { // 要找到最早位置还需要继续向左
				res = mid;
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return res;
	}
}
```



## 13 计算数组的小和

数组小和的定义：所有位置数左边比它小的数相加的和。

给定一个数组s，实现函数返回s的小和。

```java
public class Code_13_GetSmallSum {

	public static int smallSum(int[] arr) {
		if (arr == null || arr.length < 2) {
			return 0;
		}
		return func(arr, 0, arr.length - 1);
	}

	public static int func(int[] arr, int l, int r) {
		if (l == r) {
			return 0;
		}
		int mid = l + ((r - l) >> 1);
		return func(arr, l, mid) + func(arr, mid + 1, r) + merge(arr, l, mid, r);
	}

	public static int merge(int[] arr, int left, int mid, int right) {
		int[] help = new int[right - left + 1];
		int hi = 0;
		int i = left;
		int j = mid + 1;
		int smallSum = 0;
		while (i <= mid && j <= right) {
			if (arr[i] <= arr[j]) {
				smallSum += arr[i] * (right - j + 1); // 产生小和
				help[hi++] = arr[i++];
			} else {
				help[hi++] = arr[j++];
			}
		}
		while (i <= mid) {
			help[hi++] = arr[i++];
		}
		while (j <= right) {
			help[hi++] = arr[j++];
		}
		// 拷贝回原数组
		for (hi = 0; hi < help.length; hi++) {
			arr[left + hi] = help[hi];
		}
		return smallSum;
	}
}
```



## 14 自然数数组的排序

给定一个长度为N的整型数组arr，其中有N个互不相等的自然数1~N，请实现arr的排序，但是不要把下标0~N-1位置上的数通过直接赋值的方法替换成1~N。

```java
public class Code_14_NumberSort {

	public void sort_1(int[] arr) {
		int tmp = 0;
		int next = 0;
		for (int i = 0; i < arr.length; i++) {
			tmp = arr[i]; // 保存当前值
			while (arr[i] != i + 1) {
				next = arr[tmp - 1]; // 当前数应放的位置
				arr[tmp - 1] = tmp;
				tmp = next; // 继续跳
			}
		}
	}

	public void sort_2(int[] arr) {
		int tmp = 0;
		for (int i = 0; i < arr.length; i++) {
			while (arr[i] != i + 1) { // 进行交换
				tmp = arr[arr[i] - 1];
				arr[arr[i] - 1] = arr[i];
				arr[i] = tmp;
			}
		}
	}

}
```



## 15 奇数下标都是奇数或者偶数下标都是偶数

给定一个长度不小于2的数组arr，实现一个函数调整arr，要么让所有的偶数下标都是偶数，要么让所有的奇数下标都是奇数。

```java
public class Code_15_ModifyNumPos {

	public void modify(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int even = 0; // 目前最左边的偶数下标
		int odd = 1; // 目前最左边的奇数下标
		int end = arr.length - 1;
		// 将最后一个不断和前面的位置交换
		while (even <= end && odd <= end) {
			if ((arr[end] & 1) == 0) {	//最后一个是偶数
				swap(arr, end, even);
				even += 2;
			} else {
				swap(arr, end, odd);
				odd += 2;
			}
		}
	}

	public void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}
}
```



## 16 子数组的最大累加和问题

给定一个数组arr，返回子数组的最大累加和。

```java
public class Code_16_MaxSum {

	public int maxSum(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int cur = 0;
		for (int i = 0; i < arr.length; i++) {
			cur += arr[i];
			max = Math.max(max, cur);
			cur = cur < 0 ? 0 : cur;// 出现负值说明不能算在最大值里面清零
		}
		return max;
	}

}
```



## 17 子矩阵的最大累加和问题

给定一个矩阵matrix，其中的值有正有负有0，返回子矩阵的最大累加和。

```java
public class Code_17_MaxSumMatrix {

	public int maxSum(int[][] m) {
		if (m == null || m.length == 0 || m[0].length == 0) {
			return 0;
		}
		int max = Integer.MIN_VALUE;
		int cur = 0;
		int[] s = null; // 累加数组
		for (int i = 0; i < m.length; i++) { // 以i行开始
			s = new int[m[0].length];
			for (int j = 0; j < m.length; j++) { // 以j行结束
				cur = 0;
				for (int k = 0; k < s.length; k++) {
					s[k] += m[j][k];
					cur += s[k]; // 整个子矩阵的累加和
					max = Math.max(max, cur);
					cur = cur < 0 ? 0 : cur;
				}
			}
		}
		return max;
	}
}
```



## 18 在数组中找到一个局部最小的位置

局部最小值： 

1. arr长度为1时，arr[0]是局部最小。

2. arr的长度为N(N>1)时，如果arr[0]<arr[1]，那么arr[0]是局部最小；如果arr[N-1]<arr[N-2]，那么arr[N-1]是局部最小；

3. 如果0<i<N-1，既有arr[i]<arr[i-1]，又有arr[i]<arr[i+1]，那么arr[i]是局部最小。

给定一个无序数组arr，已知arr中任意两个相邻的数都不相等。写一个函数，只需返回arr中任意一个局部最小出现的位置即可。

```java
public class Code_18_GetLessIndex {

	public int getLessIndex(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1; // 不存在
		}
		if (arr.length == 1 || arr[0] < arr[1]) {
			return 0;
		}
		if (arr[arr.length - 1] < arr[arr.length - 2]) {
			return arr.length - 1;
		}
		int left = 1;
		int right = arr.length - 2;
		int mid = 0;
        // 二分查找
		while (left < right) {
			mid = (left + right) / 2;
			if (arr[mid] > arr[mid - 1]) {
				right = mid - 1;
			} else if (arr[mid] > arr[mid + 1]) {
				left = mid + 1;
			} else {  				
                return mid; // 局部最小值
			}
		}
		return left;
	}
}
```



## 19 数组中子数组的最大累乘积

给定一个double类型的数组arr，其中的元素可正可负可0，返回子数组累乘的最大乘积。

```java
public class Code_19_MaxProduct {

	public double maxProduct(double[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		double max = arr[0]; // 之前位置累乘的最大值
		double min = arr[0]; // 之前位置累乘的最小值（负值的情况）
		double res = arr[0];
		double maxEnd = 0;
		double minEnd = 0;
		for (int i = 1; i < arr.length; i++) {
			maxEnd = max * arr[i];
			minEnd = min * arr[i];
			max = Math.max(Math.max(maxEnd, minEnd), arr[i]);
			min = Math.min(Math.min(maxEnd, minEnd), arr[i]);
			res = Math.max(res, max);
		}
		return res;
	}
}
```



## 20 打印N个数组整体最大的Top K

有N个长度不一的数组，所有的数组都是有序的，请从大到小打印这N个数组整体最大的前K个数。要求如果所有数组的元素个数小于K，则从大到小打印所有的数。

```java
public class Code_20_PrintTopK {

	public class HeapNode {
		public int value;	// 值是什么
		public int arrNum;	// 来自哪个数组
		public int index;	// 来自数组的什么位置

		public HeapNode(int value, int arrNum, int index) {
			this.value = value;
			this.arrNum = arrNum;
			this.index = index;
		}
	}

	public void printTopK(int[][] matrix, int topK) {
		int heapSize = matrix.length;
		HeapNode[] heap = new HeapNode[heapSize];
		for (int i = 0; i < heap.length; i++) {
			int index = matrix[i].length - 1;
			heap[i] = new HeapNode(matrix[i][index], i, index);
			heapInsert(heap, i);
		}
		System.out.println("Top " + topK + " : ");
		for (int i = 0; i < topK; i++) {
			if (heapSize == 0) {
				break;
			}
			System.out.print(heap[0].value + " ");
			if (heap[0].index != 0) {	//用最大数那个数组的第二大替代
				heap[0].value = matrix[heap[0].arrNum][--heap[0].index];
			} else { //最大数所在数组没有前一个数就缩小堆
				swap(heap, 0, --heapSize);
			}
			heapify(heap, 0, heapSize);
		}
	}

	public void heapInsert(HeapNode[] heap, int index) {
		while (index != 0) {
			int parent = (index - 1) / 2;
			if (heap[parent].value < heap[index].value) {
				swap(heap, index, parent);
				index = parent;
			} else {
				break;
			}
		}
	}

	public void heapify(HeapNode[] heap, int index, int heapSize) {
		int left = index * 2 + 1;
		int right = index * 2 + 2;
		int largest = index;
		while (left < heapSize) {
			if (heap[left].value < heap[index].value) {
				largest = left;
			}
			if (right < heapSize && heap[right].value < heap[largest].value) {
				largest = right;
			}
            if (largest != index) {
				swap(heap, largest, index);
			} else {
				break;
			}
			index = largest;
			left = index * 2 + 1;
			right = index * 2 + 2;
		}
	}

	public void swap(HeapNode[] heap, int index1, int index2) {
		HeapNode tmp = heap[index1];
		heap[index1] = heap[index2];
		heap[index2] = tmp;
	}
}
```



## 21 边界都是1的最大正方形大小

给定一个NxN的矩阵matrix，在这个矩阵中，只有0和1两种值，返回边框全是1的最大正方形的边长长度。

```java
public class Code_21_GetMaxSize {

	public void setBorderMap(int[][] m, int[][] right, int[][] down) {
		int r = m.length;
		int c = m[0].length;	//右下角开始
		if (m[r - 1][c - 1] == 1) {
			right[r - 1][c - 1] = 1;
			down[r - 1][c - 1] = 1;
		}
		// 最后一列
		for (int i = r - 2; i != -1; i--) {
			if (m[i][c - 1] == 1) {
				right[i][c - 1] = 1;
				down[i][c - 1] = down[i + 1][c - 1] + 1;
			}
		}
		// 最后一行
		for (int i = c - 2; i != -1; i--) {
			if (m[r - 1][i] == 1) {
				right[r - 1][i] = right[r - 1][i + 1] + 1;
				down[r - 1][i] = 1;
			}
		}
		for (int i = r - 2; i != -1; i--) {
			for (int j = c - 2; j != -1; j--) {
				if (m[i][j] == 1) {
					right[i][j] = right[i][j + 1] + 1;
					down[i][j] = down[i + 1][j] + 1;
				}
			}
		}
	}

	public int getMaxSize(int[][] m) {
		int[][] right = new int[m.length][m[0].length];// 从(i,j)向右有多少个连续的1
		int[][] down = new int[m.length][m[0].length];// 从(i,j)向下有多少个连续的1
		setBorderMap(m, right, down);
		for (int size = Math.min(m.length, m[0].length); size != 0; size--) {
			// 判断不同边长的size
            if (hasSizeOfBorder(size, right, down)) {
				return size;
			}
		}
		return 0;
	}

	// 判断是否符合条件
	public boolean hasSizeOfBorder(int size, int[][] right, int[][] down) {
		for (int i = 0; i != right.length - size + 1; i++) {
			for (int j = 0; j != right[0].length - size + 1; j++) {
                // 判断四条边1的数量都要大于size
				if (right[i][j] >= size && down[i][j] >= size && right[i + size - 1][j] >= size
						&& down[i][j + size - 1] >= size) {
					return true;
				}
			}
		}
		return false;
	}
}
```



## 22 不包含本位置值的累乘数组

给定一个整型数组arr，返回不包含本位置值的累乘数组。

```java
public class Code_22_Product {

	public int[] product(int[] arr) {
		if (arr == null || arr.length < 2) {
			return null;
		}
		int count = 0; // 0的个数
		int all = 1; // 除0之外的累乘结果
		for (int i = 0; i < arr.length; i++) {
			if (arr[i] != 0) {
				all *= arr[i];
			} else {
				count++;
			}
		}
		int[] res = new int[arr.length];
		// 整个数组不包含0
        if (count == 0) {
			for (int i = 0; i < arr.length; i++) {
				res[i] = all / arr[i];
			}
		}
        // 只包含一个0
		if (count == 1) {
			for (int i = 0; i < arr.length; i++) {
				if (arr[i] == 0) {
					res[i] = all;
				}
			}
		}
        // 如果含有1个以上的0则结果全部都是0
		return res;
	}
}
```



## 23 数组的partition调整

给定一个有序数组arr，调整arr使得这个数组的左半部分没有重复元素且升序，而不用保证右部分是否有序。

```java
public class Code_23_LeftUnique {

	public void leftUnique(int[] arr) {
		if (arr == null || arr.length == 0) {
			return;
		}
		int u = 0; // 0...u都是无重复元素且升序
		int i = 1; // 整个区域
		while (i != arr.length) {
			if (arr[i++] != arr[u]) {
				swap(arr, ++u, i - 1);
			}
		}
	}

	public void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}
}
```

**补充题目**

1. 给定一个数组arr，其中只可能含有0、1、2三个值，请实现arr的排序。
2. 有一个数组，其中只有红球、蓝球和黄球，请实现红球全放在数组的左边，蓝球放在中间，黄球放在右边。
3. 有一个数组，再给定一个值k，请实现比k小的数都放在数组的左边，等于k的数都放在中间，大于k的都放在数组的右边。

```java
public class Code_23_LeftUnique {

    // 快速排序
	public void sort(int[] arr) {
		if (arr == null || arr.length < 2) {
			return;
		}
		int left = -1;
		int index = 0;
		int right = arr.length;
		while (index < right) {
			if (arr[index] == 0) {
				swap(arr, ++left, index++);
			} else if (arr[index] == 2) {
				swap(arr, index, --right);
			} else {
				index++;
			}
		}
	}
}
```



## 24 求最短通路值

用一个整型矩阵matrix表示一个网络，1代表有路，0代表无路，每一个位置只要不越界，都有上下左右4个方向，求从最左上角到最右下角的最短通路值。

```java
import java.util.LinkedList;
import java.util.Queue;

public class Code_24_MinPathValue {

    // 宽度优先遍历
	public int minPathValue(int[][] m) {
		if (m == null || m.length == 0 || m[0].length == 0 || m[0][0] != 1 || m[m.length - 1][m[0].length - 1] != 1) {
			return 0;
		}
		int res = 0;
		int[][] map = new int[m.length][m[0].length]; // 从(0,0)走到(i,j)的最短路径值
		map[0][0] = 1;
		Queue<Integer> rQ = new LinkedList<Integer>(); // 行队列
		Queue<Integer> cQ = new LinkedList<Integer>(); // 列队列
		rQ.add(0);
		cQ.add(0);
		int r = 0;
		int c = 0;
		while (!rQ.isEmpty()) {
			r = rQ.poll();
			c = cQ.poll();
			if (r == m.length - 1 && c == m[0].length - 1) {
				return map[r][c];
			}
			walkTo(map[r][c], r - 1, c, m, map, rQ, cQ); // up
			walkTo(map[r][c], r + 1, c, m, map, rQ, cQ); // down
			walkTo(map[r][c], r, c - 1, m, map, rQ, cQ); // left
			walkTo(map[r][c], r, c + 1, m, map, rQ, cQ); // right
		}
		return res;
	}

	// 向不同的方向走
	public void walkTo(int pre, int toR, int toC, int[][] m, int[][] map, Queue<Integer> rQ, Queue<Integer> cQ) {
		if (toR < 0 || toR == m.length || toC < 0 || toC == m[0].length || m[toR][toC] != 1 || map[toR][toC] != 0) {
			return;
		}
		map[toR][toC] = pre + 1;
		rQ.add(toR);
		cQ.add(toC);
	}
}
```



## 25 数组中未出现的最小正整数

给定一个无序整型数组arr，找到数组中未出现的最小正整数。

```java
public class Code_25_MissNum {

	public int missNum(int[] arr) {
		int l = 0;	// 目前为止已经包含的范围[1.l]
		int r = arr.length;	// 目前为止后续最优可能包含的范围[1,r]
		while (l < r) {
			if (arr[l] == l + 1) {	// 
				l++;
			} else if (arr[l] <= l || arr[l] > r || arr[arr[l] - l] == arr[l]) {
				arr[l] = arr[--r];
			} else {	//[l+1,r]范围上的数
				swap(arr, l, arr[l] - l);
			}
		}
		return l + 1;
	}

	public void swap(int[] arr, int index1, int index2) {
		int tmp = arr[index1];
		arr[index1] = arr[index2];
		arr[index2] = tmp;
	}
}
```



## 26 数组排序之后相邻数的最大差值

给定一个整型数组arr，返回排序后的相邻两数的最大差值。

```java
public class Code_26_MaxGap {

    // 桶排序应用
	public int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
        // 找到数组的最大值和最小值
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
        // 最大=最小则全部相等差值为0
		if (min == max) {
			return 0;
		}
		boolean[] hasNum = new boolean[len + 1];	//每个桶是否有数
		int[] maxs = new int[len + 1];	//每个桶的最大值
		int[] mins = new int[len + 1];	//每个桶的最小值
        int bid = 0;	//桶ID
        // 遍历记录每个桶的最值和是否有数
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max); // 算出桶号
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = 0;	//前一个有数桶的最大值
		int i = 0;
		while (i <= len) {
			if (hasNum[i++]) { // 找到第一个不为空的桶
				lastMax = maxs[i - 1];
				break;
			}
		}
        //i是接上面继续增加的
		for (; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}

	// 使用long类型是为了防止相乘时溢出
	public int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
}
```

