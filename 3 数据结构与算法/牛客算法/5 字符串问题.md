# 1 判断两个字符串是否互为变形词

**题目**

给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词。请实现函数判断两个字符串是否互为变形词。

```java
public class Code_01_IsDeformation {

	public boolean isDeformation(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() != str2.length()) {
			return false;
		}
		char[] chas1 = str1.toCharArray();
		char[] chas2 = str2.toCharArray();
		int[] map = new int[256]; // 统计字符出现的次数
		for (int i = 0; i < chas1.length; i++) {
			map[chas1[i]]++;
		}
		for (int i = 0; i < chas2.length; i++) {
			if (map[chas2[i]]-- == 0) {
				return false;
			}
		}
		return true;
	}
}
```



# 2 字符串中数字子串的求和

**题目**

给定一个字符串str，求其中全部数字串所代表的数字之和。

**要求**

1. 忽略小数点字符
2. 如果紧贴数字子串的左侧出现奇数个字符“-”则数字为负，偶数个字符“-”则数字为正。

```java
public class Code_02_NumSum {

	public int numSum(String str) {
		if (str == null) {
			return 0;
		}
		char[] charArr = str.toCharArray();
		int res = 0; // 目前的累加和
		int num = 0; // 当前收集到的数字
		boolean posi = true; // num是正还是负
		int cur = 0; // 当前的字符数字
		for (int i = 0; i < charArr.length; i++) {
			cur = charArr[i] - '0';
			if (cur < 0 || cur > 9) { // 遇到非数字时开始累加
				res += num;
				num = 0;
				if (charArr[i] == '-') {
					// 前一个字符是否为-
					if (i - 1 > -1 && charArr[i - 1] == '-') {
						posi = !posi;
					} else {
						posi = false;
					}
				}
			} else {
				num = num * 10 + (posi ? cur : -cur); // 组合数字
			}
		}
		res += num; // 处理最后一个数字
		return res;
	}
}
```



# 3 去掉字符串中连续出现k个0的子串

**题目**

给定一个字符串str和一个整数k，如果str中正好有连续的k个0字符出现时，把k个连续的0字符去除，返回处理后的字符串。

```java
public class Code_03_RemoveKZeros {

	public String removeKZeros(String str, int k) {
		if (str == null || k < 1) {
			return str;
		}
		char[] chas = str.toCharArray();
		int count = 0;
		int start = -1;	//每段连续0字符的开始
		for (int i = 0; i != chas.length; i++) {
			if (chas[i] == '0') {
				count++;
				start = start == -1 ? i : start;
			} else {
				if (count == k) {
					while (count-- != 0) {
						chas[start++] = 0; // 0代表空字符
					}
                }
                count = 0;
                start = -1;
			}
		}
		// 单独处理一次最后的连续0字符
		if (count == k) {
			while (count-- != 0) {
				chas[start++] = 0;
			}
		}
		return String.valueOf(chas);	//转换的时候会去除空字符
	}
}
```



# 4 判断两个字符串是否互为旋转词

**题目**

如果一个字符串str，把字符串str前面任意的部分挪到后面形成的字符串叫做str的旋转词，给定两个字符串a和b，判断a和b是否互为旋转词。

```java
public class Code_04_IsRotation {

	public static boolean isRotation(String a, String b) {
		if (a == null || b == null || a.length() != b.length()) {
			return false;
		}
		String b2 = b + b; // 两个b拼接
		return b2.indexOf(a) != -1;
	}
}
```



# 5 将整数字符串转成整数值

**题目**

给定一个字符串str，如果str符合日常书写的整数形式，并且属于32位整数的范围，返回str所代表的整数值，否则返回0。

```java
public class Code_05_Convert {

	public int convert(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		if (!isValid(chas)) {
			return 0;
		}
		boolean posi = chas[0] == '-' ? false : true; // 正负标志
		int minq = Integer.MIN_VALUE / 10;
		int minr = Integer.MIN_VALUE % 10;
		int res = 0; // 结果
		int cur = 0;
		for (int i = posi ? 0 : 1; i < chas.length; i++) {
			cur = '0' - chas[i]; // 负值
			if ((res < minq) || (res == minq && cur < minr)) {
				return 0; // 溢出返回0
			}
			res = res * 10 + cur;
		}
		// res是最小负值
		if (posi && res == Integer.MIN_VALUE) {
			return 0;
		}
		return posi ? -res : res;
	}

	// 判断字符串代表的整数是否符合书写习惯
	public boolean isValid(char[] chas) {
		if (chas[0] != '-' && (chas[0] < '0' || chas[0] > '9')) {
			return false;
		}
		if (chas[0] == '-' && (chas.length == 1 || chas[1] == '0')) {
			return false;
		}
		if (chas[0] == '0' && chas.length > 1) {
			return false;
		}
		for (int i = 1; i < chas.length; i++) {
			if (chas[i] < '0' || chas[0] > '9') {
				return false;
			}
		}
		return true;
	}
}
```



# 6 替换字符串中连续出现的指定字符串

**题目**

给定三个字符串str、from和to，把str中所有from的子串全部替换成to字符串，对连续出现from的部分要求只替换成一个to字符串，返回最终的结果字符串。

```java
public class Code_06_Replace {

	public String replace(String str, String from, String to) {
		if (str == null || from == null || str.equals("") || from.equals("")) {
			return str;
		}
		char[] chas = str.toCharArray();
		char[] chaf = from.toCharArray();
		int match = 0;// from中的索引
		// 第一次遍历把from子串替换成空字符
		for (int i = 0; i < chas.length; i++) {
			if (chas[i] == chaf[match++]) {
				if (match == chaf.length) {
					clear(chas, i, chaf.length);
					match = 0;
				}
			} else {
				match = 0;
			}
		}
		String res = "";
		String cur = "";
		// 第二次遍历替换成to
		for (int i = 0; i < chas.length; i++) {
			if (chas[i] != 0) {
				cur = cur + String.valueOf(chas[i]);
			}
			if (chas[i] == 0 && (i == 0 || chas[i - 1] != 0)) {
				res = res + cur + to;
				cur = "";
			}
		}
		// 最后一个字符
		if (!cur.equals("")) {
			res = res + cur;
		}
		return res;

	}

	// 填充空字符
	public void clear(char[] chas, int end, int len) {
		while (len-- != 0) {
			chas[end--] = 0;	//0代表空字符
		}
	}
}
```



# 7 字符串的统计字符串

**题目**

给定一个字符串str，返回str的统计字符串。例如，“aaabbadddffc”的统计字符串为“a_3_b_2_a_1_d_3_f_2_c_1”。

**补充题目**

给定一个字符串的统计字符串cstr，再给定一个整数index，返回cstr所代表的原始字符串上的第index个字符。例如“a_1_b_100”所代表的原始字符串上第0个字符是'a'，第50个字符是’b‘。

```java
public class Code_07_GetCountStr {

	public String getCountString(String str) {
		if (str == null || str.equals("")) {
			return "";
		}
		char[] chs = str.toCharArray();
		String res = String.valueOf(chs[0]);
		int num = 1;
		for (int i = 1; i < chs.length; i++) {
			if (chs[i] != chs[i - 1]) {
				res = concat(res, String.valueOf(num), String.valueOf(chs[i]));
				num = 1;
			} else {
				num++;
			}
		}
		return concat(res, String.valueOf(num), "");	//最后一个数量
	}

	// s2代表上一个字符的数量，s3代表下一个字符
	public String concat(String s1, String s2, String s3) {
		return s1 + "_" + s2 + (s3.equals("") ? s3 : "_" + s3);
	}
}
```

```java
public class Code_07_GetCountStr {

	public char getCharAt(String cstr, int index) {
		if (cstr == null || cstr.equals("")) {
			return 0;
		}
		char[] chs = cstr.toCharArray();
		boolean stage = true;
		char cur = 0;
		int num = 0; // 数量
		int sum = 0; //
		for (int i = 0; i != chs.length; i++) {
			if (chs[i] == '_') {
				stage = !stage; // 转换状态
			} else if (stage) {
				// stage为true表示目前处在遇到字符的阶段
				sum += num;
				if (sum > index) {
					return cur;
				}
				num = 0;
				cur = chs[i];
			} else {
				// stage为false表示目前处在遇到连续字符统计的阶段
				num = num * 10 + chs[i] - '0';
			}
		}
		return sum + num > index ? cur : 0;	//最后一个字符的还未统计
	}
}
```



# 8 判断字符数组中是否所有的字符都只出现过一次

**题目**

给定一个字符类型的数组chas[]，判断chas中是否所有的字符都只出现过一次。

```java
public class Code_08_IsUnique {

	public boolean isUnique(char[] chas) {
		if (chas == null) {
			return true;
		}
		// 记录是否出现过
		boolean[] map = new boolean[256];
		for (int i = 0; i < chas.length; i++) {
			if (map[chas[i]]) {
				return false;
			}
			map[chas[i]] = true;
		}
		return true; 
	}
}
```

```java
public class Code_08_IsUnique {

	// 时间o(NlogN)；空间o(1)
	public boolean isUnique_2(char[] chas) {
		if (chas == null) {
			return true;
		}
		heapSort(chas);
		for (int i = 1; i < chas.length; i++) {
			if (chas[i] == chas[i - 1]) {
				return false;
			}
		}
		return true;
	}

	// 堆排序(大根堆)
	public void heapSort(char[] chas) {
		for (int i = 0; i < chas.length; i++) {
			heapInsert(chas, i);
		}
		for (int i = chas.length - 1; i > 0; i--) {
			swap(chas, 0, i); // 将最大值移动最后
			heapify(chas, 0, i); // 调整剩余部分使其有序
		}
	}

	// 向堆中插入新值
	public void heapInsert(char[] chas, int i) {
		int parent = 0;// 父节点
		while (i != 0) {
			parent = (i - 1) / 2;
			if (chas[parent] < chas[i]) {
				swap(chas, parent, i);
				i = parent;
			} else {
				break;
			}
		}
	}

	// 调整堆结构使其重新有序
	public void heapify(char[] chas, int i, int size) {
		int left = i * 2 + 1;
		int right = i * 2 + 2;
		int largest = i;
		while (left < size) {
			if (chas[left] > chas[i]) {
				largest = left;
			}
			if (right < size && chas[right] > chas[largest]) {
				largest = right;
			}
			if (largest != i) {
				swap(chas, largest, i);
			} else {
				break;
			}
			i = largest;
			left = i * 2 + 1;
			right = i * 2 + 2;
		}
	}

	public void swap(char[] chas, int index1, int index2) {
		char tmp = chas[index1];
		chas[index1] = chas[index2];
		chas[index2] = tmp;
	}
}
```



# 9 在有序但含有空的数组中查找字符串

**题目**

给定一个字符串数组strs[]，其中有些位置为null，但在不是null的位置上，其字符串是按照字典序排序的，再给定一个字符串str，请返回str在strs中出现的最左位置。

```java
public class Code_09_GetIndex {

	public int getIndex(String[] strs, String str) {
		if (strs == null || str == null || strs.length == 0) {
			return -1;
		}
		int res = -1;
		int left = 0;
		int right = strs.length - 1;
		int mid = 0;
		int i = 0;
        // 二分查找
		while (left < right) {
			mid = (left + right) / 2;
			if (strs[mid] != null && strs[mid].equals(str)) {	//中间==str
				res = mid;
				right = mid - 1; // 向左寻找第一个
			} else if (strs[mid] != null) {	//中间!=str
				if (strs[mid].compareTo(str) > 0) {
					right = mid - 1;
				} else {
					left = mid + 1;
				}
			} else {	//中间==null
				i = mid;
				while (strs[i] == null && --i >= left)
					;
				if (i < left || strs[i].compareTo(str) < 0) {
					left = mid + 1;
				} else {
					res = strs[i].equals(str) ? i : res;
					right = i - 1;
				}
			}
		}
		return res;
	}
}
```



# 10 字符串的调整与替换

**题目**

给定一个字符串类型的数组chas[]，chas右半区全是空字符，左半区不含有空字符。现在想将左半区中所有的空格字符替换成“%20”，假设chas的右半区足够大，可以满足替换需要的空间，请完成替换函数。

```java
public class Code_10_ReplaceNull {

	public void replace(char[] chas) {
		if (chas == null || chas.length == 0) {
			return;
		}
		int num = 0; // 空格字符数量
		int len = 0; // 字符长度
		for (len = 0; len < chas.length && chas[len] != 0; len++) {	//0代表空字符
			if (chas[len] == ' ') {
				num++;
			}
		}
		int j = len + num * 2 - 1; // 替换后长度
		// 从后往前复制
		for (int i = len - 1; i > -1; i--) {
			if (chas[i] != ' ') {
				chas[j--] = chas[i];
			} else {
				chas[j--] = '0';
				chas[j--] = '2';
				chas[j--] = '%';
			}
		}
	}
}
```

**补充问题**

给定一个字符类型的数组chas[]，其中只含有数字字符和“*”字符，请把所有 *字符挪到chas的左边，数字字符挪到chas的右边，请实现调整函数。

```java
public class Code_10_ReplaceNull {

	public void modify(char[] chas) {
		if (chas == null || chas.length == 0) {
			return;
		}
		int j = chas.length - 1;
		// 先复制数字字符
		for (int i = chas.length - 1; i > -1; i--) {
			if (chas[i] != '*') {
				chas[j--] = chas[i];
			}
		}
		// 最后用*填充
		for (; j > -1; j--) {
			chas[j--] = '*';
		}
	}
}
```



# 11 翻转字符串

**题目**

给定一个字符类型的数组chas，请在单词间做逆序调整，只要做到单词顺序逆序即可。

```java
public class Code_11_RotateWord {

	public void rotateWord(char[] chas) {
		if (chas == null || chas.length == 0) {
			return;
		}
		reverse(chas, 0, chas.length - 1);	//先整体翻转
		int l = -1;
		int r = -1; // 一个单词的首尾
		for (int i = 0; i < chas.length; i++) {
			if (chas[i] != ' ') {
				l = i == 0 || chas[i - 1] == ' ' ? i : l;
				r = i == chas.length - 1 || chas[i + 1] == ' ' ? i : r;
			}
			if (l != -1 && r != -1) {
				reverse(chas, l, r);	//翻转单词
				l = -1;
				r = -1;
			}
		}
	}

	// 翻转部分字符
	public void reverse(char[] chas, int start, int end) {
		char tmp = 0;
		while (start < end) {
			tmp = chas[start];
			chas[start] = chas[end];
			chas[end] = tmp;
			start++;
			end--;
		}
	}
}
```

**补充题目**

给定一个字符类型的数组chas和一个整数size，请把大小为size的左半区整体移动右半区，右半区整体移到左半区。

```java
public void rotate(char[] chas, int size) {
    if (chas == null || size <= 0 || size >= chas.length) {
        return;
    }
    // 三次翻转
    reverse(chas, 0, chas.length - 1);
    reverse(chas, 0, size - 1);
    reverse(chas, size, chas.length - 1);
}
```



# 12 数组中两个字符串的最小距离

**题目**

给定一个字符串数组strs，再给定两个字符串str1和str2，返回在strs中str1和str2的最小距离，如果str1或str2为null，或不在strs中，返回-1。

```java
public class Code_12_MinDistance {

	public int minDistance(String[] strs, String str1, String str2) {
		if (str1 == null || str2 == null) {
			return -1;
		}
		if (str1.equals(str2)) {
			return 0;
		}
		int last1 = -1; // str1最新位置
		int last2 = -1; // str2最新位置
		int min = Integer.MAX_VALUE;
		for (int i = 0; i < strs.length; i++) {
			if (strs[i].equals(str1)) {
				min = Math.min(min, last2 == -1 ? min : i - last2);
				last1 = i;
			}
			if (strs[i].equals(str2)) {
				min = Math.min(min, last1 == -1 ? min : i - last1);
				last2 = i;
			}
		}
		return min == Integer.MAX_VALUE ? -1 : min;
	}
}
```

# 13 添加最少字符使字符串整体都是回文字符串

**题目**

给定一个字符串str，如果可以在str的任意位置添加字符，请返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果。

```java
public class Code_13_GetPalindrome {

	public int[][] getDp(char[] str) {
		// dp[i][j]代表str[i...j]最少添加几个字符变成回文
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			// 单独处理和前一个的关系
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) { // 两端相等
					dp[i][j] = dp[i + 1][j - 1];
				} else { // 两端不等分两种情况
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		return dp;
	}

	public String getPalindrome(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = getDp(chas);
		char[] res = new char[chas.length + dp[0][chas.length - 1]]; // 结果字符数组
		int i = 0;
		int j = chas.length - 1; // 原始字符索引
		int resl = 0;
		int resr = chas.length - 1; // 结果字符索引
		while (i < j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) { // 左侧插入chas[j]
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else { // 右侧插入chas[i]
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}
}
```

**进阶问题**

给定一个字符串str，再给定str的最长回文子序列字符串strlps，请返回在添加字符最少的情况下，让str整体都是回文字符串的一种结果。

```java
public class Code_13_GetPalindrome {

	public String getPalindrome_2(String str, String strlps) {
		if (str == null || str.equals("")) {
			return "";
		}
		char[] chas = str.toCharArray();	//N
		char[] lps = strlps.toCharArray();	//M
		char[] res = new char[2 * chas.length - lps.length];	//2xN-M
		int chasl = 0;
		int chasr = chas.length - 1; // 原始字符串索引
		int lpsl = 0;
		int lpsr = lps.length - 1; // 回文子序列索引
		int resl = 0;
		int resr = res.length - 1; // 结果字符串索引
		int tmpl = 0;
		int tmpr = 0;
		// 根据回文子序列去剥洋葱
		while (lpsl < lpsr) {
			tmpl = chasl;
			tmpr = chasr;
			while (chas[chasl] != lps[lpsl]) {
				chasl++; // 找到原始字符串中回文子序列的第一个字符
			}
			while (chas[chasr] != lps[lpsr]) {
				chasr--; // 找到原始字符串中回文子序列的第一个字符
			}
			set(res, resl, resr, chas, tmpl, chasl, chasr, tmpr);
			resl += chasl - tmpl + tmpr - chasr;
			resr += chasl - tmpl + tmpr - chasr; // 加上填充部分的长度
			res[resl++] = chas[chasl++];
			res[resr--] = chas[chasr--]; // 添加上原本存在的回文字符
			lpsl++;
			lpsr--;
		}
		return String.valueOf(res);
	}

	// 把chas中ls~le和rs~re两端区间设置为回文
	public void set(char[] res, int resl, int resr, char[] chas, int ls, int le, int rs, int re) {
		// 先写左侧字符
		for (int i = ls; i < le; i++) {
			res[resl++] = chas[i];
			res[resr--] = chas[i];
		}
		// 再写右侧字符
		for (int i = re; i > rs; i--) {
			res[resl++] = chas[i];
			res[resr--] = chas[i];
		}
	}
}
```



# 14 括号字符串的有效性和最长有效长度

**题目**

给定一个字符串str，判断是不是整体有效的括号字符串。

```java
public class Code_14_IsValid {

	public boolean isValid(String str) {
		if (str == null || str.equals("")) {
			return false;
		}
		char[] chas = str.toCharArray();
		int status = 0;
		for (int i = 0; i < chas.length; i++) {
			if (chas[i] != ')' && chas[i] != '(') {
				return false;
			}
			if (chas[i] == ')' && --status < 0) {
				return false;// )比（多则返回false
			}
			if (chas[i] == '(') {
				status++;
			}
		}
		return status == 0; // 两种括号数量一样则为true
	}
}
```

**补充问题**

给定一个括号字符串str，返回最长的有效括号子串。

```java
public class Code_14_IsValid {

	public int maxLength(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		// dp[i]表示str[0...i]必须以字符str[i]为结尾的最长有效子串
		int[] dp = new int[chas.length];
		int pre = 0;
		int res = 0;
		for (int i = 1; i < chas.length; i++) {
			if (chas[i] == ')') {
				pre = i - dp[i - 1] - 1; // 看上一个字符结尾的最长子串的前一个字符
				if (pre >= 0 && chas[pre] == '(') { // 能和当前‘）’组合到一起
					dp[i] = dp[i - 1] + 2 + (pre > 0 ? dp[pre - 1] : 0); // 还有可能和前面的组成大子串
				}
			}
			res = Math.max(res, dp[i]); // 记录最大值
		}
		return res;
	}
}
```



# 15 公式字符串求值

**题目**

给定一个字符串str，str表示一个公式，公式里可能有整数、加减乘法符号和左右括号，返回公式的计算结果。

可以认定给定字符串一定正确，如果是负数用括号括起来，但作为公式开头和括号部分的开头不用括号，且不存在溢出情况。

```java
import java.util.Deque;
import java.util.LinkedList;

public class Code_15_FormulaValue {

	public int getValue(String exp) {
		return value(exp.toCharArray(), 0)[0];
	}

	// 递归函数处理没有括号的部分
	// 返回值：第一个表示递归计算结果，第二个表示递归的结束位置
	public int[] value(char[] chars, int i) {
		Deque<String> deque = new LinkedList<String>();
		int pre = 0; // 组合成的数字
		int[] bra = null;
		while (i < chars.length && chars[i] != ')') {
			if (chars[i] >= '0' && chars[i] <= '9') {
				pre = pre * 10 + chars[i++] - '0';
			} else if (chars[i] != '(') { // 遇到操作符
				addNum(deque, pre);
				deque.addLast(String.valueOf(chars[i++])); // 操作符入栈
				pre = 0;
			} else {// 遇到了括号进入递归
				bra = value(chars, i + 1);
				pre = bra[0];
				i = bra[1] + 1;
			}
		}
		addNum(deque, pre); // 加入最后一个数字
		return new int[] { getNum(deque), i };
	}

	// 将数字和加减符号添加入栈
	public void addNum(Deque<String> deque, int num) {
		if (!deque.isEmpty()) {
			int cur = 0;
			String top = deque.pollLast(); // 操作符
			if (top.equals("+") || top.equals("-")) {
				deque.addLast(top); // 加减操作符直接入栈
			} else { // 乘除操作符
				cur = Integer.valueOf(deque.pollLast()); // 弹出前一个数字
				num = top.equals("*") ? (cur * num) : (cur / num);
			}
		}
		deque.addLast(String.valueOf(num)); // 计算结果入栈
	}

	// 从队列中获取数字结算结果(此时只含有操作数和加减操作符)
	public int getNum(Deque<String> deque) {
		int res = 0;
		boolean add = true; // 数字符号
		String cur = null; // 当前的数字或加减符
		int num = 0;
		while (!deque.isEmpty()) {
			cur = deque.pollFirst();
			if (cur.equals("+")) {
				add = true;
			} else if (cur.equals("-")) {
				add = false;
			} else {
				num = Integer.valueOf(cur);
				res += add ? num : -num;
			}
		}
		return res;
	}
}
```



# 16 0左边必有1的二进制字符串数量

**题目**

给定一个整数N，求由0字符与1字符组成的长度为N的所有字符串中，满足0字符的左边必有1字符的字符串数量。

```java
public class Code_16_Binary01Num {

	// 方法一：递归
	public int getNum_1(int n) {
		if (n < 1) {
			return 0;
		}
		return process(1, n);
	}

	// 递归函数
	// p(i)表示0~i-1位置已经确定，且i-1位置为1时i~N-1位置的所有符合条件情况
	public int process(int i, int n) {
		if (i == n - 1) { // 最后一个字符为0或者1均可
			return 2;
		}
		if (i == n) { // 全部遍历完
			return 1;
		}
		// i位置为1则后序p(i+1)
		// i位置为0则i+1必须为1则后序p(i+2)
		return process(i + 1, n) + process(i + 2, n);
	}
}
```



# 17 拼接所有字符串产生字典顺序最小的大写字符串

**题目**

给定一个字符串类型的数组strs，请找到一种拼接顺序，使得将所有的字符串拼接起来组成的大写字符串是所有可能性中字典序最小的，并返回这个大写字符串。

```java
import java.util.Arrays;
import java.util.Comparator;

public class Code_17_LowestString {

	// 自定义比较器
	public class MyComparator implements Comparator<String> {

		public int compare(String a, String b) {
			return (a + b).compareTo(b + a);
		}
	}

	public String lowestString(String[] strs) {
		if (strs == null || strs.length == 0) {
			return "";
		}
		Arrays.sort(strs, new MyComparator());// 根据比较器排序
		String res = "";
		for (int i = 0; i < strs.length; i++) {
			res += strs[i];
		}
		return res;
	}
}
```



# 18 找到字符串的最长无重复字符子串

**题目**

给定一个字符串str，返回str的最长无重复字符子串的长度。

```java
public class Code_18_MaxUnique {

	public int maxUnique(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		int[] map = new int[256]; // 各字符最近出现的位置
		for (int i = 0; i < map.length; i++) {
			map[i] = -1;
		}
		int len = 0; // 最长无重复子串长度的最大值
		int pre = -1; // 必须以str[i-1]结尾时最长无重复字符子串开始位置的前一个位置
		int cur = 0;
		for (int i = 0; i < map.length; i++) {
			pre = Math.max(pre, map[chas[i]]); // 选更靠右的
			cur = i - pre; // 必须以str[i]为结尾的最长子串长度
			len = Math.max(len, cur);
			map[chas[i]] = i; // 更新最新位置
		}
		return len;
	}
}
```



# 19 找到被指的新类型字符

新类型字符的定义如下：

1. 新类型字符是长度为1或者为2的字符串
2. 表现形式可以仅是小写字母，例如，"e"；也可以是大写字母+小写字母，例如，"Ab"；还可以是大写字母+大写字母，例如，"DC"。

现在给定一个字符串str，str一定是若干新类型字符正确组合的结果。比如"eaCCBi"，由新类型字符"e","a","CC"和"Bi"拼成。再给定一个整数k，代表str中的位置。请返回被k位置指中的新类型字符。

```java
public class Code_19_PointNewChar {

	public String pointNewchar(String s, int k) {
		if (s == null || s.equals("") || k < 0 || k >= s.length()) {
			return "";
		}
		char[] chas = s.toCharArray();
		int uNum = 0;
		// 找到k前面连续大写字母的数量
		for (int i = k - 1; i >= 0; i--) {
			if (!Character.isUpperCase((chas[i]))) {
				break;
			}
			uNum++;
		}
		if ((uNum & 1) == 1) { // 奇数个大写字母
			return s.substring(k - 1, k + 1);
		}
		if (Character.isUpperCase(chas[k])) {// 偶数个大写字母且k是大写字母
			return s.substring(k, k + 2);
		}
		return String.valueOf(chas[k]); // 偶数个大写字母且k是小写字母
	}
}
```



# 20 最小包含子串的长度

**题目**

给定字符串str1和str2，求str1的子串中含有str2所有字符的最小子串长度。

```java
public class Code_20_MinLength {

	public int minLength(String str1, String str2) {
		if (str1 == null || str2 == null || str1.length() < str2.length()) {
			return 0;
		}
		char[] chas1 = str1.toCharArray();
		char[] chas2 = str2.toCharArray();
		int[] map = new int[256];
		for (int i = 0; i < chas2.length; i++) {
			map[chas2[i]]++; // map表示各字符str1欠str2的数量
		}
		int left = 0;
		int right = 0;
		int match = chas2.length;
		int minLen = Integer.MAX_VALUE;
		while (right != chas1.length) {
			map[chas1[right]]--; // 出现了该字符
			if (map[chas1[right]] >= 0) {
				match--; // 所欠的字符-1
			}
			if (match == 0) { // 此时子串包含了所有str2字符但不一定是最短的
				while (map[chas1[left]] < 0) {
					map[chas1[left++]]++; // 去掉多包含的字符
				}
				minLen = Math.min(minLen, right - left + 1); // 更新最短长度
				match++;
				map[chas1[left++]]++; // left字符又欠str2了
			}
			right++;
		}
		return minLen == Integer.MAX_VALUE ? 0 : minLen;
	}
}
```



# 21 回文最少分割数

**题目**

给定一个字符串str，返回把str全部切成回文子串的最小分割数。

```java
public class Code_21_MinCut {

	public int minCut(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		int len = chas.length;
		int[] dp = new int[len + 1]; // str[i...len-1]切成回文子串的最小切割数
		dp[len] = -1; // 最后一个不可用
		boolean[][] p = new boolean[len][len]; // p[i][j]表示str[i...j]是否回文
		// 从右往左遍历
		for (int i = len - 1; i >= 0; i--) {
			dp[i] = Integer.MAX_VALUE;
			// 枚举i到len-1的位置
            for (int j = i; j < len; j++) {
				if (chas[i] == chas[j] && (j - i < 2 || p[i + 1][j - 1])) {
					p[i][j] = true; // str[i...j]是回文的
					dp[i] = Math.min(dp[i], dp[j + 1] + 1);
				}
			}
		}
		return dp[0];
	}
}
```



# 22 字符串匹配问题

**题目**

给定字符串str，其中绝对不含有字符'.'和'\*'。再给定字符串exp，其中可以含有'.'或'\*'，'\*'字符不能是exp的首字符，并且任意两个'\*'字符不相邻。exp中的'.'代表任何一个字符，exp中的'\*'表示'\*'的前一个字符可以有0个或者多个。请写一个函数，判断str是否能被exp匹配。

```java
public class Code_22_IsMatchStr {

	// 判断字符串的有效性
	public boolean isValid(char[] s, char[] e) {
		for (int i = 0; i < s.length; i++) {
			if (s[i] == '*' || s[i] == '.') {
				return false;
			}
		}
		for (int i = 0; i < e.length; i++) {
			if (e[i] == '*' && (i == 0 || e[i - 1] == '*')) {
				return false;
			}
		}
		return true;
	}

	// 方法一：递归方法
	public boolean isMatch(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		return isValid(s, e) ? process(s, e, 0, 0) : false;
	}

	public boolean process(char[] s, char[] e, int si, int ei) {
		if (ei == e.length) { // 都到结尾表示匹配成功
			return si == s.length;
		}
		if (ei + 1 == e.length || e[ei + 1] != '*') { // ei的下一个字符不是*
			return si != s.length && (e[ei] == s[si] || e[ei] == '.') && process(s, e, si + 1, ei + 1);
		}
		// ei的下一个字符是*
		while (si != s.length && (e[ei] == s[si] || e[ei] == '.')) {
			// 用e[ei]+*去匹配s[si]
			if (process(s, e, si, ei + 2)) {
				return true;
			}
			si++; // 看是否能匹配更多的s[si]表示的字符
		}
		return process(s, e, si, ei + 2);// 继续向前匹配
	}
}
```

```java
public class Code_22_IsMatchStr {

	// 方法二：动态规划
	public boolean isMathcDP(String str, String exp) {
		if (str == null || exp == null) {
			return false;
		}
		char[] s = str.toCharArray();
		char[] e = exp.toCharArray();
		if (!isValid(s, e)) {
			return false;
		}
		// dp数组表示递归函数的参数及返回值
		boolean[][] dp = initDPMap(s, e);
		for (int i = s.length - 1; i > -1; i--) {
			for (int j = e.length - 2; j > -1; j--) {
				if (e[j + 1] != '*') { // 下一个字符不是*
					dp[i][j] = (s[i] == e[j] || e[j] == '.') && dp[i + 1][j + 1];
				} else {
					int si = i;
					while (si != s.length && (s[si] == e[j] || e[j] == '.')) {
						if (dp[si][j + 2]) { // 出现了匹配
							dp[i][j] = true;
							break;
						}
						si++;
					}
					// si已经不能匹配直接使用后面的结果（肯定是false）
					if (dp[i][j] != true) {
						dp[i][j] = dp[si][j + 2];
					}
				}
			}
		}
		return dp[0][0];
	}

	public boolean[][] initDPMap(char[] s, char[] e) {
		int slen = s.length;
		int elen = e.length;
		boolean[][] dp = new boolean[slen + 1][elen + 1];
		dp[slen][elen] = true; // 最后都匹配完了返回true
		// 初始化最后一行（str结束exp还没结束）
		for (int j = elen - 2; j > -1; j = j - 2) {
			if (e[j] != '*' && e[j + 1] == '*') {
				dp[slen][j] = true; // 成对出现的a*可以代表0个字符
			} else {
				break; // 只要出现一个不成对后面的都是false
			}
		}
		// 初始化最后两列
		if (slen > 0 && elen > 0) {
			if (e[elen - 1] == '.' || s[slen - 1] == e[elen - 1]) {
				dp[slen - 1][elen - 1] = true;
			}
		}
		return dp;
	}

}
```



# 23 字典树（前缀树）的实现

**题目**

字典树是处理字符串常见的数据结构。假设组成所有单词的字符仅是a~z，请实现字典树结构，并包含以下四个主要功能：

- void insert(String word)：添加word，可以重复添加。
- void delete(String word)：删除word，如果word添加过多次，仅删除一个。
- boolead search(String word)：查询word是否在字典中。
- int prefixNumber(String pre)：返回以字符串pre为前缀的单词数量。

```java
public class Code_23_Trie {

	public class TrieNode {
		public int path; // 经过的路径
		public int end; // 以本节点结尾的路径
		public TrieNode[] map; // 向下的路径指针

		public TrieNode() {
			path = 0;
			end = 0;
			map = new TrieNode[26]; // 26个字母
		}
	}

	public class Trie {
		private TrieNode root; // 根节点

		public Trie() {
			root = new TrieNode();
		}

		public void insert(String word) {
			if (word == null) {
				return;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a'; // 在向下路径中的索引
				if (node.map[index] == null) { // 还没有初始化
					node.map[index] = new TrieNode();
				}
				node = node.map[index]; // 继续线下
				node.path++;// 经过路径+1
			}
			node.end++; // 结尾路径+1
		}

		public void delete(String word) {
			if (search(word)) {
				char[] chs = word.toCharArray();
				TrieNode node = root;
				int index = 0;
				for (int i = 0; i < chs.length; i++) {
					index = chs[i] - 'a'; // 在向下路径中的索引
					if (node.map[index].path-- == 1) { // 删完最后一个
						node.map[index] = null;
						return;
					}
					node = node.map[index]; // 继续线下
				}
				node.end--;
			}
		}

		public boolean search(String word) {
			if (word == null) {
				return false;
			}
			char[] chs = word.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a'; // 在向下路径中的索引
				if (node.map[index] == null) { // 还没有初始化
					return false;
				}
				node = node.map[index]; // 继续线下
			}
			return node.end != 0; // 结尾处判断
		}

		// 判断是否包含pre前缀
		public int prefixNumber(String pre) {
			if (pre == null) {
				return 0;
			}
			char[] chs = pre.toCharArray();
			TrieNode node = root;
			int index = 0;
			for (int i = 0; i < chs.length; i++) {
				index = chs[i] - 'a'; // 在向下路径中的索引
				if (node.map[index] == null) { // 出现了不存在路径
					return 0;
				}
				node = node.map[index]; // 继续线下
			}
			return node.path;
		}
	}
}
```

