# 1 斐波那契系列问题的递归和非递归

**题目**

给定整数N，返回斐波那契额数列的第N项，要求时间复杂度o(logN)的解法。

```java
public class Code_01_Fibonacci {

	/**
	 * 问题一：斐波那契数列问题
	 */

	// 解法一：暴力递归o(2^N)
	public int f1(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		return f1(n - 1) + f1(n - 2);
	}

	// 解法二:顺序计算o(N)
	public int f2(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		int res = 1;
		int pre = 1;
		int tmp = 0;
		for (int i = 3; i <= n; i++) {
			tmp = res;	//暂存i-1
			res = res + pre;	//i位置的值=(i-1)+(i-2)
			pre = tmp;	//取出i-1变为了i-2
		}
		return res;
	}

	// 解法三：递推公式矩阵的幂o(logN)
	public int f3(int n) {
		if (n < 1) {
			return 0;
		}
		if (n == 1 || n == 2) {
			return 1;
		}
		int[][] base = { { 1, 1 }, { 1, 0 } }; // 基础矩阵
		int[][] res = matrixPower(base, n - 2);
		return res[0][0] + res[1][0];
	}

	// 矩阵乘法
	public int[][] muliMatrix(int[][] m1, int[][] m2) {
		int[][] res = new int[m1.length][m2[0].length];
		for (int i = 0; i < m2[0].length; i++) {
			for (int j = 0; j < m1.length; j++) {
				for (int k = 0; k < m2.length; k++) {
					res[i][j] += m1[i][k] * m2[k][j];
				}
			}
		}
		return res;
	}

	// 求矩阵N的P次方
	public int[][] matrixPower(int[][] m, int p) {
		int[][] res = new int[m.length][m[0].length];
		// 先把res设为单位矩阵，相当于整数中的1
		for (int i = 0; i < res.length; i++) {
			res[i][i] = 1;
		}
		int[][] tmp = m;
		for (; p != 0; p >>= 1) {
			if ((p & 1) != 0) {
				res = muliMatrix(res, tmp);
			}
			tmp = muliMatrix(tmp, tmp);
		}
		return res;
	}
	
}
```

**引申题目1**

给定整数N，代表台阶数，一次可以跨2个或者1个台阶，返回有多少种走法。

**引申问题2**

母牛每年只会生1头小母牛，并且不会死亡，第一年农场有1只，第二年开始生小牛，每次母牛3年之后成熟可以生小牛，给定整数N，求出N年后牛的数量。



# 2 矩阵的最小路径和

**题目**

给定一个矩阵m，从左上角开始每次只能向右走或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径和中最小的路径和。

```java
public class Code_02_MinPathSum {

	// 解法一：动态规划
	// 时间复杂度o(MxN)，空间复杂度o(MxN)
	public int minPathSum_1(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 0;
		}
		int row = m.length;		//行
		int col = m[0].length;	//列
		int[][] dp = new int[row][col];// 从左上角到各位置的最小路径和
		dp[0][0] = m[0][0];
		// 可以直接确定的情况（第一行和第一列）
		for (int i = 1; i < row; i++) {
			dp[i][0] = dp[i - 1][0] + m[i][0];
		}
		for (int j = 1; j < col; j++) {
			dp[0][j] = dp[0][j - 1] + m[0][j];
		}
		// 一般情况
		for (int i = 1; i < row; i++) {
			for (int j = 1; j < col; j++) {
				dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j];
			}
		}
		return dp[row - 1][col - 1];
	}

	// 解法一：动态规划空间压缩
	// 时间复杂度o(MxN)，空间复杂度o(min{M,N})
	public int minPathSum_2(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 0;
		}
		int more = Math.max(m.length, m[0].length);// 行列数较大值
		int less = Math.min(m.length, m[0].length);// 行列数较小值
		boolean rowmore = more == m.length; // 行数是否大于等于列数
		int[] arr = new int[less];
		arr[0] = m[0][0];
		// 初始化第一行或第一列
		for (int i = 1; i < less; i++) {
			arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]);
		}
		for (int i = 1; i < more; i++) {
			arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]);
			for (int j = 1; j < less; j++) {
				arr[j] = Math.min(arr[j - 1], arr[j]) + (rowmore ? m[i][j] : m[j][i]);
			}
		}
		return arr[less - 1];
	}
}
```



# 3 换钱的最少货币数

**题目**

给定数组arr，arr中所有的值都为正数且不重复。每个值代表**一种**面值的货币，每种面值的货币可以有任意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数。

```java
public class Code_03_MinCoins {

	public int minCoins_1(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return -1;
		}
		int n = arr.length;
		int max = Integer.MAX_VALUE;
		int[][] dp = new int[n][aim + 1]; // 目标是j且只能用arr[0...i]
		// 初始化第一行（只能使用arr[0]）
		for (int j = 1; j <= aim; j++) {
			dp[0][j] = max;
			if (j - arr[0] >= 0 && dp[0][j - arr[0]] != max) {
				dp[0][j] = dp[0][j - arr[0]] + 1;
			}
		}
		int left = 0;
		// 填充剩余部分
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= aim; j++) {
				left = max;
				if (j - arr[i] >= 0 && dp[i][j - arr[i]] != max) {	//使用arr[i]这张
					left = dp[i][j - arr[i]] + 1;
				}
				dp[i][j] = Math.min(left, dp[i - 1][j]);	//不使用arr[i]这张
			}
		}
		return dp[n - 1][aim] != max ? dp[n - 1][aim] : -1;
	}

	// 进行空间压缩
	public int minCoins_2(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return -1;
		}
		int n = arr.length;
		int max = Integer.MAX_VALUE;
		int[] dp = new int[aim + 1]; // 只记录一行
		// 初始化第一行（只能使用arr[0]）
		for (int j = 1; j <= aim; j++) {
			dp[j] = max;
			if (j - arr[0] >= 0 && dp[j - arr[0]] != max) {
				dp[j] = dp[j - arr[0]] + 1;
			}
		}
		int left = 0;
		// 填充剩余部分
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= aim; j++) {
				left = max;
				if (j - arr[i] >= 0 && dp[j - arr[i]] != max) {
					left = dp[j - arr[i]] + 1;
				}
				dp[j] = Math.min(left, dp[j]);
			}
		}
		return dp[aim] != max ? dp[aim] : -1;
	}
}
```

**补充题目**

给定数组arr，arr中所有的值都为正数。每个值代表**一张**钱的面值，每种面值的货币可以有任意张，再给定一个整数aim代表要找的钱数，求组成aim的最少货币数。

```java
public class Code_03_MinCoins {

	public int minCoins_3(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return -1;
		}
		int n = arr.length;
		int max = Integer.MAX_VALUE;
		int[][] dp = new int[n][aim + 1]; // 目标是j且只能用arr[0...i]
		// 初始化第一行（只能使用arr[0]）
		for (int j = 1; j <= aim; j++) {
			dp[0][j] = max;
		}
		if (arr[0] <= aim) {
			dp[0][arr[0]] = 1; // 只有1张所以只有一张情况
		}
		int leftup = 0; // 左上角某个位置的值
		// 填充剩余部分
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= aim; j++) {
				leftup = max;
				if (j - arr[i] >= 0 && dp[i][j - arr[i]] != max) {
                    // 因为只有1张，需要不使用arr[i]达到j-arr[i]
					leftup = dp[i - 1][j - arr[i]] + 1;
				}
				dp[i][j] = Math.min(leftup, dp[i - 1][j]);	//不使用arr[i]
			}
		}
		return dp[n - 1][aim] != max ? dp[n - 1][aim] : -1;
	}

	// 进行空间压缩
	public int minCoins_4(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return -1;
		}
		int n = arr.length;
		int max = Integer.MAX_VALUE;
		int[] dp = new int[aim + 1]; // 只记录一行
		// 初始化第一行（只能使用arr[0]）
		for (int j = 1; j <= aim; j++) {
			dp[j] = max;
		}
		if (arr[0] <= aim) {
			dp[arr[0]] = 1; // 只有1张所以只有一张情况
		}
		int leftup = 0;
		// 填充剩余部分
		for (int i = 1; i < n; i++) {
			for (int j = 1; j <= aim; j++) {
				leftup = max;
				if (j - arr[i] >= 0 && dp[j - arr[i]] != max) {
					leftup = dp[j - arr[i]] + 1;
				}
				dp[j] = Math.min(leftup, dp[j]);
			}
		}
		return dp[aim] != max ? dp[aim] : -1;
	}
}
```



# 4 换钱的方法数

**题目**

给定数组arr，arr中所有的值都为正数且不重复。每个值代表**一种**面值的货币，每种面值的货币可以有任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。

```java
public class Code_04_Coins {

	// 方法一：暴力递归
	public int coins_1(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		return process_1(arr, 0, aim);
	}

	public int process_1(int[] arr, int index, int aim) {
		int res = 0;
		if (index == arr.length) {
			res = aim == 0 ? 1 : 0;
		} else {
           	// arr[index]取不同的张数 
			for (int i = 0; arr[index] * i <= aim; i++) {
				res += process_1(arr, index + 1, aim - arr[index] * i);
			}
		}
		return res;
	}

	// 方法二：记忆化搜索
	public int coins_2(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] map = new int[arr.length + 1][aim + 1];
		return process_2(arr, 0, aim, map);
	}

	public int process_2(int[] arr, int index, int aim, int[][] map) {
		int res = 0;
		if (index == arr.length) {
			res = aim == 0 ? 1 : 0;
		} else {
			int mapValue = 0;
			for (int i = 0; arr[index] * i <= aim; i++) {
				mapValue = map[index + 1][aim - arr[index] * i];
				if (mapValue != 0) { // 存在有效返回值
					res += mapValue == -1 ? 0 : mapValue;
				} else { // 不存在记录则进入递归
					res += process_1(arr, index + 1, aim - arr[index] * i);
				}
			}
		}
		map[index][aim] = res == 0 ? -1 : res; // 记录本次的递归结果
		return res;
	}

	// 方法三：动态规划
	public int coins_3(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] dp = new int[arr.length][aim + 1]; // 使用arr[0..i]的情况下组成钱数j的方法数
		// 初始化第一列：目标钱数为0情况只有1种
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		// 初始化第一行：只使用arr[0]的情况
		for (int j = 1; arr[0] * j <= aim; j++) {
			dp[0][arr[0] * j] = 1;
		}
		int num = 0;
        // 其他位置
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				num = 0;
                // arr[i]取k张
				for (int k = 0; j - arr[i] * k >= 0; k++) {
					num += dp[i - 1][j - arr[i] * k];
				}
				dp[i][j] = num;
			}
		}
		return dp[arr.length - 1][aim];
	}

	// 方法四：动态规划优化一
	public int coins_4(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[][] dp = new int[arr.length][aim + 1]; // 使用arr[0..i]的情况下组成钱数j的方法数
		// 目标钱数为0情况只有1种
		for (int i = 0; i < arr.length; i++) {
			dp[i][0] = 1;
		}
		// 只使用arr[0]的情况
		for (int j = 1; arr[0] * j <= aim; j++) {
			dp[0][arr[0] * j] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				dp[i][j] = dp[i - 1][j]; // 不适用arr[i]达到j
                // 加速
                dp[i][j] += j - arr[i] > 0 ? dp[i][j - arr[i]] : 0;	//使用arr[i]达到j
			}
		}
		return dp[arr.length - 1][aim];
	}

	// 方法五：动态规划优化二
	public int coins_5(int[] arr, int aim) {
		if (arr == null || arr.length == 0 || aim < 0) {
			return 0;
		}
		int[] dp = new int[aim + 1];
		// 只使用arr[0]的情况
		for (int j = 0; arr[0] * j <= aim; j++) {
			dp[arr[0] * j] = 1;
		}
		for (int i = 1; i < arr.length; i++) {
			for (int j = 1; j <= aim; j++) {
				dp[j] += j - arr[i] > 0 ? dp[j - arr[i]] : 0;
			}
		}
		return dp[aim];
	}
}
```



# 5 最长递增子序列

**题目**

给定数组arr，返回arr的最长递增子序列。

```java
public class Code_05_MaxSubList {

	// 方法一：o(N^2)
	public int[] list_1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int[] dp = getdp_1(arr);
		return generateLIS(arr, dp);
	}

	// 计算dp数组
	public int[] getdp_1(int[] arr) {
		int[] dp = new int[arr.length]; // 以arr[i]为结尾的最长递增子序列长度
		for (int i = 0; i < arr.length; i++) {
			dp[i] = 1;
			for (int j = 0; j < i; j++) {
				// 以哪个数结尾的递增子序列更大则作为倒数第二个数
                if (arr[i] > arr[j]) {
					dp[i] = Math.max(dp[i], dp[j] + 1);
				}
			}
		}
		return dp;
	}

	// 根据dp数组产生结果
	public int[] generateLIS(int[] arr, int[] dp) {
		int len = 0;
		int index = 0;
		// 找到dp数组的最大值和对应索引
		for (int i = 0; i < dp.length; i++) {
			if (dp[i] > len) {
				len = dp[i];
				index = i;
			}
		}
		int[] lis = new int[len]; // 存储最长子序列
		lis[--len] = arr[index]; // 存入本字符
		// 从index开始向前遍历找到着len-1个比arr[index]小的数
        for (int i = index; i >= 0; i--) {
			if (arr[i] < arr[index] && dp[i] == dp[index] - 1) {
				lis[--len] = arr[i];
				index = i;
			}
		}
		return lis;
	}

}
```



# 6 汉诺塔问题

**题目**

给定一个整数n，代表汉诺塔游戏中从小到大放置的n个圆盘，假设开始时所有的圆盘都放在左边的柱子上，想按照汉诺塔游戏的要求把所有的圆盘都移到右边的柱子上。实现函数打印最优移动轨迹。

```java
public class Code_06_Hanoi {

	// 经典汉诺塔
	public void hanoi(int n) {
		if (n > 0) {
			func(n, "left", "mid", "right");
		}
	}

	public void func(int n, String from, String mid, String to) {
		if (n == 1) {
			System.out.println("move from " + from + " to " + to);
		} else {
			func(n - 1, from, to, mid);
			func(1, from, mid, to);
			func(n - 1, mid, from, to);
		}
	}
}
```

**进阶**

给定一个整型数组arr其中只含有1、2和3，代表所有圆盘的目前位置，1代表左柱，2代表中柱，3代表右柱。如果arr代表的状态是最优移动轨迹过程中出现的状态，返回是第几个状态，如果不是返回-1。

要求时间复杂度o(N)，空间复杂度o(1)。

```java
public class Code_06_Hanoi {

	// 进阶问题
	public int step_1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return -1;
		}
		return process(arr, arr.length - 1, 1, 2, 3);
	}

    // i代表最大圆盘
	public int process(int[] arr, int i, int from, int mid, int to) {
		if (i == -1) {
			return 0;
		}
		// 最大盘i在mid说明不是最优路径
		if (arr[i] != from && arr[i] != to) {
			return -1;
		}
		if (arr[i] == from) { // 最大盘在from上需要继续考察1~i-1
			return process(arr, i - 1, from, to, mid);
		} else {// 最大盘在to上说明走完了2^i-1步，继续考察1~i-1
			int rest = process(arr, i - 1, mid, from, to);
			if (rest == -1) {
				return -1;
			}
			return (1 << i) + rest;	//（1<<i）== 2^(i-1)
		
	}
}
```



# 7 最长公共子序列问题

**题目**

给定两个字符串str1和str2，返回两个字符串的最长公共子序列。

```java
public class Code_07_LongestSubsequence {

	// 生成dp数组，代表str1[0...i]和str2[0...j]的最长匹配长度
	public int[][] getdp(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		dp[0][0] = str1[0] == str2[0] ? 1 : 0;
		// 初始化第一列
		for (int i = 1; i < str1.length; i++) {
			// 出现一个匹配之后后面都是1
			dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
		}
		// 初始化第一行
		for (int j = 1; j < str2.length; j++) {
			// 出现一个匹配之后后面都是1
			dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
		}
		// 其他普通位置
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				// 来源分别是上、左和左上
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				if (str1[i] == str2[j]) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
				}
			}
		}
		return dp;
	}

	public String lcse(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int[][] dp = getdp(chs1, chs2);
		int m = chs1.length - 1;
		int n = chs2.length - 2;
		char[] res = new char[dp[m][n]];// 右下角代表最长匹配长度
		int index = res.length - 1;
		while (index >= 0) {
			if (n > 0 && dp[m][n] == dp[m][n - 1]) { // 向左移动
				n--;
			} else if (m > 0 && dp[m][n] == dp[m - 1][n]) {// 向上移动
				m--;
			} else { // 向左上移动,出现了匹配字符
				res[index--] = chs1[m];
				m--;
				n--;
			}
		}
		return String.valueOf(res);
	}
}
```



# 8 最长公共子串问题

**题目**

给定两个字符串str1和str2，返回两个字符串的最长公共子串。

```java
public class Code_08_LongestSubstring {

	public int[][] getdp(char[] str1, char[] str2) {
		// dp[i][j]表示必须以str1[i]和str2[j]为结尾的最大匹配长度
		int[][] dp = new int[str1.length][str2.length];
		// 初始化第一列
		for (int i = 0; i < str1.length; i++) {
			if (str1[i] == str2[0]) {
				dp[i][0] = 1;
			}
		}
		// 初始化第一行
		for (int j = 1; j < str2.length; j++) {
			if (str2[j] == str1[0]) {
				dp[0][j] = 1;
			}
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				if (str1[i] == str2[j]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
			}
		}
		return dp;
	}

	public String lcst(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int[][] dp = getdp(chs1, chs2);
		int end = 0;
		int max = 0;
		for (int i = 0; i < chs1.length; i++) {
			for (int j = 0; j < chs2.length; j++) {
				if (dp[i][j] > max) { // 更新最长子串
					end = i;	//表示匹配子串的结尾
					max = dp[i][j];
				}
			}
		}
		return str1.substring(end - max + 1, end + 1);
	}
}
```



# 9 最小编辑代价

**题目**

给定两个字符串str1和str2，在给定3个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。

```java
public class Code_09_MinCost {

	public int minCost(String str1, String str2, int ic, int dc, int rc) {
		if (str1 == null || str2 == null) {
			return 0;
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int row = chs1.length + 1;
		int col = chs2.length + 1;
		// dp[i][j]表示把str1[0..i-1]编辑成str2[0..j-1]的代价
		int[][] dp = new int[row][col]; // dp[0][0]表示空字符""
		// 初始化第一列(str1编辑成"")
		for (int i = 1; i < dp.length; i++) {
			dp[i][0] = dc * i;
		}
		// 初始化第一行(""编辑成str2)
		for (int j = 1; j < dp.length; j++) {
			dp[0][j] = ic * j;
		}
		for (int i = 1; i < row; i++) {
			for (int j = 1; j < col; j++) {
				if (chs1[i - 1] == chs2[j - 1]) { // 相等不需要代价
					dp[i][j] = dp[i - 1][j - 1];
				} else { // 不相等需要替换代价
					dp[i][j] = dp[i - 1][j - 1] + rc;
				}
				dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic); // 插入str2的一个元素
				dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc); // 删掉str1的一个元素
			}
		}
		return dp[row - 1][col - 1];
	}
}
```



# 10 字符串的交错组成

**题目**

给定三个字符串str1、str2和aim，如果aim包含且仅包含来自str1和str2的所有字符，而且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持原来在str2中的顺序，那么成aim是str1和str2的交错组成，实现函数判断aim是否是str1和str2的交错组成。

```java
public class Code_10_IsCross {

	public boolean isCross(String str1, String str2, String aim) {
		if (str1 == null || str2 == null || aim == null) {
			return false;
		}
		char[] ch1 = str1.toCharArray();
		char[] ch2 = str2.toCharArray();
		char[] chaim = aim.toCharArray();
		if (chaim.length != ch1.length + ch2.length) {
			return false;
		}
        //dp[i][j]代表aim[0...i+j-1]能否被str1[0...i-1]和str2[0...j-1]交错组成
		boolean[][] dp = new boolean[ch1.length + 1][ch2.length + 1];
		dp[0][0] = true;
		// 初始化第一列，只有str1构成aim
		for (int i = 1; i < ch1.length; i++) {
			if (ch1[i - 1] != chaim[i - 1]) {
				break;
			}
			dp[i][0] = true;// 相等才能构成
		}
		// 初始化第一行，只有str2构成aim
		for (int j = 1; j < ch2.length; j++) {
			if (ch2[j - 1] != chaim[j - 1]) {
				break;
			}
			dp[0][j] = true;
		}
		for (int i = 1; i < ch1.length; i++) {
			for (int j = 1; j < ch2.length; j++) {
				// str1和str2有一个能满足等于aim当前值就为true
				if ((ch1[i - 1] == chaim[i + j - 1] && dp[i - 1][j])
						|| (ch2[j - 1] == chaim[i + j - 1] && dp[i][j - 1])) {
					dp[i][j] = true;
				}
			}
		}
		return dp[ch1.length][ch2.length];
	}
}
```



# 11 龙与地下城游戏

**题目**

给定一个二维数组map，含义是一张地图，例如，如下矩阵：

```
-2	-3	3
-5	-10	1
0	30	-5
```

游戏的规则如下：

1. 骑士从左上角出发，每次只能向右或向下走，最后到达右下角见到公主。
2. 地图中的值代表事件，负数表示怪物要扣的血量，非负数代表血瓶回血。
3. 骑士行走过程中，走到任何一个位置时，血量都不能少于1。

为了保证骑士能够见到公主，初始血量至少是多少？根据map返回初始血量。

```java
public class Code_11_MinHP {

	public int minHP(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 1;
		}
		int row = m.length;		//行
		int col = m[0].length;	//列
		int[][] dp = new int[row--][col--];
		// dp[i][j]表示要走上这个位置能够到达右小角应该有的血量
		dp[row][col] = m[row][col] > 0 ? 1 : -m[row][col] + 1;
		// 最后一行（只能向右）
		for (int j = col - 1; j >= 0; j--) {
			dp[row][j] = Math.max(dp[row][j + 1] - m[row][j], 1);
		}
		int right = 0;
		int down = 0;
		// 从倒数第二行向上填充
		for (int i = row - 1; i >= 0; i--) {
			// 每行的最后一个
			dp[i][col] = Math.max(dp[i + 1][col] - m[i][col], 1);
			for (int j = col - 1; j >= 0; j--) {
				right = Math.max(dp[i][j + 1] - m[i][j], 1); // 向右走需要的血量
				down = Math.max(dp[i + 1][j] - m[i][j], 1); // 向下走需要的血量
				dp[i][j] = Math.min(right, down); // 选择最小值
			}
		}
		return dp[0][0];
	}
}
```



# 12 数字字符串转换为字母组合的种数

**题目**

给定一个字符串str，str全部由数字字符组成，如果str中某一个或某相邻两个字符组成的子串值在1~26之间，则这个子串可以转换成一个字母。规定“1”转换成为“A”，"2"转换成“B”，"3"转换成“C”..."26"转换成“Z”，写一个函数，求str有多少种不同的转换结果，并返回种数。

```java
public class Code_12_NumToLetter {

	public int num(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chs = str.toCharArray();
		return process(chs, 0);
	}

	// p(i)的含义是str[0...i-1]已经转换完毕，而str[i...N-1]还没转换时，最终的转换种数
	public int process(char[] chs, int i) {
		// 最后一个字符只有1种情况
		if (i == chs.length) {
			return 1;
		}
		if (chs[i] == '0') { // 字符为0表示后序不能有合法的转换
			return 0;
		}
		int res = process(chs, i + 1);
		// 可以和后面字符组合
		if (i + 1 < chs.length && (chs[i] - '0') * 10 + chs[i + 1] - '0' < 27) {
			res += process(chs, i + 2);
		}
		return res;
	}
}
```



# 13 表达式得到期望结果的组成种数

**题目**

给定一个只由0（假）、1（真）、&（逻辑与）、|（逻辑或）和^（异或）五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合的方式，可以达到desired的结果。

```java
public class Code_13_ExpressNums {

	// 方法一：暴力递归
	public int num_1(String express, boolean desired) {
		if (express == null || express.equals("")) {
			return 0;
		}
		char[] exp = express.toCharArray();
		if (!isValid(exp)) {
			return 0;
		}
		return p(exp, desired, 0, exp.length - 1);
	}

	public int p(char[] exp, boolean desired, int l, int r) {
		// 只剩一个元素
		if (l == r) {
			if (exp[l] == '1') {
				return desired ? 1 : 0;
			} else {
				return desired ? 0 : 1;
			}
		}
		int res = 0;
		if (desired) {
			// 遍历操作符
			for (int i = l + 1; i < r; i = i + 2) {
				switch (exp[i]) {
				case '&':
					// 左边为真的种数 x 右边为真的种数
					res += p(exp, true, 1, i - 1) * p(exp, true, i + 1, r);
					break;
				case '|':
					res += p(exp, true, 1, i - 1) * p(exp, false, i + 1, r);
					res += p(exp, false, 1, i - 1) * p(exp, true, i + 1, r);
					res += p(exp, true, 1, i - 1) * p(exp, true, i + 1, r);
					break;
				case '^':
					res += p(exp, true, 1, i - 1) * p(exp, false, i + 1, r);
					res += p(exp, false, 1, i - 1) * p(exp, true, i + 1, r);
					break;
				}
			}
		} else {
			// 遍历操作符
			for (int i = l + 1; i < r; i = i + 2) {
				switch (exp[i]) {
				case '&':
					res += p(exp, true, 1, i - 1) * p(exp, false, i + 1, r);
					res += p(exp, false, 1, i - 1) * p(exp, true, i + 1, r);
					res += p(exp, false, 1, i - 1) * p(exp, false, i + 1, r);
					break;
				case '|':
					res += p(exp, false, 1, i - 1) * p(exp, false, i + 1, r);
					break;
				case '^':
					res += p(exp, true, 1, i - 1) * p(exp, true, i + 1, r);
					res += p(exp, false, 1, i - 1) * p(exp, false, i + 1, r);
					break;
				}
			}
		}
		return res;
	}

	// 判断表达式是否合法
	public boolean isValid(char[] exp) {
		// 表达式的长度必须是奇数
		if ((exp.length & 1) == 0) {
			return false;
		}
		// 偶数下标表示数字一定是0或者1
		for (int i = 0; i < exp.length; i = i + 2) {
			if ((exp[i] != '1') && (exp[i] != '0')) {
				return false;
			}
		}
		// 奇数下标表示操作符是%|^三种之一
		for (int i = 1; i < exp.length; i = i + 2) {
			if ((exp[i] != '&') && (exp[i] != '|') && (exp[i] != '^')) {
				return false;
			}
		}
		return true;
	}
}
```



# 14 排成一条线的纸牌博弈问题

**题目**

给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是只能从两端拿，玩家A和B都是聪明人，请返回最后获胜者的分数。

```java
public class Code_14_CardGame {

	public int win_1(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		// 从先拿和后拿中选择最优的
		return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
	}

	// arr[i...j]先拿最终的分数
	public int f(int[] arr, int i, int j) {
		if (i == j) {
			return arr[i];
		}
		// 拿左边和拿右边
		return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
	}

	// arr[i...j]后拿最终的分数
	public int s(int[] arr, int i, int j) {
		if (i == j) {
			return arr[i];
		}
		// 对方也是聪明人，所以留下来的是小值
		return Math.min(f(arr, i + 1, j), f(arr, i, j - 1));
	}

	public int win_2(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[][] f = new int[arr.length][arr.length]; // 表示f(i,j)的返回值
		int[][] s = new int[arr.length][arr.length]; // 表示s(i,j)的返回值
		for (int j = 0; j < arr.length; j++) {
			f[j][j] = arr[j]; // 只剩一个值先选可以选到
			for (int i = j - 1; i >= 0; i--) {
				f[i][j] = Math.max(arr[i] + s[i + 1][j], arr[i] + s[i][j - 1]);
				s[i][j] = Math.min(f[i + 1][j], f[i][j - 1]);
			}
		}
		return Math.max(f[0][arr.length - 1], s[0][arr.length - 1]);
	}
}

```



# 15 跳跃游戏

**题目**

给定数组arr，arr[i] == k代表可以从位置i向右跳1~k个距离。如果从位置0出发，返回最少跳几次能跳到arr最后的位置上。

```java
public class Code_15_JumpGame {

	public int jump(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int jump = 0; // 目前跳了多少步
		int cur = 0; // 如果只能跳jump步最远能到达的位置
		int next = 0; // 再跳一步最远能到达的位置
		for (int i = 0; i < arr.length; i++) {
			if (cur < i) {
				jump++;
				cur = next;
			}
			next = Math.max(next, i + arr[i]);
		}
		return jump;
	}
}
```



# 16 数组中的最长连续序列

**题目**

给定无序数组arr，返回其中最长的连续序列的长度。

比如arr=[100,4,200,1,3,2]，最长的连续序列为[1,2,3,4]，返回4

```java
import java.util.HashMap;

public class Code_16_LongestConsecutive {

	public int longestConsecutive(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int max = 1;
		// value代表key这个值所在的最长连续序列的长度
		// 且key必在这个连续序列的最小值和最大值范围内
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int i = 0; i < arr.length; i++) {
			// 添加新值
			if (!map.containsKey(arr[i])) {
				map.put(arr[i], 1);
				if (map.containsKey(arr[i] - 1)) { // 遍历过前一个值
					max = Math.max(max, merge(map, arr[i] - 1, arr[i]));
				}
				if (map.containsKey(arr[i] + 1)) { // 遍历过后一个值
					max = Math.max(max, merge(map, arr[i], arr[i] + 1));
				}
			}
		}
		return max;
	}

	// 合并less和more所在的连续序列
	public int merge(HashMap<Integer, Integer> map, int less, int more) {
		int left = less - map.get(less) + 1; // 向左长度
		int right = more + map.get(more) - 1; // 向右长度
		int len = right - left + 1; // 合并后的长度
		map.put(left, len); // 更新长度值
		map.put(right, len);
		return len;
	}
}
```



# 17 N皇后问题

**题目**

N皇后问题是指在NxN的棋盘上要摆上N个皇后，要求任何两个皇后不同行，不同列，也不在同一条斜线上。给定一个整数n，返回n皇后的摆法有多少种。

```java
public class Code_17_NQueen {

	public int num(int n) {
		if (n < 1) {
			return 0;
		}
		// 保存已经放置的皇后位置
		// record[i]表示第i行皇后所在的列
		int[] record = new int[n];
		return process(0, record, n);
	}

	public int process(int i, int[] record, int n) {
		if (i == n) {
			return 1;
		}
		int res = 0;
		for (int j = 0; j < n; j++) {
			if (isValid(record, i, j)) {
				record[i] = j; // 在第i行第j列放置皇后
				res += process(i + 1, record, n); // 递归放置下一行
			}
		}
		return res;
	}

	// 判断第i行第j列能否放皇后
	public boolean isValid(int[] record, int i, int j) {
        // 遍历之前的每一行
		for (int k = 0; k < i; k++) {
			if (j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)) {
				return false;
			}
		}
		return true;
	}
}
```

