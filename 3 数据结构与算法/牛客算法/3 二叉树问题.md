# 1 递归或非递归方式实现二叉树先序、中序和后序遍历

**题目**

用递归和非递归方式，分别按照二叉树的先序、中序和后序打印所有节点。

```java
import java.util.Stack;

public class Code_01_OrderTree {

	public class Node {
		public int value;
		public Node left;
		public Node right;

		public Node(int value) {
			this.value = value;
		}
	}

	// 递归先序
	public void preOrderRecur(Node head) {
		if (head == null) {
			return;
		}
		System.out.println(head.value + " ");
		preOrderRecur(head.left);
		preOrderRecur(head.right);
	}

	// 递归中序
	public void inOrderRecur(Node head) {
		if (head == null) {
			return;
		}
		preOrderRecur(head.left);
		System.out.println(head.value + " ");
		preOrderRecur(head.right);
	}

	// 递归后序
	public void posOrderRecur(Node head) {
		if (head == null) {
			return;
		}
		preOrderRecur(head.left);
		preOrderRecur(head.right);
		System.out.println(head.value + " ");
	}

	// 非递归先序
	public void preOrderUnRecur(Node head) {
		if (head != null) {
			Stack<Node> stack = new Stack<>();
			stack.push(head);
			while (!stack.isEmpty()) {
				// 先打印节点
				head = stack.pop();
				System.out.println(head.value + " ");
				// 先压右孩子，再压左孩子
				if (head.right != null) {
					stack.push(head.right);
				}
				if (head.left != null) {
					stack.push(head.left);
				}
			}
		}
	}

	// 非递归中序
	public void inOrderUnRecur(Node head) {
		if (head != null) {
			Stack<Node> stack = new Stack<>();
			while (!stack.isEmpty() || head != null) {
				if (head != null) { // 当前节点不空则压栈并指向左孩子
					stack.push(head);
					head = head.left;
				} else { // 当前节点为空栈不为空则出栈打印并指向右孩子
					head = stack.pop();
					System.out.println(head.value + " ");
					head = head.right;
				}
			}
		}
	}

	// 非递归后序（两个栈）
	public void posOrderUnRecur(Node head) {
		if (head != null) {
			Stack<Node> s1 = new Stack<>();
			Stack<Node> s2 = new Stack<>();
			s1.push(head);
			while (!s1.isEmpty()) {
				head = s1.pop();
				s2.push(head); // 不打印压入另一个栈
				// 先压左孩子，再压右孩子（中左右变为中右左）
				if (head.left != null) {
					s1.push(head.left);
				}
				if (head.right != null) {
					s2.push(head.right);
				}
			}
			// 利用s2逆序（中右左变为左右中）
			while (!s2.isEmpty()) {
				System.out.println(s2.pop().value + " ");
			}
		}
	}

}
```



# 2 打印二叉树的边界节点

**题目**

给定一棵二叉树的头节点head，按照如下两种标准分别实现二叉树边界节点的逆时针打印。

标准一：

1. 头节点为边界节点。
2. 叶节点为边界节点。
3. 如果节点在其所在的层中是最左或最右的，那么也是边界节点。

标准二：

1. 头节点为边界节点。
2. 叶节点为边界节点。
3. 树左边界延申下去的路径为边界节点。
4. 树右边界延申下去的路径为边界节点。

**要求**

- 如果节点数为N，两种标准实现的时间复杂度要求都为o(N)，额外空间复杂度要求都为o(h)，h为二叉树的高度。
- 两种标准都要求逆时针顺序且不重复打印所有的边界节点。

```java
public class Code_02_PrintEdge {

	// 标准一
	public void printEdge_1(Node head) {
		if (head == null) {
			return;
		}
		int height = getHeight(head, 0);
		Node[][] edgeMap = new Node[height][2]; // 存储每一层的最左和最右节点
		setEdgeMap(head, 0, edgeMap);
		// 打印左边界
		for (int i = 0; i < edgeMap.length; i++) {
			System.out.println(edgeMap[i][0].value + " ");
		}
		// 打印既不是左边界，也不是右边界的叶子节点
		printLeafNotInMap(head, 0, edgeMap);
		// 打印右边界，但不是左边界的节点
		for (int i = edgeMap.length - 1; i >= 0; i--) {
			if (edgeMap[i][0] != edgeMap[i][1]) {
				System.out.println(edgeMap[i][1].value + " ");
			}
		}
	}

	// 获取二叉树高度
	public int getHeight(Node head, int h) {
		if (head == null) {
			return h;
		}
		return Math.max(getHeight(head.left, h + 1), getHeight(head.right, h + 1));
	}

	public void setEdgeMap(Node head, int h, Node[][] edgeMap) {
		if (head == null) {
			return;
		}
		edgeMap[h][0] = edgeMap[h][0] == null ? head : edgeMap[h][0]; // 最左节点是本层第一个遍历到的节点
		edgeMap[h][1] = head; // 最右节点是本层最后一个遍历到的节点
		setEdgeMap(head.left, h + 1, edgeMap);
		setEdgeMap(head.right, h + 1, edgeMap);
	}

	public void printLeafNotInMap(Node head, int h, Node[][] edgeMap) {
		if (head == null) {
			return;
		}
		// 叶子节点同时不是最左也不是最右节点
		if (head.left == null && head.right == null && head != edgeMap[h][0] && head != edgeMap[h][1]) {
			System.out.println(head.value + " ");
		}
		printLeafNotInMap(head.left, h + 1, edgeMap);
		printLeafNotInMap(head.right, h + 1, edgeMap);
	}

	// 标准二
	public void printEdge_2(Node head) {
		if (head == null) {
			return;
		}
		System.out.println(head.value + " ");
		if (head.left != null && head.right != null) {
			// 左右孩子都有则进入打印边界过程
			printLeftEdge(head.left, true);
			printRightEdge(head.right, true);
		} else {
			// 一直向下寻找
			printEdge_2(head.left != null ? head.left : head.right);
		}
	}

	public void printLeftEdge(Node h, boolean print) {
		if (h == null) {
			return;
		}
		// 边界或者叶节点
		if (print || (h.left == null && h.right == null)) {
			System.out.println(h.value + " ");
		}
		printLeftEdge(h.left, print);
		printLeftEdge(h.right, print && h.left == null ? true : false); // 左孩子为空右孩子才能为左边界
	}

	public void printRightEdge(Node h, boolean print) {
		if (h == null) {
			return;
		}
		printRightEdge(h.left, print && h.right == null ? true : false);
		printLeftEdge(h.right, print);
		if (print || (h.left == null && h.right == null)) {
			System.out.println(h.value + " ");
		}
	}

}
```



# 3 如何较为直观的打印二叉树

**题目**

给定一颗二叉树的头节点 head，已知二叉树的节点值的类型是32位整型，实现一个打印二叉树的函数，可以直观的展示树的形状。

```java
package chapter_03;

public class Code_03_PrintTree {

	public void printTree(Node head) {
		System.out.println("Binary Tree:");
		printInOrder(head, 0, "H", 17);
	}

	// 先序打印二叉树
	public void printInOrder(Node head, int height, String to, int len) {
		if (head == null) {
			return;
		}
		printInOrder(head.left, height + 1, "v", len); // 递归左子树
		String val = to + head.value + to;
		int lenM = val.length();
		int lenL = (len - lenM) / 2;
		int lenR = len - lenM - lenL;
		val = getSpace(lenL) + val + getSpace(lenR); // 规范化节点的值
		System.out.println(getSpace(height * len) + val); // 每行前面的空格
		printInOrder(head.left, height + 1, "^", len); // 递归右子树
	}

	// 返回指定大小的空格
	public String getSpace(int num) {
		String space = " ";
		StringBuffer buffer = new StringBuffer("");
		for (int i = 0; i < num; i++) {
			buffer.append(space);
		}
		return buffer.toString();
	}

}
```



# 4 二叉树的序列化和反序列化

**题目**

二叉树被记录成文件的过程叫做二叉树的序列化，通过文件内容重建原来的二叉树的过程叫做二叉树的反序列化。给定一棵二叉树的头节点head，并已知二叉树节点值的类型为32位整型。请实现二叉树的序列化和反序列化。

```java
import java.util.LinkedList;
import java.util.Queue;

public class Code_04_SerialTree {

	// 先序遍历序列化
	public String serialByPre(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		res += serialByPre(head.left);
		res += serialByPre(head.right);
		return res;
	}

	// 先序遍历反序列化
	public Node reconByPreString(String preStr) {
		String[] values = preStr.split("!");
		Queue<String> queue = new LinkedList<>();
		for (int i = 0; i < values.length; i++) {
			queue.offer(values[i]);
		}
		return reconPreOrder(queue);
	}

	public Node reconPreOrder(Queue<String> queue) {
		String value = queue.poll();
		if (value.equals("#")) {
			return null;
		}
		Node head = new Node(Integer.valueOf(value));
		head.left = reconPreOrder(queue);
		head.right = reconPreOrder(queue);
		return head;
	}

	// 层序遍历序列化
	public String serialByLevel(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		Queue<Node> queue = new LinkedList<>();
		queue.offer(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			if (head.left != null) {
				res += head.left.value + "!";
				queue.offer(head.left);
			} else {
				res += "#!";
			}
			if (head.right != null) {
				res += head.right.value + "!";
				queue.offer(head.right);
			} else {
				res += "#!";
			}
		}
		return res;
	}

	// 层序遍历反序列化
	public Node reconByLevelString(String levelStr) {
		String[] values = levelStr.split("!");
		int index = 0;
		Node head = generateNodeByString(values[index++]);
		Queue<Node> queue = new LinkedList<>();
		if (head != null) {
			queue.offer(head);
		}
		Node node = null;
		while (!queue.isEmpty()) {
			node = queue.poll();
			node.left = generateNodeByString(values[index++]);
			node.right = generateNodeByString(values[index++]);
			// 如果节点非空进行连接
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
		return head;
	}

	// 根据节点值生成新节点
	public Node generateNodeByString(String val) {
		if (val.equals("#")) {
			return null;
		}
		return new Node(Integer.valueOf(val));
	}
}
```



# 5 遍历二叉树的神级方法

**题目**

给定一棵二叉树的头节点head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数位N，要求时间复杂度o(N)，额外空间复杂度o(1)。

**步骤**

1. 假设当前子数的头节点为h，让h的左子树种最右节点的right指针指向h，然后h的左子树继续步骤1的处理过程，直到遇到某一个节点没有左子树记为node，进入步骤2

2. 从node开始通过每个节点的right指针进行移动，并依次打印，假设移动到的节点为cur。对每一个cur节点都判断cur节点的左子树中最右节点是否指向cur。

   ① 如果是。让cur节点的左子树中最右节点的right指针指向空，也就是把步骤1的调整后再逐渐调整回来，然后打印cur，继续通过cur的right指针移动到下一个节点，重复步骤2

   ② 如果不是。以cur为头的子树重回步骤1执行。

中序遍历在打印某个节点时，一定是在步骤2开始移动的过程中，而步骤2最初开始时的位置一定是子树的最左节点，在通过right指针移动的过程中，要么是某个节点移动到右子树上，此时左子树和根节点已经打印结束，开始右子树的处理过程；要么是某个节点移动到某个上层的节点，此时必然是这个上层节点的左子树整体打印完毕，然后开始处理根节点和右子树的过程。

```java
public class Code_05_Morris {

	// Morris中序遍历
	public void morrisIn(Node head) {
		if (head == null) {
			return;
		}
		Node cur1 = head; // 遍历以cur1为头节点的子数
		Node cur2 = null;
		while (cur1 != null) {
			cur2 = cur1.left;
			// 先处理左子树
			if (cur2 != null) {
				// 找到左子树的最右节点
				while (cur2.right != null && cur2.right != cur1) {
					cur2 = cur2.right;
				}
				// cur2的右指针为空
				if (cur2.right == null) {
					cur2.right = cur1;
					cur1 = cur1.left; // 继续处理cur1的左子树
					continue;
				} else { // cur2的右指针不为空
					cur2.right = null;
				}
			}
			System.out.println(cur1.value + " ");
			cur1 = cur1.right; // 左中都打印完开始向右子树移动
		}
	}

}
```

先序遍历是中序遍历的简单改写。中序遍历的打印时机放在了步骤2所描述的移动过程中，而先序遍历只要把打印时机放在步骤1发生的时候即可。步骤1发生的时候，正在处理以h为头的子树，并且是以h为头的子树首次进入调整过程，此时直接打印h，就可以做到先序打印。

```java
public class Code_05_Morris {

	// Morris先序遍历
	public void morrisPre(Node head) {
		if (head == null) {
			return;
		}
		Node cur1 = head;
		Node cur2 = null;
		while (cur1 != null) {
			cur2 = cur1.left;
			if (cur2 != null) {
				while (cur2.right != null && cur2.right != cur1) {
					cur2 = cur2.right;
				}
				if (cur2.right == null) {
					cur2.right = cur1;
					System.out.println(cur1.value + " "); // 打印时机
					cur1 = cur1.left;
					continue;
				} else {
					cur2.right = null;
				}
			} else {
				// 左子树为空直接打印根节点
				System.out.println(cur1.value + " ");
			}
			cur1 = cur1.right;
		}
	}

}
```

后序遍历依次逆序打印所有节点的左子树的右边界，打印的时机放在步骤2的条件①被触发的时候，也就是调回去的过程发生的时候。最后，因为整棵二叉树并不属于任何节点的左子树，所以，整棵树的右边界需要单独逆序打印。

```java
public class Code_05_Morris {

	// Morris后序遍历
	public void morrisPos(Node head) {
		if (head == null) {
			return;
		}
		Node cur1 = head;
		Node cur2 = null;
		while (cur1 != null) {
			cur2 = cur1.left;
			if (cur2 != null) {
				while (cur2.right != null && cur2.right != cur1) {
					cur2 = cur2.right;
				}
				if (cur2.right == null) {
					cur2.right = cur1;
					cur1 = cur1.left;
					continue;
				} else {
					cur2.right = null;
					printEdge(cur1.left);
				}
			}
			cur1 = cur1.right;
		}
		printEdge(head); // 最后单独打印整棵树的右边界
	}

	// 打印右边界
	public void printEdge(Node head) {
		Node tail = reverseEdge(head); // 逆序
		Node cur = tail;
		while (cur != null) {
			System.out.println(cur.value + " ");
			cur = cur.right;
		}
		reverseEdge(tail); // 恢复原状
	}

	// 逆序右边界
	public Node reverseEdge(Node from) {
		Node pre = null;
		Node next = null;
		while (from != null) {
			next = from.right;
			from.right = pre;
			pre = from;
			from = next;
		}
		return pre;
	}

}
```



# 6 在二叉树种找到累加和为指定值的最长路径长度

**题目**

给定一棵二叉树的头节点head和一个32位整数num，二叉树节点值类型为整型。求累加和为sum的最长路径长度。

**要求**

如果节点数为N，时间复杂度o(N)，额外空间复杂度o(h)。

```java
import java.util.HashMap;

public class Code_06_GetMaxLength {

	public int getMaxLength(Node head, int sum) {
		// HashMap负责记录从head开始的一条路径上的累加和出现情况
		// key --> 某个累加和的值
		// value --> 这个累加和在路径中最早出现的层数
		HashMap<Integer, Integer> sumMap = new HashMap<>();
		sumMap.put(0, 0);
		return preOrder(head, sum, 0, 1, 0, sumMap);
	}

	public int preOrder(Node head, int sum, int preSum, int level, int maxLen, HashMap<Integer, Integer> sumMap) {
		if (head == null) {
			return maxLen;
		}
		int curSum = preSum + head.value;
		if (!sumMap.containsKey(curSum)) { // 添加新出现的累加和值
			sumMap.put(curSum, level);
		}
		// curSum-sum的最早出现位置如果有记录，则可得到一个最长记录
		if (sumMap.containsKey(curSum - sum)) {
			maxLen = Math.max(level - sumMap.get(curSum - sum), maxLen);
		}
		maxLen = preOrder(head.left, sum, preSum, level + 1, maxLen, sumMap);
		maxLen = preOrder(head.right, sum, preSum, level + 1, maxLen, sumMap);
		// 向上层返回时删除记录
		if (level == sumMap.get(curSum)) {
			sumMap.remove(curSum);
		}
		return maxLen;
	}

}
```



# 7 找到二叉树中的最大搜索二叉子树

**题目**

给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。

**要求**

如果节点数为N，要求时间复杂度为o(N)，额外空间复杂度o(h)

```java
public class Code_07_BiggestSubBST {

	public Node biggestSubBST(Node head) {
		int[] record = new int[3]; // 最大BST大小、最小值和最大值
		return posOrder(head, record);
	}

	public Node posOrder(Node head, int[] record) {
		if (head == null) {
			record[0] = 0;
			record[1] = Integer.MAX_VALUE;
			record[2] = Integer.MIN_VALUE;
			return null;
		}
		int value = head.value;
		// 先递归处理左子树
		Node lBST = posOrder(head.left, record);
		int lSize = record[0];
		int lMin = record[1];
		int lMax = record[2];
		// 再递归处理右子树
		Node rBST = posOrder(head.right, record);
		int rSize = record[0];
		int rMin = record[1];
		int rMax = record[2];
		// 记录本子树的最大值和最小值
		record[1] = Math.min(lMin, value);
		record[2] = Math.max(rMax, value);
		// 头节点head满足BST条件进行添加
		if (head.left == lBST && head.right == rBST && lMax < value && value < rMin) {
			record[0] = lSize + rSize + 1;
			return head;
		}
		// 头节点不满足条件返回左右子树中BST的最大值
		record[0] = Math.max(lSize, rSize);
		return lSize > rSize ? lBST : rBST;
	}
}
```



# 8 找到二叉树中符合搜索二叉树条件的最大拓扑结构

**题目**

给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。

```java
import java.util.HashMap;
import java.util.Map;

public class Code_08_BSTTopoSize {

	// 方法一:利用队列结构
	// 时间复杂度o(N^2)
	public int bstTopoSize_1(Node head) {
		if (head == null) {
			return 0;
		}
		int max = maxTopo(head, head);
		// 递归左右子树
		max = Math.max(bstTopoSize_1(head.left), max);
		max = Math.max(bstTopoSize_1(head.right), max);
		return max;
	}

	public int maxTopo(Node h, Node n) {
		if (h != null && n != null && isBSTNode(h, n, n.value)) {
			// 递归结点n的左右子树判断
			return maxTopo(h, n.left) + maxTopo(h, n.right) + 1;
		}
		// 结点n不满足搜索结构直接返回0
		return 0;
	}

	// 查找结点n是否在以h为头节点的搜索二叉树结构中
	public boolean isBSTNode(Node h, Node n, int value) {
		if (h == null) {
			return false;
		}
		if (h == n) {
			return true;
		}
		return isBSTNode(h.value > value ? h.left : h.right, n, value);
	}

	// 每个结点对应的左右子树的贡献值记录
	public class Record {
		public int l;
		public int r;

		public Record(int left, int right) {
			this.l = left;
			this.r = right;
		}
	}

	// 方法二:拓扑贡献记录
	// 时间复杂度最好o(N)，最差o(NlogN)
	public int bstTopoSize_2(Node head) {
		Map<Node, Record> map = new HashMap<>();
		return posOrder(head, map);
	}

	// 后序遍历
	public int posOrder(Node h, Map<Node, Record> map) {
		if (h == null) {
			return 0;
		}
		int ls = posOrder(h.left, map);
		int rs = posOrder(h.right, map);
		modifyMap(h.left, h.value, map, true); // 修改h左子树的贡献值
		modifyMap(h.right, h.value, map, false); // 修改h右子树的贡献值
		Record lr = map.get(h.left); // 左子树的贡献值
		Record rr = map.get(h.right); // 右子树的贡献值
		int lbst = lr == null ? 0 : lr.l + lr.r + 1;
		int rbst = rr == null ? 0 : rr.l + rr.r + 1;
		map.put(h, new Record(lbst, rbst)); // 添加h结点记录
		return Math.max(lbst + rbst + 1, Math.max(ls, rs)); // 返回最大拓扑结构大小
	}

	public int modifyMap(Node n, int v, Map<Node, Record> m, boolean s) {
		if (n == null || (!m.containsKey(n))) {
			return 0;
		}
		Record record = m.get(n);
		if ((s && n.value > v) || ((!s) && n.value < v)) {
			// 不满足条件的结点删除
			m.remove(n);
			return record.l + record.r + 1; // 返回值是向上传递的要删除的贡献值
		} else {
			// 递归求得左子树的右边界或者右子树的左边界需要删除的值
			int minus = modifyMap(s ? n.right : n.left, v, m, s);
			if (s) { // 左子树删除右值
				record.r = record.r - minus;
			} else { // 右子树删除左值
				record.l = record.l - minus;
			}
			m.put(n, record); // 添加新纪录
			return minus;
		}
	}
}
```



# 9 二叉树的按层打印与ZigZag打印

**题目**

给定一棵二叉树的头节点head，分别实现按层打印和ZigZag打印二叉树的函数。

要求输出对应的行号。

```java
import java.util.Deque;
import java.util.LinkedList;
import java.util.Queue;

public class Code_09_PrintByLevelOrZigZag {

	// 按层打印二叉树
	public void printByLevel(Node head) {
		if (head == null) {
			return;
		}
		Queue<Node> queue = new LinkedList<>();
		int level = 1;
		Node last = head; // 本层的最后一个结点
		Node nLast = null; // 下一层的最后一个结点
		queue.offer(head);
		System.out.println("Level " + (level++) + " : ");
		while (!queue.isEmpty()) {
			head = queue.poll();
			System.out.println(head.value + " ");
			if (head.left != null) {
				queue.offer(head.left);
				nLast = head.left;
			}
			if (head.right != null) {
				queue.offer(head.right);
				nLast = head.right; // nLast是本层最新入队的结点
			}
			// 遍历到本层的尾部
			if (head == last && !queue.isEmpty()) {
				System.out.println("\nLevel " + (level++) + " : ");
				last = nLast;
			}
		}
	}

	// ZigZag打印二叉树
	public void printByZigZag(Node head) {
		if (head == null) {
			return;
		}
		Deque<Node> deque = new LinkedList<>(); // 双端队列
		int level = 1;
		boolean lr = true; // 打印方向
		Node last = head;
		Node nLast = null;
		deque.offerFirst(head);
		printLevelAndOrientation(level++, lr);
		while (!deque.isEmpty()) {
			if (lr) { // 左->右
				head = deque.pollFirst(); // 从头部弹出
				// 先入左再入右
				if (head.left != null) {
					nLast = nLast == null ? head.left : nLast; // 下一行的最后结点是本层的第一个孩子ֵ
					deque.offerLast(head.left); // 从尾部插入
				}
				if (head.right != null) {
					nLast = nLast == null ? head.right : nLast;
					deque.offerLast(head.right);
				}
			} else { // 右->左
				head = deque.pollLast(); // 从尾部弹出
				// 先入右再入左
				if (head.right != null) {
					nLast = nLast == null ? head.right : nLast;
					deque.offerFirst(head.right); // 从头部插入
				}
				if (head.left != null) {
					nLast = nLast == null ? head.left : nLast;
					deque.offerFirst(head.left);
				}
			}
			System.out.println(head.value + " ");
			// 遍历到本行尾部
			if (head == last && !deque.isEmpty()) {
				lr = !lr;
				last = nLast;
				nLast = null;
				System.out.println();
				printLevelAndOrientation(level++, lr);
			}
		}
	}

	// 格式化打印每层信息
	public void printLevelAndOrientation(int level, boolean lr) {
		System.out.println("Level " + level + " from ");
		System.out.println(lr ? "left to right: " : "right to left: ");
	}
}
```



# 10 调整搜索二叉树中两个错误的节点

**题目**

一棵二叉树原本是搜索二叉树，但是其中有两个节点调换了位置，使得不再是搜索二叉树，请找出这两个错误节点并返回。

**进阶**

结构上调整两个错误节点，使其恢复为搜索二叉树。

```java
import java.util.Stack;

public class Code_10_GetTwoErrNodes {

	// 通过改写中序非递归版本找到两个错误的节点
	public Node[] getTwoErrNodes(Node head) {
		Node[] errs = new Node[2];
		if (head == null) {
			return errs;
		}
		Stack<Node> stack = new Stack<>();
		Node pre = null; // 记录前一个节点
		while (!stack.isEmpty() || head != null) {
			if (head != null) { //
				stack.push(head);
				head = head.left;
			} else {
				head = stack.pop();
				if (pre != null && pre.value > head.value) { // 出现了前大于后的情况
					errs[0] = errs[0] == null ? pre : errs[0];// 第一个错误值是第一次降序的第一个元素
					errs[1] = head; // 第二个错误值是最后一次降序的第二个元素
				}
				pre = head;
				head = head.right;
			}
		}
		return errs;
	}

	// 从结构上调整节点位置，分多种情况讨论
	public Node recoverTree(Node head) {
		Node[] errs = getTwoErrNodes(head);
		Node[] parents = getTwoErrParents(head, errs[0], errs[1]);
		// 第一个错误节点的信息
		Node e1 = errs[0];
		Node e1P = parents[0];
		Node e1L = e1.left;
		Node e1R = e1.right;
		// 第二个错误节点的信息
		Node e2 = errs[1];
		Node e2P = parents[1];
		Node e2L = e2.left;
		Node e2R = e2.right;

		if (e1 == head) { // e1是头节点
			if (e1 == e2P) { // e1是e2的父节点
				e1.left = e2L;
				e1.right = e2R;
				e2.right = e1;
				e2.left = e1L;
			} else if (e2P.left == e2) {// e2是其父的左孩子
				e2P.left = e1;
				e2.left = e1L;
				e2.right = e1R;
				e1.left = e2L;
				e1.right = e2R;
			} else { // e2是其父的右孩子
				e2P.right = e1;
				e2.left = e1L;
				e2.right = e1R;
				e1.left = e2L;
				e1.right = e2R;
			}
			head = e2; // e2成为了新头节点
		} else if (e2 == head) { // e2是头节点
			if (e2 == e1P) { // e2是e1的父节点
				e2.left = e1L;
				e2.right = e1R;
				e1.right = e2;
				e1.left = e2L;
			} else if (e1P.left == e1) {// e1是其父的左孩子
				e1P.left = e2;
				e1.left = e2L;
				e1.right = e2R;
				e2.left = e1L;
				e2.right = e1R;
			} else { // e1是其父的右孩子
				e1P.right = e2;
				e1.left = e2L;
				e1.right = e2R;
				e2.left = e1L;
				e2.right = e1R;
			}
			head = e1;// e1成为了新的头节点
		} else { // e1和e2节点都不是头节点
			if (e1 == e2P) { // e1是e2的父节点且e2只可能是e1的右孩子
				if (e1P.left == e1) {// e1是其父的左孩子
					e1P.left = e2;
					e1.left = e2L;
					e1.right = e2R;
					e2.left = e1L;
					e2.right = e1;
				} else {// e1是其父的右孩子
					e1P.right = e2;
					e1.left = e2L;
					e1.right = e2R;
					e2.left = e1L;
					e2.right = e1;
				}
			} else if (e2 == e1P) { // e2是e1的父节点且e1只可能是e2的左孩子
				if (e2P.left == e2) {// e2是其父的左孩子
					e2P.left = e1;
					e2.left = e1L;
					e2.right = e1R;
					e1.left = e2;
					e1.right = e2R;
				} else {// e2是其父的右孩子
					e2P.right = e1;
					e2.left = e1L;
					e2.right = e1R;
					e1.left = e2;
					e1.right = e2R;
				}
			} else { // e1和e2都不是头且不存在父子关系
				if (e1P.left == e1) { // e1是其父的左孩子
					if (e2P.left == e2) {// e2是其父的左孩子
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e2R;
						e1P.left = e2;
						e2P.left = e1;
					} else {// e2是其父的右孩子
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e2R;
						e1P.left = e2;
						e2P.right = e1;
					}
				} else { // e1是其父的右孩子
					if (e2P.left == e2) {// e2是其父的左孩子
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e2R;
						e1P.right = e2;
						e2P.left = e1;
					} else {// e2是其父的右孩子
						e1.left = e2L;
						e1.right = e2R;
						e2.left = e1L;
						e2.right = e2R;
						e1P.right = e2;
						e2P.right = e1;
					}
				}
			}
		}
		return head;
	}

	// 获取两个错误节点各自的父节点
	public Node[] getTwoErrParents(Node head, Node e1, Node e2) {
		Node[] parents = new Node[2];
		if (head == null) {
			return parents;
		}
		Stack<Node> stack = new Stack<>();
		while (!stack.isEmpty() || head != null) {
			if (head != null) {
				stack.push(head);
				head = head.left;
			} else {
				head = stack.pop();
				if (head.left == e1 || head.right == e1) {
					parents[0] = head;
				}
				if (head.left == e2 || head.right == e2) {
					parents[1] = head;
				}
				head = head.right;
			}
		}
		return parents;
	}

}
```



# 11 判断t1树是否包含t2树全部的拓扑结构

**题目**

给定彼此独立的两棵树头节点分别为t1和t2，判断t1树是否包含t2树全部的拓扑结构。

```java
public class Code_11_Contains {

	// 时间复杂度o(NxM)，空间复杂度o(1)
	public boolean contains(Node t1, Node t2) {
		return check(t1, t2) || contains(t1.left, t2) || contains(t1.right, t2);
	}

	// 从节点h和t2开始进行判断
	public boolean check(Node h, Node t2) {
		if (t2 == null) {
			return true;
		}
		if (h == null || h.value != t2.value) {
			return false;
		}
		return check(h.left, t2.left) && check(h.right, t2.right);
	}

}
```



# 12 判断t1树中是否有与t2树拓扑结构完全相同的子树

**题目**

给定彼此独立的两棵树头节点分别为t1和t2，判断t1中是否有与t2树拓扑结构完全相同的子树。

```java
public class Code_12_IsSubTree {

	// 利用KMP算法处理序列化结果
	// 时间复杂度o(N+M)，空间复杂度o(1)
	public boolean isSubTree(Node t1, Node t2) {
		String t1Str = serialByPre(t1);
		String t2Str = serialByPre(t2);
		return getIndexOf(t1Str, t2Str) != -1;
	}

	// 先序序列化
	public String serialByPre(Node head) {
		if (head == null) {
			return "#!";
		}
		String res = head.value + "!";
		res += serialByPre(head.left);
		res += serialByPre(head.right);
		return res;
	}

	// KMP算法
	public int getIndexOf(String s, String m) {
		if (s == null || m == null || m.length() < 1 || s.length() < m.length()) {
			return -1;
		}
		char[] ss = s.toCharArray();
		char[] ms = m.toCharArray();
		int si = 0;
		int mi = 0;
		int[] next = getNextArray(ms);
		while (si < ss.length && mi < ms.length) {
			if (ss[si] == ms[mi]) {
				si++;
				mi++;
			} else if (next[mi] == -1) {
				si++;
			} else {
				mi = next[mi];
			}
		}
		return mi == ms.length ? si - mi : -1;
	}

	public int[] getNextArray(char[] ms) {
		if (ms.length == 1) {
			return new int[] { -1 };
		}
		int[] next = new int[ms.length];
		next[0] = -1;
		next[1] = 0;
		int pos = 2;
		int cn = 0;
		while (pos < next.length) {
			if (ms[pos - 1] == ms[cn]) {
				next[pos++] = ++cn;
			} else if (cn > 0) {
				cn = next[cn];
			} else {
				next[pos++] = 0;
			}
		}
		return next;
	}
}
```



# 13 判断二叉树是否为平衡二叉树

**题目**

给定一棵二叉树的头节点head，判断这颗二叉树是否为平衡二叉树。

**要求**

如果二叉树的节点数为N，要求时间复杂度为o(N)。

```java
public class Code_13_IsBalance {

	public boolean isBalance(Node head) {
		boolean[] res = new boolean[1]; // 是否为平衡二叉树
		res[0] = true;
		getHeight(head, 1, res);
		return res[0];
	}

	// 获取子树的高度
	public int getHeight(Node head, int level, boolean[] res) {
		if (head == null) {
			return level;
		}
		int lH = getHeight(head.left, level + 1, res);
		if (!res[0]) {
			return level;
		}
		int rH = getHeight(head.right, level + 1, res);
		if (!res[0]) {
			return level;
		}
		if (Math.abs(lH - rH) > 1) {
			res[0] = false;
		}
		return Math.max(lH, rH);
	}
}
```



# 14 根据后序数组重建搜索二叉树

**题目**

给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。

**进阶**

如果整型数组arr中没有重复值，且已知是一棵搜索二叉树的后序遍历结果，通过数组arr重构二叉树。

```java
public class Code_14_PosArrayToBST {

	// 判断数组是否为后序结果
	public boolean isPostArray(int[] arr) {
		if (arr == null || arr.length == 0) {
			return false;
		}
		return isPost(arr, 0, arr.length - 1);
	}

	public boolean isPost(int[] arr, int start, int end) {
		if (start == end) {
			return true;
		}
		int less = -1; // less值代表最新的小于头节点的值
		int more = end; // more代表第一个大于头节点的值
		for (int i = start; i < end; i++) {
			if (arr[end] > arr[i]) {
				less = i;
			} else {
				more = more == end ? i : more;
			}
		}
		if (less == -1 || more == end) { // 只含有左子树或右子树
			return isPost(arr, start, end - 1);
		}
		if (less != more - 1) { // 不符合条件
			return false;
		}
		// 递归处理左子树和右子树
		return isPost(arr, start, less) && isPost(arr, more, end - 1);
	}
}
```

```java
public class Code_14_PosArrayToBST {

	// 根据搜索二叉树的后序结果重建二叉树
	public Node posArrayToBST(int[] posArr) {
		if (posArr == null) {
			return null;
		}
		return posToBST(posArr, 0, posArr.length - 1);
	}

	public Node posToBST(int[] posArr, int start, int end) {
		if (start > end) {
			return null;
		}
		Node head = new Node(posArr[end]); // 最后一个值为头节点
		int less = -1;
		int more = end;
		for (int i = start; i < end; i++) {
			if (posArr[end] > posArr[i]) {
				less = i;
			} else {
				more = more == end ? i : more;
			}
		}
		head.left = posToBST(posArr, start, less);
		head.right = posToBST(posArr, more, end - 1);
		return head;
	}
}
```



# 15 判断二叉树是否为搜索二叉树和完全二叉树

**题目**

给定一个二叉树的头节点head，已知其中没有重复值的节点，实现两个函数分别判断这棵二叉树是否为搜索二叉树和完全二叉树。

```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class Code_15_IsBSTOrCBT {

	// 搜索二叉树判断
	public boolean isBST(Node head) {
		int lastData = Integer.MIN_VALUE;
		if (head != null) {
			Stack<Node> stack = new Stack<>();
			while (!stack.isEmpty() || head != null) {
				if (head != null) {
					stack.push(head);
					head = head.left;
				} else {
					head = stack.pop();
					if (head.value < lastData) {
						return false;
					}
					lastData = head.value;
					head = head.right;
				}
			}
		}
		return true;
	}
}
```



```java
import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class Code_15_IsBSTOrCBT {

	// 完全二叉树判断
	public boolean isCBT(Node head) {
		if (head == null) {
			return true;
		}
		Queue<Node> queue = new LinkedList<>();
		boolean leaf = false;
		Node l = null;
		Node r = null;
		queue.offer(head);
		while (!queue.isEmpty()) {
			head = queue.poll();
			l = head.left;
			r = head.right;
			if ((l == null && r != null) || (leaf && (l != null || r != null))) {
				return false;
			}
			if (l != null) {
				queue.offer(l);
			}
			if (r != null) {
				queue.offer(r);
			} else {
				leaf = true;
			}
		}
		return true;
	}
}
```



# 16 通过有序数组生成平衡搜索二叉树

**题目**

给定一个有序数组sortArr，已知其中没有重复值，用这个有序数组生成一棵平衡搜索二叉树，并且该搜索二叉树中序遍历的结果与sortArr一致。

```java
public class Code_16_GenerateTree {

	public Node generateTree(int[] sortArr) {
		if (sortArr == null) {
			return null;
		}
		return generate(sortArr, 0, sortArr.length - 1);
	}

	public Node generate(int[] sortArr, int start, int end) {
		if (start > end) {
			return null;
		}
		int mid = (start + end) / 2; // 中间的节点是头节点
		Node head = new Node(sortArr[mid]);
		// 递归处理左右子树
		head.left = generate(sortArr, start, mid - 1);
		head.right = generate(sortArr, mid + 1, end);
		return head;
	}

}
```



# 17 在二叉树中找到一个节点的后继节点

**题目**

现在有一种新的二叉树结点类型如下：

```java
public class Node {
    public int value;
    public Node left;
    public Node right;
	public Node parent;
    
    public Node(int value) {
        this.value = value;
    }
}
```

只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。

```java
public class Code_17_GetNextNode {

	public Node getNextNode(Node node) {
		if (node == null) {
			return node;
		}
		if (node.right != null) {
			return getLeftMost(node.right); // 返回右子树的最左节点
		} else {
			Node parent = node.parent;
			// 寻找某个父节点是其父的左孩子结构
			while (parent != null && parent.left != node) {
				node = parent;
				parent = node.parent;
			}
			return parent;
		}
	}

	public Node getLeftMost(Node node) {
		if (node == null) {
			return node;
		}
		while (node.left != null) {
			node = node.left;
		}
		return node;
	}
}
```



# 18 在二叉树中找到两个节点的最近公共祖先

**题目**

给定一棵二叉树的头节点head，以及这棵树的两个节点o1和o2，请返回o1和o2的最近公共祖先。

**进阶**

如果查询两个节点的最近公共祖先的操作十分频繁，想法让单条查询的查询时间减少。

```java
public class Code_18_LowestAncestor {

	public Node lowestAncestor(Node head, Node o1, Node o2) {
		if (head == null || head == o1 || head == o2) {
			return head;
		}
		// 先遍历左右子树
		Node left = lowestAncestor(head.left, o1, o2);
		Node right = lowestAncestor(head.right, o1, o2);
		if (left != null && right != null) { // 左右都不为空则第一次相遇返回头节点
			return head;
		}
		return left != null ? left : right; // 其中有空则返回非空返回值
	}
}
```

```java
// 创造记录以加速查询
public class Record {
    private HashMap<Node, Node> map; // 记录每个节点的头节点

    public Record(Node head) {
        map = new HashMap<>();
        if (head != null) {
            map.put(head, null);
        }
        setMap(head);
    }

    // 设置map的值
    private void setMap(Node head) {
        if (head == null) {
            return;
        }
        if (head.left != null) {
            map.put(head.left, head);
        }
        if (head.right != null) {
            map.put(head.right, head);
        }
        setMap(head.left);
        setMap(head.right);
    }

    public Node query(Node o1, Node o2) {
        HashSet<Node> path = new HashSet<>();
        // 将o1到根节点的所有节点存入set
        while (map.containsKey(o1)) {
            path.add(o1);
            o1 = map.get(o1);
        }
        // 查找公共祖先
        while (!path.contains(o2)) {
            o2 = map.get(o2);
        }
        return o2;
    }
}
```



# 19 Tarjan算法与并查集解决二叉树节点间最近公共祖先的批量查询问题

**题目**

定义Query类如下：

```java
public class Query {
    public Node o1;
    public Node o2;

    public Query(Node o1, Node o2) {
        this.o1 = o1;
        this.o2 = o2;
    }
}
```

一个Query类的实例表示一条查询语句，表示想要查询o1节点和o2节点的最近公共祖先节点。

给定一棵二叉树的头节点head，并给定所有的查询语句，即一个Query类型的数组Query[] ques，请返回Node类型的数组Node[] ans，ans[i]代表ques[i]这条查询的答案。

**要求**

如果二叉树的节点个数为N，查询语句的条数为M，整个处理过程的时间复杂度要求达到o(N+M)。

```java
// 并查集结构
public class DisjointSets {
    public HashMap<Node, Node> fatherMap; // 记录每个节点的父节点
    public HashMap<Node, Integer> rankMap; // 记录每个节点的秩（节点下面的层数）

    public DisjointSets() {
        fatherMap = new HashMap<>();
        rankMap = new HashMap<>();
    }

    // 初始化
    public void makeSets(Node head) {
        fatherMap.clear();
        rankMap.clear();
        preOrderMake(head);
    }

    // 每个节点各自组成一个集合
    private void preOrderMake(Node head) {
        if (head == null) {
            return;
        }
        fatherMap.put(head, head);
        rankMap.put(head, 0);
        preOrderMake(head.left);
        preOrderMake(head.right);
    }

    // 找到某个节点所在集合的代表节点
    public Node findFather(Node n) {
        Node father = fatherMap.get(n);
        if (father != n) {
            father = findFather(father);
        }
        fatherMap.put(n, father); // 将查询路径上的点直接挂到代表节点上
        return father;
    }

    // 合并两个节点所在的集合
    public void union(Node a, Node b) {
        if (a == null || b == null) {
            return;
        }
        Node aFather = findFather(a);
        Node bFather = findFather(b);
        if (aFather != bFather) { // 属于两个集合才合并
            int aFrank = rankMap.get(aFather);
            int bFrank = rankMap.get(bFather);
            if (aFrank < bFrank) {
                fatherMap.put(aFather, bFather); // a集合挂到b集合上
            } else if (aFrank > bFrank) {
                fatherMap.put(bFather, aFather); // b集合挂到a集合上
            } else {
                fatherMap.put(bFather, aFather);
                rankMap.put(aFather, aFrank + 1);// 需要更新rank值
            }
        }
    }
}
```

```java
public Node[] tarJanQuery(Node head, Query[] queries) {
    Node[] ans = new Tarjan().query(head, queries);
    return ans;
}

public class Tarjan {
    private HashMap<Node, LinkedList<Node>> queryMap; // 表示和节点key有查询的节点列表
    private HashMap<Node, LinkedList<Integer>> indexMap;// 表示和节点key有查询的节点对应的结果存入的位置
    private HashMap<Node, Node> ancestorMap; // 表示以节点key为代表节点的集合的祖先节点
    private DisjointSets sets; // 并查集结构

    public Tarjan() {
        queryMap = new HashMap<>();
        indexMap = new HashMap<>();
        ancestorMap = new HashMap<>();
        sets = new DisjointSets();
    }

    public Node[] query(Node head, Query[] ques) {
        Node[] ans = new Node[ques.length]; // 结果数组
        setQueries(ques, ans);
        sets.makeSets(head);
        setAnswers(head, ans);
        return ans;
    }

    public void setQueries(Query[] ques, Node[] ans) {
        Node o1 = null;
        Node o2 = null; // 待查询的两个节点
        // 循环进行每条查询
        for (int i = 0; i != ans.length; i++) {
            o1 = ques[i].o1;
            o2 = ques[i].o2;
            if (o1 == o2 || o1 == null || o2 == null) {
                ans[i] = o1 != null ? o1 : o2; // 可以直接得到
            } else {
                if (!queryMap.containsKey(o1)) { // 没有查询记录则添加
                    queryMap.put(o1, new LinkedList<Node>());
                    indexMap.put(o1, new LinkedList<Integer>());
                }
                if (!queryMap.containsKey(o2)) { // 没有查询记录则添加
                    queryMap.put(o2, new LinkedList<Node>());
                    indexMap.put(o2, new LinkedList<Integer>());
                }
                // 添加查询记录
                queryMap.get(o1).add(o2);
                indexMap.get(o1).add(i);
                queryMap.get(o2).add(o1);
                indexMap.get(o2).add(i);
            }
        }
    }

    public void setAnswers(Node head, Node[] ans) {
        if (head == null) {
            return;
        }
        // 整个处理过程是“左根右根”的顺序
        setAnswers(head.left, ans); // 先处理左子树
        sets.union(head.left, head); // 合并处理完的左子树和头节点
        ancestorMap.put(sets.findFather(head), head); // 将以head为代表节点的集合的祖先设置为head
        setAnswers(head.right, ans); // 再处理右子树
        sets.union(head.right, head);
        ancestorMap.put(sets.findFather(head), head);

        LinkedList<Node> nList = queryMap.get(head);
        LinkedList<Integer> iList = indexMap.get(head); // 和head节点有关的查询

        Node node = null;
        Node nodeFather = null;
        int index = 0;
        // 含有查询操作
        while (nList != null && !nList.isEmpty()) {
            node = nList.poll(); // 针对head和node的查询
            index = iList.poll();
            nodeFather = sets.findFather(node); // 找到node节点的代表节点
            if (ancestorMap.containsKey(nodeFather)) { // 含有祖先记录
                ans[index] = ancestorMap.get(nodeFather);
            }
        }
    }
}
```



# 20 二叉树节点间的最大距离问题

**题目**

从二叉树的节点A出发，可以向上或者向下走，但只能经过一次，当到达节点B时，路径上的节点数叫做A到B的距离。

**要求**

如果二叉树的节点数为N，时间复杂度要求为o(N)。

```java
public class Code_20_MaxDistance {

	public int maxDistance(Node head) {
		int[] record = new int[1];
		return posOrder(head, record);
	}

	// 返回值是最大距离
	public int posOrder(Node head, int[] record) {
		if (head == null) {
			record[0] = 0;
			return 0;
		}
		int lMax = posOrder(head.left, record); //
		int maxFromLeft = record[0]; // 距离左孩子的最远距离
		int rMax = posOrder(head.right, record);
		int maxFromRight = record[0];// 距离右孩子的最远距离
		int curNodeMax = maxFromLeft + maxFromRight + 1; // 经过根节点的最远距离
		record[0] = Math.max(maxFromRight, maxFromLeft) + 1; // 更新距离根节点的最远距离
		return Math.max(Math.max(lMax, rMax), curNodeMax);// 返回距离最大值
	}
}
```



# 21 先序、中序和后序数组两两结合重构二叉树

**题目**

已知一棵二叉树的所有节点值都不同，给定这棵二叉树正确的先序、中序和后序数组。分别实现三个函数实现任意两种数组集合重构原来的二叉树，并返回重构二叉树的头节点。

```java
// 通过先序和中序重建二叉树
public Node preInToTree(int[] pre, int[] in) {
    if (pre == null || in == null) {
        return null;
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < in.length; i++) {
        map.put(in[i], i); // 中序每个节点的位置
    }
    return preIn(pre, 0, pre.length - 1, in, 0, in.length - 1, map);
}

public Node preIn(int[] p, int pi, int pj, int[] n, int ni, int nj, HashMap<Integer, Integer> map) {
    if (pi > pj) {
        return null;
    }
    Node head = new Node(p[pi]); // 先序第一个是根节点
    int index = map.get(p[pi]); // 在中序中快速找到根节点的位置
    head.left = preIn(p, pi + 1, pi + index - ni, n, ni, index - 1, map); // 递归左子树
    head.right = preIn(p, pi + index - ni + 1, pj, n, index + 1, nj, map);// 递归右子树
    return head;
}
```

```java
// 通过中序和后序重建二叉树
public Node inPosToTree(int[] pre, int[] in) {
    if (pre == null || in == null) {
        return null;
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < in.length; i++) {
        map.put(in[i], i); // 中序每个节点的位置
    }
    return inPos(pre, 0, pre.length - 1, in, 0, in.length - 1, map);
}

public Node inPos(int[] n, int ni, int nj, int[] s, int si, int sj, HashMap<Integer, Integer> map) {
    if (si > sj) {
        return null;
    }
    Node head = new Node(s[sj]); // 后序第一个是根节点
    int index = map.get(s[sj]); // 在中序中快速找到根节点的位置
    head.left = inPos(n, ni, index - 1, s, si, si + index - ni - 1, map); // 递归左子树
    head.right = inPos(n, index + 1, nj, s, si + index - ni, sj - 1, map);// 递归右子树
    return head;
}
```

```java
// 每个节点的孩子数都为0或者2的二叉树才能被先序和后序重建出来
public Node prePosToTree(int[] pre, int[] pos) {
    if (pre == null || pos == null) {
        return null;
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < pos.length; i++) {
        map.put(pos[i], i); // 中序每个节点的位置
    }
    return inPos(pre, 0, pre.length - 1, pos, 0, pos.length - 1, map);
}

public Node prePos(int[] p, int pi, int pj, int[] s, int si, int sj, HashMap<Integer, Integer> map) {
    Node head = new Node(s[sj--]); // 后序第一个节点是根节点
    if (pi == pj) {
        return head;
    }
    int index = map.get(p[++pi]); // 左子树的根节点
    head.left = prePos(p, pi, pi + index - si, s, si, index, map);
    head.right = prePos(p, pi + index - si + 1, pj, s, index + 1, sj, map);
    return head;
}
```



# 22 通过先序和中序数组生成后序数组

**题目**

已知一棵二叉树所有的节点值都不同，给定这棵树正确的先序和中序数组，通过这两个数组直接生成正确的后序数组。

```java
public class Code_22_GetPosArray {

	public int[] getPosArray(int[] pre, int[] in) {
		if (pre == null || in == null) {
			return null;
		}
		int len = pre.length;
		int[] pos = new int[len];
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int i = 0; i < len; i++) {
			map.put(in[i], i); // 构建中序map方便快速查找
		}
		setPos(pre, 0, len - 1, in, 0, len - 1, pos, len - 1, map);
		return pos;
	}

	// 从右往左一次填好后序数组s
	// si为后序数组s该填的位置
	// 返回值为s该填的下一个位置
	public int setPos(int[] p, int pi, int pj, int[] n, int ni, int nj, int[] s, int si,
			HashMap<Integer, Integer> map) {
		if (pi > pj) {
			return si;
		}
		s[si--] = p[pi]; // 先序的第一个节点是后序的最后一个节点
		int i = map.get(p[pi]); // 快速找到根节点在中序中的位置
		si = setPos(p, pj - nj + i + 1, pj, n, i + 1, nj, s, si, map); // 先处理右子树
		return setPos(p, pi + 1, pi + i - ni, n, ni, i - 1, s, si, map); // 再处理左子树
	}
}
```



# 23 统计和生成所有不同的二叉树

**题目**

给定一个整数N，如果N<1，代表空树结构，否则代表中序遍历的结果为{1，2，3，...，N}，请返回可能的二叉树结构有多少。

**进阶**

N的含义不变，假设可能的二叉树结构有M种，请返回M个二叉树的头节点，每一棵二叉树代表一种可能的结构。

```java
public class Code_23_NumTrees {

	public int numTrees(int n) {
		if (n < 2) {
			return 1;
		}
		int[] num = new int[n + 1];
		num[0] = 1;
		for (int i = 1; i < n + 1; i++) { // 以i为头节点
			for (int j = 1; j < i + 1; j++) {
				num[i] += num[j - 1] * num[i - j];// 分别代表左右子树的节点个数
			}
		}
		return num[n];
	}
}
```

```java
public List<Node> generateTrees(int n) {
    return generate(1, n);
}

public List<Node> generate(int start, int end) {
    List<Node> res = new LinkedList<>();
    if (start > end) {
        res.add(null);
    }
    Node head = null;
    for (int i = start; i < end + 1; i++) {
        head = new Node(i);
        List<Node> lSubs = generate(start, i - 1); // 递归左子树
        List<Node> rSubs = generate(i + 1, end); // 递归右子树
        // i为头节点的前提下，左右分别配对
        for (Node l : lSubs) {
            for (Node r : rSubs) {
                head.left = l;
                head.right = r;
                res.add(cloneTree(head));
            }
        }
    }
    return res;
}

public Node cloneTree(Node head) {
    if (head == null) {
        return null;
    }
    Node res = new Node(head.value);
    res.left = cloneTree(head.left);
    res.right = cloneTree(head.right);
    return res;
}
```



# 24 统计完全二叉树的节点数

**题目**

给定一棵完全二叉树的头节点head，返回这棵树的节点个数。

**要求**

如果完全二叉树的节点个数为N，请实现时间复杂度低于o(N)的解法。

```java
public class Code_24_NodeNum {

	public int nodeNum(Node head) {
		if (head == null) {
			return 0;
		}
		return bs(head, 1, mostLeftLevel(head, 1));
	}

	public int bs(Node node, int l, int h) {
		if (l == h) {
			return 1;
		}
		if (mostLeftLevel(node.right, l + 1) == h) { // 右子树最左节点到底说明左子树是层数h-1的满二叉树
			return (1 << (h - l)) + bs(node.right, l + 1, h);
		} else { // 右子树没到底则右子树是层数h-2的满二叉树
			return (1 << (h - l - 1) + bs(node.left, l + 1, h));
		}
	}

	// 返回最左节点的深度
	public int mostLeftLevel(Node node, int level) {
		while (node != null) {
			level++;
			node = node.left;
		}
		return level - 1;
	}
}
```

