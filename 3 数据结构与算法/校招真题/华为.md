## 1 字符串最后一个单词的长度

计算字符串最后一个单词的长度，单词以空格隔开。 

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String line = scan.nextLine();
		String[] arr = line.split(" ");
		System.out.println(arr[arr.length - 1].length());
	}
}
```

## 2 计算字符个数

写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		String all = "";
		String one = "";
		char[] ac;
		int num = 0;
		while (s.hasNext()) {
			all = s.nextLine();
			one = s.nextLine();
			ac = all.toCharArray();
			for (int i = 0; i < ac.length; i++) {
				if (one.equalsIgnoreCase(String.valueOf(ac[i])))
					num++;
			}
			System.out.println(num);
		}
	}
}
```

## 3 明明的随机数

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			TreeSet<Integer> set = new TreeSet<Integer>(); // TreeSet自动排序去重
			int n = sc.nextInt(); // 整数的个数
			if (n > 0) {
				for (int i = 0; i < n; i++) {
					set.add(sc.nextInt());
				}
			}
			for (Integer i : set) {
				System.out.println(i);
			}
		}
	}
}
```

## 4 字符串分隔

- 连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； 
- 长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String s = new String(sc.nextLine());
			if (s.length() % 8 != 0) {
				s = s + "00000000";
			}
			while (s.length() >= 8) {
				System.out.println(s.substring(0, 8));
				s = s.substring(8);
			}
		}
	}
}
```

## 5 进制转换

写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ）

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String str = sc.next().substring(2);
			System.out.println(Integer.parseInt(str, 16));
		}
	}
}
```

## 6 质数因子

输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ），最后一个数后面也要有空格。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		long number = 0;
		while (scanner.hasNextLong()) {
			number = scanner.nextLong();
			isPrimerFactors(number);
		}
	}

	private static void isPrimerFactors(long num) {
		long number = num;
		while (number != 1) {
			for (int i = 2; i <= number; i++) {
				if (number % i == 0) {
					number /= i;
					System.out.print(i + " ");
					break;
				}
			}
		}
	}
}
```

## 7 取近似值

写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		while (scan.hasNext()) {
			double d = scan.nextDouble();
			System.out.println(Math.round(d));
		}
	}
}
```

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		while (scan.hasNext()) {
			double d = scan.nextDouble();
			int dint = (int) d;
			if ((d - dint) >= 0.5 && (d - dint) < 1)
				dint++;
			System.out.println(dint);
		}
	}
}
```

## 8 合并表记录

数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		TreeMap<Integer, Integer> map = new TreeMap<>();
		int size = sc.nextInt();
		while (sc.hasNext()) {
			int key = sc.nextInt();
			int value = sc.nextInt();
			if (map.containsKey(key)) {
				map.put(key, value + map.get(key));
			} else {
				map.put(key, value);
			}
		}
		for (Integer key : map.keySet()) {
			System.out.println(key + " " + map.get(key));
		}
	}
}
```

## 9 提取不重复的整数

输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String str = sc.next();
			String a = str.substring(str.length() - 1);
			for (int i = str.length() - 2; i >= 0; i--) {
				if (!a.contains(str.substring(i, i + 1))) {
					a += str.substring(i, i + 1);
				}
			}
			System.out.println(a);
		}
	}
}
```

## 10 字符个数统计

编写一个函数，计算字符串中含有的不同字符的个数。字符在ACSII码范围内(0~127)。不在范围内的不作统计。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String str = sc.nextLine();
			char[] chs = str.toCharArray();
			HashSet<Character> set = new HashSet<>();
			for (int i = 0; i < chs.length; i++) {
				set.add(chs[i]);
			}
			System.out.println(set.size());
		}
		sc.close();
	}
}
```

## 11 数字颠倒

输入一个整数，将这个整数以字符串的形式逆序输出。

程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int num = sc.nextInt();
			String res = "";
			while (num != 0) {
				int t1 = num % 10;
				int t2 = num / 10;
				res = res + String.valueOf(t1);
				num = t2;
			}
			System.out.println(res);
		}
	}
}
```

## 12 字符串反转

写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String str = sc.nextLine();
			StringBuffer sb = new StringBuffer(str);
			sb.reverse();
			System.out.println(sb.toString());
		}
	}
}
```

## 13 句子逆序

将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”

所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			String strs = sc.nextLine();
			String[] s = strs.split(" ");
			for (int i = s.length - 1; i >= 0; i--) {
				System.out.print(s[i] + " ");
			}
		}
	}
}
```

## 14 字符串字典序排序

给定n个字符串，请对n个字符串按照字典序排列。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int n = sc.nextInt();
			String[] s = new String[n];
			for (int i = 0; i < n; i++) {
				s[i] = sc.next();
			}
			Arrays.sort(s);
			for (int i = 0; i < n; i++) {
				System.out.println(s[i]);
			}
		}
	}
}
```

## 15 求int型正整数在内存中存储时1的个数

输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int n = sc.nextInt();
			int count = 0;
			while (n > 0) {
				if ((n & 1) > 0)
					count++;
				n = n >> 1;
			}
			System.out.println(count);
		}
	}
}
```

## 16 购物单

王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件   | 附件           |
| ------ | -------------- |
| 电脑   | 打印机，扫描仪 |
| 书柜   | 图书           |
| 书桌   | 台灯，文具     |
| 工作椅 | 无             |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 **~** 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j1,j2 ……jk ，则所求的总和为：

v[j1]\*w[j1]+v[j2]\*w[j 2 ]+ … +v[jk]\*w[jk] 

请你帮助王强设计一个满足要求的购物单。

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt(); // 总钱数
		int m = sc.nextInt(); // 商品个数
		int[][] price = new int[m + 1][3]; // 价格
		int[][] value = new int[m + 1][3]; // 价值
		int[][] dp = new int[m + 1][n + 1]; // 前i个商品在钱数j的前提下可以获得的最大价值
		int p, v, q;
		// int index = 1;
		// 存储清单
		for (int i = 1; i <= m; i++) {
			p = sc.nextInt(); // 价格
			v = sc.nextInt() * p; // 价值
			q = sc.nextInt(); // 主or附件
			if (q == 0) { // 主件
				price[i][0] = p;
				value[i][0] = v;
			} else { // 附件
				if (price[q][1] == 0) {
					price[q][1] = p;
					value[q][1] = v;
				} else {
					price[q][2] = p;
					value[q][2] = v;
				}
			}
		}
		// 遍历计算
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				if (j >= price[i][0]) // 可以容下第i个主件时,比较放第i个或者不放第i个物品的价值
					dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - price[i][0]] + value[i][0]);

				if (j >= price[i][0] + price[i][1]) // 可以容下第i个主件和此主件的第1个附件时
					dp[i][j] = Math.max(dp[i - 1][j],
							dp[i - 1][j - price[i][0] - price[i][1]] + value[i][0] + value[i][1]);

				if (j >= price[i][0] + price[i][2]) // 可以容下第i个主件和此主件的第2个附件时
					dp[i][j] = Math.max(dp[i - 1][j],
							dp[i - 1][j - price[i][0] - price[i][2]] + value[i][0] + value[i][2]);

				if (j >= price[i][0] + price[i][1] + price[i][2]) // 可以容下第i个主件和此主件的第1个附件和第2个附件时
					dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - price[i][0] - price[i][1] - price[i][2]]
							+ value[i][0] + value[i][1] + value[i][2]);
			}
		}
		System.out.println(dp[m][n]);
	}

}
```

## 17 坐标移动

开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while (in.hasNext()) {
			String s = in.nextLine();
			String[] str = s.split(";");
			int row = 0;
			int column = 0;
			for (int i = 0; i < str.length; i++) {
				if (str[i].length() <= 3) {
					if (str[i].charAt(0) == 'A' && str[i].substring(1).matches("[0-9]+")) {
						row -= Integer.parseInt(str[i].substring(1));
					}

					if (str[i].charAt(0) == 'D' && str[i].substring(1).matches("[0-9]+")) {
						row += Integer.parseInt(str[i].substring(1));
					}

					if (str[i].charAt(0) == 'W' && str[i].substring(1).matches("[0-9]+")) {
						column += Integer.parseInt(str[i].substring(1));
					}

					if (str[i].charAt(0) == 'S' && str[i].substring(1).matches("[0-9]+")) {
						column -= Integer.parseInt(str[i].substring(1));
					}
				}
			}

			System.out.println(row + "," + column);
		}

	}
}
```

## 18 识别有效的IP地址

请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。

所有的IP地址划分为 A,B,C,D,E五类

- A类地址1.0.0.0~126.255.255.255;
- B类地址128.0.0.0~191.255.255.255;
- C类地址192.0.0.0~223.255.255.255;
- D类地址224.0.0.0~239.255.255.255；
- E类地址240.0.0.0~255.255.255.255

私网IP范围是：

- 10.0.0.0～10.255.255.255
- 172.16.0.0～172.31.255.255
- 192.168.0.0～192.168.255.255

子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int typeA = 0;
		int typeB = 0;
		int typeC = 0;
		int typeD = 0;
		int typeE = 0;
		int errorIpOrMaskCode = 0;
		int privIp = 0;
		while (sc.hasNext()) {
			String ipt = sc.nextLine();
			String[] ipAndMaskCode = ipt.split("~");
			String ip = ipAndMaskCode[0];
			String maskCode = ipAndMaskCode[1];
			// 格式判断
			if (!isValidFormat(ip) || !isValidFormat(maskCode)) {
				errorIpOrMaskCode++;
				continue;
			}
			// 判断掩码是否错误
			if (!validMaskCode(maskCode)) {
				errorIpOrMaskCode++;
				continue;
			}
			// 判断ip类别
			String fnStr = ip.substring(0, ip.indexOf("."));
			int fn = Integer.valueOf(fnStr);
			if (fn >= 1 && fn < 127) {
				// A
				typeA++;
			} else if (fn >= 128 && fn < 192) {
				// B
				typeB++;
			} else if (fn >= 192 && fn < 224) {
				// C
				typeC++;
			} else if (fn >= 224 && fn < 240) {
				// D
				typeD++;
			} else if (fn >= 240 && fn <= 255) {
				// E
				typeE++;
			}
			// 判断是否是私网IP
			String ipSubStr = ip.substring(ip.indexOf(".") + 1);
			String snStr = ipSubStr.substring(0, ipSubStr.indexOf("."));
			int sn = Integer.valueOf(snStr);
			if (fn == 10 || (fn == 172 && sn >= 16 && sn <= 31) || (fn == 192 && sn == 168)) {
				privIp++;
			}
		}
		sc.close();
		System.out.println(
				typeA + " " + typeB + " " + typeC + " " + typeD + " " + typeE + " " + errorIpOrMaskCode + " " + privIp);
	}

	private static boolean isValidFormat(String ip) {
		if (ip == null || "".equals(ip))
			return false;
		String[] ips = ip.split("\\.");
		if (ips.length != 4) {
			return false;
		}
		for (String s : ips) {
			int n = Integer.valueOf(s);
			if (n < 0 || n > 255) {
				return false;
			}
		}
		return true;
	}

	private static boolean validMaskCode(String maskCode) {
		String[] nums = maskCode.split("\\.");
		StringBuilder sb = new StringBuilder();
		for (String num : nums) {
			int n = Integer.valueOf(num);
			sb.append(binaryString(n));
		}
		int firstIndexOf0 = sb.indexOf("0");
		int lastIndexOf1 = sb.lastIndexOf("1");
		if (firstIndexOf0 < lastIndexOf1) {
			return false;
		}
		return true;
	}

	private static String binaryString(int num) {
		StringBuilder result = new StringBuilder();
		int flag = 1 << 7;
		for (int i = 0; i < 8; i++) {
			int val = (flag & num) == 0 ? 0 : 1;
			result.append(val);
			num <<= 1;
		}
		return result.toString();
	}
}
```

## 19 简单错误记录

开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。

1. 记录最多8条错误记录，循环记录，对相同的错误记录（净文件名称和行号完全匹配）只记录一条，错误计数增加；
2. 超过16个字符的文件名称，只记录文件的最后有效16个字符；
3. 输入的文件可能带路径，记录文件名称不能带路径。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		Map<String, Integer> map = new LinkedHashMap<String, Integer>();
		while (sc.hasNext()) {
			String str = sc.next();
			int linenum = sc.nextInt();
			String[] arr = str.split("\\\\"); // 根据\切割
			String s = arr[arr.length - 1];
			if (s.length() > 16) // 截取
				s = s.substring(s.length() - 16);
			String key = s + " " + linenum;
			int value = 1;
			if (map.containsKey(key))
				map.put(key, map.get(key) + 1);
			else {
				map.put(key, value);
			}
		}
		int count = 0;
		for (String string : map.keySet()) {
			count++;
			if (count > (map.keySet().size() - 8)) // 输出最后八个记录
				System.out.println(string + " " + map.get(string));
		}
	}
}
```

## 20 密码验证合格程序

密码要求:

1. 长度超过8位
2. 包括大小写字母.数字.其它符号,以上四种至少三种
3. 不能有相同长度超2的子串重复

说明:长度超过2的子串

```java
import java.util.*;

public class Main {
	// 1.长度超过8位
	public static boolean checkLength(String password) {
		if (password == null || password.length() <= 8)
			return false;
		return true;
	}

	// 2.包括大小写字母.数字.其它符号,以上四种至少三种
	public static boolean checkCharKinds(String password) {
		int Digit = 0, lowercase = 0, uppercase = 0, others = 0;
		char[] ch = password.toCharArray();
		for (int i = 0; i < ch.length; i++) {
			if (ch[i] >= '0' && ch[i] <= '9') {
				Digit = 1;
				continue;
			} else if (ch[i] >= 'a' && ch[i] <= 'z') {
				lowercase = 1;
				continue;
			} else if (ch[i] >= 'A' && ch[i] <= 'Z') {
				uppercase = 1;
				continue;
			} else {
				others = 1;
				continue;
			}
		}
		int total = Digit + lowercase + uppercase + others;
		return total >= 3 ? true : false;
	}

	// 3.不能有相同长度超2的子串重复
	public static boolean checkCharRepeat(String password) {
		for (int i = 0; i < password.length() - 2; i++) {
			String substr1 = password.substring(i, i + 3);
			if (password.substring(i + 1).contains(substr1))
				return false;
		}
		return true;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNextLine()) {
			String psw = sc.nextLine();
			if (checkLength(psw) && checkCharKinds(psw) && checkCharRepeat(psw))
				System.out.println("OK");
			else
				System.out.println("NG");
		}
	}
}
```

## 21 简单密码

密码变换规则：

- 1--1，abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0；
- 小写字母都变成对应的数字，数字和其他的符号都不做变换；
- 密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位；

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		System.out.println(password(sc.next()));
	}

	public static String password(String str) {
		if (str == null || "".equals(str))
			return str;
		char[] nums = str.toCharArray();
		StringBuilder sb = new StringBuilder();
		for (char c : nums) {
			if (c >= 'a' && c <= 'z') {
				if (c == 's' || c == 'v' || c == 'y' || c == 'z')
					sb.append((c - 'a') / 3 + 1);
				else
					sb.append((c - 'a') / 3 + 2);
			} else if (c >= 'A' && c <= 'Z') {
				if (c == 'Z')
					sb.append('a');
				else
					sb.append((char) (c + 'a' - 'A' + 1));
			} else {
				sb.append(c);
			}
		}
		return sb.toString();
	}

}
```

## 22 汽水瓶

某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int blank = sc.nextInt();
			int drink = 0;
			int remain;
			if (blank > 0 && blank <= 100) {
				if (blank == 1) {
					drink = 0;
				} else if (blank == 2) {
					drink = 1;
				}
				while (blank > 2) { // 10,4,5
					drink += blank / 3; // 3 drink,4 drink
					remain = blank % 3; // 1 remain,1 remain
					blank = blank / 3 + remain; // 4 blank,2 blank
					if (blank == 2) {
						drink++;
					}
				}
			}
			System.out.println(drink + "");
		}
	}
}
```

## 23 删除字符串中出现次数最少的字符

实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int[] num = new int[26];
			String line = sc.nextLine();
			for (int i = 0; i < line.length(); i++) {
				char c = line.charAt(i);
				int n = (int) (c - 'a');
				num[n]++;
			}
			int min = Integer.MAX_VALUE;
			for (int i = 0; i < 26; i++) {
				if (num[i] != 0 && num[i] < min) {
					min = num[i];
				}
			}
			for (int i = 0; i < line.length(); i++) {
				char c = line.charAt(i);
				int n = (int) (c - 'a');
				if (num[n] != min) {
					System.out.print(c);
				}
			}
			System.out.println();
		}
	}
}
```

## 24 合唱队

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。 

合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，   则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1\<Ti>Ti+1>......>TK。 

已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

```java
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (sc.hasNext()) {
			int num = sc.nextInt();
			if (num <= 2) {
				System.out.println(0);
			}
			int[] members = new int[num];// 存储每一个数据元素
			int[] left_queue = new int[num];// 数据元素从左到右对应的最大递增子序列数
			int[] right_queue = new int[num];// 数据元素从右到左对应的最大递增子序列数
			// 初始化各个数组数据
			for (int i = 0; i < num; i++) {
				members[i] = sc.nextInt();
				left_queue[i] = 1;
				right_queue[i] = 1;
			}
			// 从左到右
			for (int i = 0; i < num; i++) {
				for (int j = 0; j < i; j++) {
					if (members[i] > members[j] && left_queue[j] + 1 > left_queue[i])
						left_queue[i] = left_queue[j] + 1;
				}
			}
			// 从右到左
			for (int i = num - 1; i >= 0; i--) {
				for (int j = num - 1; j > i; j--) {
					if (members[i] > members[j] && right_queue[j] + 1 > right_queue[i])
						right_queue[i] = right_queue[j] + 1;
				}
			}

			int max = 0; // 最长的子串
			for (int i = 0; i < num; i++) {
				if (left_queue[i] + right_queue[i] > max)
					max = left_queue[i] + right_queue[i];
			}
			System.out.println(num - max + 1); // 需要出队的人
		}
	}
}
```



