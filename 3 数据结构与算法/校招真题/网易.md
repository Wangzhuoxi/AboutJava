### 1 牛牛找工作

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();    //工作数量
        int m = sc.nextInt();    //人数
        TreeMap<Integer,Integer> map = new TreeMap<>();    //<工作-报酬>
        int[][] arr = new int[n][2];    //<工作-报酬>
        for(int i = 0;i < n;i++){
            arr[i][0] = sc.nextInt();
            arr[i][1] = sc.nextInt();
        }
        Arrays.sort(arr,(e1,e2)->(int)(e1[0]-e2[0]));    //按照工作难度排序
        // 更新每个难度值对应的报酬为不高于其难度值的所有报酬中最高的报酬
        for(int i =1;i <arr.length;i++){
            arr[i][1] = Math.max(arr[i-1][1],arr[i][1]);
        }
        for(int i = 0;i <arr.length;i++){
            map.put(arr[i][0],arr[i][1]);
        }
        for(int i =0;i<m;i++){
            int ability = sc.nextInt();
            Integer index = map.floorKey(ability);    //不高于ability的最高索引
            if(index!=null){
                System.out.println(map.get(index));
            }else{
                System.out.println(0);
            }
        }
    }
}
```

### 2 被3整除

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		while (input.hasNext()) {
			int l = input.nextInt();
			int r = input.nextInt();
			long sum = 0;
			for (int i = 1; i < l; i++) {
				sum += i;
			}
			int count = 0;
			for (int i = l; i <= r; i++) {
				sum += i;
				if (sum % 3 == 0)
					count++;
			}
			System.out.println(count);
		}
		input.close();
	}
}
```

### 3 安置路灯

小Q正在给一条长度为n的道路设计路灯安置方案。

为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用'.'表示, 不需要照亮的障碍物格子用'X'表示。

小Q现在要在道路上设置一些路灯, 对于安置在pos位置的路灯, 这盏路灯可以照亮pos - 1, pos, pos + 1这三个位置。

小Q希望能安置尽量少的路灯照亮所有'.'区域, 希望你能帮他计算一下最少需要多少盏路灯。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		for (int i = 0; i < t; i++) { // 循环每个测试用例
			int n = sc.nextInt();
			String str = sc.next();
			int count = 0;
			for (int j = 0; j < n; j++) {
				if (str.charAt(j) == '.') {
					count++;
					j += 2; // 跳过3个位置
				}
				// X直接跳到下一个位置
			}
			System.out.println(count);
		}
		sc.close();
	}
}
```

### 4 迷路的牛牛

牛牛去犇犇老师家补课，出门的时候面向北方，但是现在他迷路了。虽然他手里有一张地图，但是他需要知道自己面向哪个方向，请你帮帮他。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		String s = sc.next();
		int count = 0;
		for (int i = 0; i < N; i++) {
			if (s.charAt(i) == 'R') // 右转（正）
				count++;
			else // 左转（负）
				count--;
			// 限制在[-4,4]之间
			if (count > 4)
				count = count - 4;
			if (count < -4)
				count = count + 4;
		}
		if (count < 0)
			count = count + 4;
		switch (count) {
		case 0:
			System.out.println("N");
			break;
		case 1:
			System.out.println("E");
			break;
		case 2:
			System.out.println("S");
			break;
		default:
			System.out.println("W");
		}
		sc.close();
	}
}
```

### 5 数对

牛牛以前在老师那里得到了一个正整数数对(x, y), 牛牛忘记他们具体是多少了。

但是牛牛记得老师告诉过他x和y均不大于n, 并且x除以y的余数大于等于k。

牛牛希望你能帮他计算一共有多少个可能的数对。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		long n = sc.nextInt();
		long k = sc.nextInt();
		long ans = 0L;
		if (k == 0) {
			ans = n * n; // 任何两对数的余数都是大于等于零
		} else {
			for (long y = k + 1; y <= n; y++) {
				ans += (n / y) * (y - k) + Math.max(0, n % y - k + 1);
				// 假设n=10,k=3，则对y来说只能是4,5,6,7,8,9,10
				// 当y=4,(n/y)*(y-k)代表x小于等于8(8是4的整数倍)时有(3,4),(7,4)，Math.max(0,n%y-k+1)代表x大于8时符合题意的对数为0
				// 当y=5,(n/y)*(y-k)代表x小于等于10(10是5的整数倍)时有(3,5),(4,5),(8,5),(9,5)，Math.max(0,n%y-k+1)代表x大于10时符合题意的对数为0
				// 当y=6,(n/y)*(y-k)代表x小于等于6时有(3,6),(4,6),(5,6),Math.max(0,n%y-k+1)代表x大于6时符合题意的对数为2,分别是(9,6),(10,6)
				// 当y=7,(n/y)*(y-k)代表x小于等于7时有(3,7),(4,7),(5,7),(6,7),Math.max(0,n%y-k+1)代表x大于7时符合题意的对数为1,是(10,7)
				// ...以此类推
			}
		}
		System.out.println(ans);
		sc.close();
	}
}
```

### 6 矩形重叠

平面内有n个矩形, 第i个矩形的左下角坐标为(x1[i], y1[i]), 右上角坐标为(x2[i], y2[i])。

如果两个或者多个矩形有公共区域则认为它们是相互重叠的(不考虑边界和角落)。

请你计算出平面内重叠矩形数量最多的地方,有多少个矩形相互重叠。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] x1 = new int[n];
		int[] y1 = new int[n];
		int[] x2 = new int[n];
		int[] y2 = new int[n];
		for (int i = 0; i < n; i++)
			x1[i] = in.nextInt();
		for (int i = 0; i < n; i++)
			y1[i] = in.nextInt();
		for (int i = 0; i < n; i++)
			x2[i] = in.nextInt();
		for (int i = 0; i < n; i++)
			y2[i] = in.nextInt();
		int ans = 0;
		int cnt = 0;
		for (int x : x1)
			for (int y : y1) {
				for (int i = 0; i < n; i++) {
					if (x >= x1[i] && x < x2[i] && y >= y1[i] && y < y2[i])
						cnt++;
				}
				if (cnt > ans)
					ans = cnt;
				cnt = 0;
			}
		System.out.println(ans);
		in.close();
	}
}
```

### 7 牛牛的闹钟

牛牛总是睡过头，所以他定了很多闹钟，只有在闹钟响的时候他才会醒过来并且决定起不起床。从他起床算起他需要X分钟到达教室，上课时间为当天的A时B分，请问他最晚可以什么时间起床。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int h = 0, m = 0;
		int[] a = new int[n];
		for (int i = 0; i < n; i++) {
			h = sc.nextInt();
			m = sc.nextInt();
			a[i] = h * 60 + m;
		}
		int t = sc.nextInt();
		h = sc.nextInt();
		m = sc.nextInt();
		int p = h * 60 + m - t;
		int lastest = Integer.MIN_VALUE;
		for (int i = 0; i < n; i++) {
			if (a[i] > lastest && a[i] <= p)
				lastest = a[i];
		}
		h = lastest / 60;
		m = lastest % 60;
		System.out.print(h + " " + m);
		sc.close();
	}
}
```

### 8 牛牛的背包问题

牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。

牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。

牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。

```java
import java.util.Scanner;

public class Main {
	public static long result = 1;

	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		long total = scanner.nextLong();
		long[] base = new long[n];
		long count = 0;
		for (int i = 0; i < base.length; i++) {
			base[i] = scanner.nextLong();
			count += base[i];
		}
		if (count <= total) {
			System.out.println((int) Math.pow(2, n));
		} else {
			dfs(base, 0, total, 0);
			System.out.println(result);
		}
		scanner.close();
	}

	public static void dfs(long[] base, int index, long total, long current) {
		if (index == base.length) {
			return;
		}
		if (current + base[index] <= total) {
			result++;
			dfs(base, index + 1, total, current + base[index]);
		}
		dfs(base, index + 1, total, current);
	}
}
```

### 9 俄罗斯方块

小易有一个古老的游戏机，上面有着经典的游戏俄罗斯方块。因为它比较古老，所以规则和一般的俄罗斯方块不同。

荧幕上一共有 n 列，每次都会有一个 1 x 1 的方块随机落下，在同一列中，后落下的方块会叠在先前的方块之上，当一整行方块都被占满时，这一行会被消去，并得到1分。

有一天，小易又开了一局游戏，当玩到第 m 个方块落下时他觉得太无聊就关掉了，小易希望你告诉他这局游戏他获得的分数。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
		int m = scanner.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < m; i++) {
			arr[scanner.nextInt() - 1]++;
		}
		Arrays.sort(arr);
		System.out.println(arr[0]);
		scanner.close();
	}
}
```

### 10 瞌睡

小易觉得高数课太无聊了，决定睡觉。不过他对课上的一些内容挺感兴趣，所以希望你在老师讲到有趣的部分的时候叫醒他一下。你知道了小易对一堂课每分钟知识点的感兴趣程度，并以分数量化，以及他在这堂课上每分钟是否会睡着，你可以叫醒他一次，这会使得他在接下来的k分钟内保持清醒。你需要选择一种方案最大化小易这堂课听到的知识点分值。

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int k = scan.nextInt();
		int[] val = new int[n];
		int[] state = new int[n];
		// 保存瞌睡时的累计评分
		int sleep = 0;
		int[] sleepval = new int[n];
		for (int i = 0; i < n; i++) {
			val[i] = scan.nextInt();
		}
		for (int i = 0; i < n; i++) {
			state[i] = scan.nextInt();
			if (state[i] == 0) {
				sleep += val[i];
			}
			sleepval[i] = sleep;
		}
		int res = getMaxVal(val, state, n, k, sleepval);
		System.out.println(res);
		scan.close();
	}

	private static int getMaxVal(int[] val, int[] state, int n, int k, int[] sleepval) {
		int res = 0;
		int addval = 0;
		for (int i = 0; i < n; i++) {
			if (state[i] == 1)
				res += val[i]; // 清醒部分固定分值
			else {
				int wakeval = 0;
				if (i + k - 1 >= n) { // 边界处理
					wakeval = (i > 0) ? (sleepval[n - 1] - sleepval[i - 1]) : sleepval[n - 1];
				} else {
					wakeval = (i > 0) ? (sleepval[i + k - 1] - sleepval[i - 1]) : sleepval[i + k - 1];
				}
				addval = addval >= wakeval ? addval : wakeval;
			}
		}
		return res + addval;
	}
}
```

### 11 丰收

又到了丰收的季节，恰逢小易去牛牛的果园里游玩。

牛牛常说他对整个果园的每个地方都了如指掌，小易不太相信，所以他想考考牛牛。

在果园里有N堆苹果，每堆苹果的数量为ai，小易希望知道从左往右数第x个苹果是属于哪一堆的。

牛牛觉得这个问题太简单，所以希望你来替他回答。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int a[] = new int[n];
		a[0] = sc.nextInt();
		for (int i = 1; i < n; i++) {
			a[i] = a[i - 1] + sc.nextInt();
		}
		int m = sc.nextInt();
		int[] q = new int[m];
		for (int i = 0; i < m; i++) {
			q[i] = sc.nextInt();
		}
		for (int i = 0; i < m; i++) {
			int left = 0, right = n - 1;
			while (left + 1 != right) { // 最后在两个数间判断
				int mid = (left + right) >> 1;
				if (q[i] <= a[mid])
					right = mid;
				else
					left = mid;
			}
			System.out.println(q[i] > a[left] ? right + 1 : left + 1);
		}
		sc.close();
	}
}
```

### 12 整理房间

又到了周末，小易的房间乱得一团糟。

他希望将地上的杂物稍微整理下，使每团杂物看起来都紧凑一些，没有那么乱。

地上一共有n团杂物，每团杂物都包含4个物品。第i物品的坐标用(ai,bi)表示，小易每次都可以将它绕着(xi,yi)逆时针旋转90^ \circ90∘，这将消耗他的一次移动次数。如果一团杂物的4个点构成了一个面积不为0的正方形，我们说它是紧凑的。

因为小易很懒，所以他希望你帮助他计算一下每团杂物最少需要多少步移动能使它变得紧凑。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();

		int[][][] abxy = new int[n][4][4];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < 4; j++) {
				abxy[i][j][0] = sc.nextInt();
				abxy[i][j][1] = sc.nextInt();
				abxy[i][j][2] = sc.nextInt();
				abxy[i][j][3] = sc.nextInt();
			}
		}
		for (int index = 0; index < n; index++) {
			int min = Integer.MAX_VALUE;
			for (int i = 0; i < 4; i++) {
				for (int j = 0; j < 4; j++) {
					for (int k = 0; k < 4; k++) {
						for (int m = 0; m < 4; m++) {
							if (isSquare(rotate(abxy[index][0], i), rotate(abxy[index][1], j),
									rotate(abxy[index][2], k), rotate(abxy[index][3], m))) {
								min = Math.min(min, i + j + k + m);
							}
						}
					}
				}
			}
			if (min == Integer.MAX_VALUE) {
				min = -1;
			}
			System.out.println(min);
		}
		sc.close();
	}

	// 绕xy旋转count次 point长度为4，固定这个长度是因为这样在调用的时候比较方便
	public static int[] rotate(int[] point, int count) {
		int[] res = new int[] { point[2] + point[3] - point[1], point[3] - point[2] + point[0], point[2], point[3] }; // 坐标变换
		if (count == 0) {
			return point;
		} else {
			return rotate(res, count - 1);
		}
	}

	// 判定正方形，一定要判定两个对角边是否相等
	public static boolean isSquare(int[] point1, int[] point2, int[] point3, int[] point4) {
		double[] sideLen = new double[] { distance(point1, point2), distance(point2, point3), distance(point3, point4),
				distance(point4, point1), distance(point1, point3), distance(point2, point4) };
		Arrays.sort(sideLen);
		return sideLen[0] != 0 && sideLen[0] == sideLen[1] && sideLen[1] == sideLen[2] && sideLen[2] == sideLen[3]
				&& sideLen[3] == sideLen[0] && sideLen[4] == sideLen[5];
	}

	private static double distance(int[] fromPoint, int[] toPoint) {
		return Math.pow(fromPoint[0] - toPoint[0], 2) + Math.pow(fromPoint[1] - toPoint[1], 2);
	}
}
```

### 13 表达式求值

今天上课，老师教了小易怎么计算加法和乘法，乘法的优先级大于加法，但是如果一个运算加了括号，那么它的优先级是最高的。例如：

```java
1+2*3=7
1*(2+3)=5
1*2*3=6
(1+2)*3=9
```

现在小易希望你帮他计算给定3个数a，b，c，在它们中间添加"+"，"*"，"("，")"符号，能够获得的最大值。

```java
import java.util.*;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		int x1 = a + b + c;
		int x2 = a * b + c;
		int x3 = a + b * c;
		int x4 = a * b * c;
		int x5 = a * (b + c);
		int x6 = (a + b) * c;
		int[] x = { x1, x2, x3, x4, x5, x6 };
		Arrays.sort(x);
		System.out.println(x[5]);
		sc.close();
	}
}
```

```java
import java.util.*;

public class Main {
    //大致思路，不用考虑括号，最大值一定是由三个数里最大的一个数乘另外两个加或乘的最大值
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] x = new int[3];
        x[0] = sc.nextInt();
        x[1] = sc.nextInt();
        x[2] = sc.nextInt();
        Arrays.sort(x);
        int res = Math.max(x[0]+x[1],x[0]*x[1])*x[2];
        System.out.println(res);
		sc.close();
	}
}
```

### 14 塔

小易有一些立方体，每个立方体的边长为1，他用这些立方体搭了一些塔。

现在小易定义：这些塔的不稳定值为它们之中最高的塔与最低的塔的高度差。

小易想让这些塔尽量稳定，所以他进行了如下操作：每次从某座塔上取下一块立方体，并把它放到另一座塔上。

注意，小易不会把立方体放到它原本的那座塔上，因为他认为这样毫无意义。

现在小易想要知道，他进行了不超过k次操作之后，不稳定值最小是多少。

```java
import java.util.*;

public class Main {
	// 其实很简单，每次排个序，然后从最大堆往最小堆搬一个即可，并记录堆序号，直到最大堆-最小堆<1 或者 移动次数达到k。
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();// 塔的数量
		int k = sc.nextInt();// 最多操作数
		ArrayList<Integer> towers = new ArrayList<>();
		for (int i = 0; i < n; i++)
			towers.add(sc.nextInt());
		int count = 0;
		int max = Collections.max(towers);
		int min = Collections.min(towers);
		ArrayList<Integer> list1 = new ArrayList<>();
		ArrayList<Integer> list2 = new ArrayList<>();
		while (max - min > 1 && count < k) {
			max = Collections.max(towers);
			min = Collections.min(towers);
			list1.add(towers.indexOf(max) + 1);
			list2.add(towers.indexOf(min) + 1);
			towers.set(towers.indexOf(min), min + 1);
			towers.set(towers.indexOf(max), max - 1);
			count++;
		}
		System.out.println(Collections.max(towers) - Collections.min(towers) + " " + count);
		for (int i = 0; i < list1.size(); i++) {
			System.out.println(list1.get(i) + " " + list2.get(i));
		}
		sc.close();
	}
}
```

### 15 小易的字典

小易在学校中学习了关于字符串的理论, 于是他基于此完成了一个字典的项目。

小易的这个字典很奇特, 字典内的每个单词都包含n个'a'和m个'z', 并且所有单词按照字典序排列。

小易现在希望你能帮他找出第k个单词是什么。

```java
import java.util.ArrayList;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int m = scan.nextInt();// a的个数
		int n = scan.nextInt();// z的个数
		long target = scan.nextInt();// 目标第几个
		long k = 0;
		ArrayList<String> list = new ArrayList<String>();
		while (m > 0 && n > 0) {// 当a和z均存在时执行
			k = pz(m - 1, n, target);// 假设a确定，出去a之后剩余a和z的排列组合个数
			if (k >= target) {// 如果确定a之后，剩余的排列组合数大于目标，则说明a已确定
				list.add("a");
				m--;// a的个数减1
			} else {// 如果确定a之后，剩余的排列组合数小于目标，则说明不是a。
				list.add("z");
				n--;// z的个数减1
				target -= k;// 目标减掉排列组合数。因为如果a开头可以有k中情况，
							// 减掉k之后即为确定z开头之后，接下来找第target个即可。
			}
		}
		if (target != 1) {// 存在经过计算之后必为1
			System.out.println("-1");
			return;
		} else {
			while (m > 0) {// 如果z的个数为0，则将a追加到最后即可
				list.add("a");
				m--;
			}
			while (n > 0) {// 如果a的个数为0，则将z追加到最后即可
				list.add("z");
				n--;
			}
		}
		for (int i = 0; i < list.size(); i++) {
			System.out.print(list.get(i));
		}
	}

	public static long pz(int m, int n, long target) {// 计算假设a确定之后，a之后的部分排列组合数
		if (m == 0 || n == 0)
			return 1;
		long sum = m + n;
		long k = 1;
		n = Math.min(m, n);// C(m+n) n=C(m+n) m 取最小即可
		for (int i = 0; i < n; i++) {
			k *= sum - i;
			k /= (i + 1);
			if (k > target)// 防止大数。如果k>target 则只进行list.add("a")和m--//a的个数减1。
							// 没有target -= k;因此不影响
				break;
		}
		return k;
	}
}
```

