# 1 Linux用户

Linux是一个多用户的系统，我们可以多个用户同时登陆Linux~

- 账户实质上就是一个用户在系统上的标识。

Linux中的账户包括

- 用户账户
  - 普通用户账户：在系统上的任务是进行普通工作
  - 超级用户账户（或管理员账户）：在系统上的任务是对普通用户和整个系统进行管理。
- 组账户(组是用户的集合)
  - 标准组：标准组可以容纳多个用户
  - 私有组：私有组中只有用户自己

当一个用户同属于多个组时，将这些组分为

- 主组（初始组）：用户登录系统时的组。
- 附加组：登录后可切换的其他组

上面也说了，账户的实质上就是用户在系统上的标识，这些标识是用文件保存起来的：

- 用户名和 UID 被保存在` /etc/passwd `文件中，文件权限 `(-rw-r--r--)`
- 组和GID 被保存在 `/etc/group `文件中，文件权限` (-r--------)`
- 用户口令(密码)被保存在 `/etc/shadow`文件中 ，文件权限` (-rw-r--r-- )`
- 组口令被保存在 `/etc/gshadow`文件中 ，文件权限 `(-r--------)`

也就是说：我们创建的用户，这个用户的信息由不同的文件来保存着。

![img](https://segmentfault.com/img/remote/1460000015255063)

![img](https://segmentfault.com/img/remote/1460000015255064)

![img](https://segmentfault.com/img/remote/1460000015255065)

![img](https://segmentfault.com/img/remote/1460000015255066?w=1013&h=687)

有了上面的知识点，下面我来简述一下创建用户的时候会发生什么：

- 用户名和 UID 被保存在 `/etc/passwd` 这个文件中，用户的口令通常用`shadow passwords`保护
- 当用户登录时，他们被分配了一个主目录和一个运行的程序（通常是 shell）
- 若没有指定他所属于的组，RHEL/CentOS就建立一个和该用户同名的私有组，且用户被分配到这个私有组中

再来回顾一下：账户的实质上就是用户在系统上的标识，这些标识是用文件保存起来的。也就是说：我们是可以直接编辑修改系统账户文件来维护账户。

但是不建议这样做，如果明确要这样做的话，最好使用命令检测一下你编辑的语法是否有问题：

- `pwck`：验证用户账号文件，认证信息的完整性。该命令检测文件`“/etc/passwd”`和`“/etc/shadow”` 的每行中字段的格式和值是否正确
- `grpck `：验证组账号文件，认证信息的完整性。该命令检测文件`“/etc/group”`和`“/etc/gshadow”`的每行中字段的格式和值是否正确。

既然不建议我们直接编辑文件的方式来管理用户，那么Linux是肯定有现成的命令给我们使用的：

用户管理：

- `useradd`
- `usermod`
- `userdel`

组管理：

- `groupadd`
- `groupmod`
- `groupdel`

批量管理用户：

- 成批添加/更新一组账户：`newusers`
- 成批更新用户的口令：`chpasswd`

组成员管理：

- 向标准组中添加用户
  - `gpasswd -a <用户账号名> <组账号名>`
  - `usermod -G <组账号名> <用户账号名>`
- 从标准组中删除用户
  - `gpasswd -d <用户账号名> <组账号名>`

口令维护(禁用、恢复和删除用户口令)：

- 设置用户口令：`passwd [<用户账号名>]`
- 禁用用户账户口令`passwd -l <用户账号名>`
- 查看用户账户口令状态`passwd -S <用户账号名>`
- 恢复用户账户口令`passwd -u <用户账号名>`
- 清除用户账户口令`passwd -d <用户账号名>`

口令时效设置：

- 修改 `/etc/login.defs` 的相关配置参数

![img](https://segmentfault.com/img/remote/1460000015255067)

设置已存在用户的口令时效：`chage`命令

用户切换命令：

- `su`直接切换为超级用户
- `sudo`直接使用 sudo 命令前缀执行系统管理命令。执行系统管理命令时无需知道超级用户的口令，使用普通用户自己的口令即可

用户相关的命令：

- `id`：显示用户当前的uid、gid和用户所属的组列表
- `groups`：显示指定用户所属的组列表
- `whoami`：显示当前用户的名称
- `w/who`：显示登录用户及相关信息
- `newgrp`：用于转换用户的当前组到指定的组账号，用户必须属于该组才可以正确执行该命令

> shadow文件中密码为*号和！！代表什么？

答：`*`代表账户禁用；`！！`代表密码锁定。

> airXX用户组id是多少？这个组是什么类型的组？这样做有什么好处？

答：air08用户组id是501，这个组属于私有组。每个未指定组的用户会建立一个同名的组，这样的组称为私有组，只有一个用户，既有利于防止信息泄露，也也有利于防止不合理的授权。总之，有利于安全管理。

> 默认情况下删除用户，但却保留了用户的主目录，这样做有什么好处？

答：保留用户目录，防止将用户目录下有价值的资料误删除。

> 锁定账户后，shadow文件发生了什么变化？

答：锁定账户的密码之前会锁定标志！！

> 用su切换用户后，建立的新文件文件属于哪个用户？

答：新文件属于切换之后的用户。

> 两次执行chpasswd命令，结果是否相同？加密算法md5和sha512哪个更安全？

答：两次执行chpasswd命令结果不同，默认情况采用sha512加密算法；-m选项时，采用md5加密算法；sha512更安全，因为加密信息长度更长，破解计算量大。

# 2 权限管理

Linux是多用户的操作系统，允许多个用户同时在系统上登录和工作。 为了确保系统和用户的安全，Linux自然就有自己一套的权限管理机制！

使用`ls -l`命令会显示文件信息，例如：

```shell
drwxr-xr-x   3  osmond   osmond    4096  05-16 13:32   nobp
```

![img](https://segmentfault.com/img/remote/1460000015255110)

针对于文件权限：

![img](https://segmentfault.com/img/remote/1460000015255111?w=895&h=269)

这9个字符每3个一组，组成 3 套 权限控制

- 第一套控制文件所有者的访问权限
- 第二套控制所有者所在用户组的其他成员的访问权限
- 第三套控制系统其他用户的访问权限

rwx分别代表的意思：

![img](https://segmentfault.com/img/remote/1460000015255112)

看到这里来，如果前面的你看懂了，那`drwxr-xr-x`这么一串东西我觉得你很容易就能理解了：

d是文件夹，后面还有9个字母，每3个分成一组，`-`号表示没有。那么这个文件夹的权限就是：

对当前用户是可读可写可执行，对同组的用户是可读可执行，对其他的用户是可读可执行

对于这些rwx命令为了方便还可以换成八进制的数据来表示，我相信大家看完下面的demo也知道其实就这么一回事了：

![img](https://segmentfault.com/img/remote/1460000015255113)

权限的优先顺序：

- 如果UID匹配，就应用用户属主（user）权限
- 否则，如果GID匹配，就应用组（group）权限
- 如果都不匹配，就应用其它用户（other）权限
- 超级用户root具有一切权限，无需特殊说明

## 2.1 管理Linux权限的常用命令

- `chmod`：改变文件或目录的权限
- `chown`：改变文件或目录的属主（所有者）
- `chgrp`：改变文件或目录所属的组
- `umask`：设置文件的缺省生成掩码

![img](https://segmentfault.com/img/remote/1460000015255114?w=1013&h=565)

![img](https://segmentfault.com/img/remote/1460000015255115)

## 2.2 权限扩展知识

上面提到了umask属性，它用来做这样的东西的：默认生成掩码告诉系统当创建一个文件或目录时不应该赋予其哪些权限。默认的umask的值是022：

![img](https://segmentfault.com/img/remote/1460000015255116?w=972&h=485)

除了上面所说的权限之外，Linux还提供了三种特殊的权限：

- SUID：使用命令的所属用户的权限来运行，而不是命令执行者的权限
- SGID：使用命令的组权限来运行。
- Sticky-bit：目录中的文件只能被文件的所属用户和root用户删除。

它们是这样表示的：

- SUID和SGID用s表示；Sticky-bit用t表示
- SUID是占用属主的x位置来表示
- SGID是占用组的x位置来表示
- sticky-bit是占用其他人的x位置来表示

例如：`drwxrwxrwt 5 root root 4096 06-18 01:01 /tmp`它就拥有sticky-bit权限。`-rwsr-xr-x 1 root root 23420 2010-08-11 /usr/bin/passwd`它就拥有SUID权限

SUID，SGID，sticky-bit同样也有数字的表示法：

![img](https://segmentfault.com/img/remote/1460000015255117)

使用的例子：

![img](https://segmentfault.com/img/remote/1460000015255118?w=830&h=518)

Linux内核中有大量安全特征。EXT2/3/4文件系统的扩展属性可以在某种程度上保护系统的安全。

**常见的扩展属性：**

- A（Atime）：告诉系统不要修改对这个文件的最后访问时间。
  - 使用A属性可以提高一定的性能。
- S（Sync）：一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘。
  - 使用S属性能够最大限度的保障文件的完整性。
- a（Append Only）：系统只允许在这个文件之后追加数据，不允许任何进程覆盖或者截断这个文件。如果目录具有这个属性，系统将 只允许在这个目录下建立和修改文件，而不允许删除任何文件。
- i（Immutable）：系统不允许对这个文件进行任何的修改。如果目录具有这个属性，那么任何的进程只能修改目录之下的文件，不允许建立和删除文件。
  - a属性和i属性对于提高文件系统的安全性和保障文件系统的完整性有很大的好处。

常用命令：

- 显示扩展属性：`lsattr [-adR] [文件|目录]`
- 修改扩展属性：`chattr [-R] [[-+=][属性]] <文件|目录>`