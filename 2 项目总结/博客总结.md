## 1 数据库设计

数据库采用MySQL，共涉及5个表；

博客表t_blog：
id、title、summary、releaseDate、clickHit、reply、content、typeId、keyword；
(主键、标题、摘要、发布日期、点击数、评论数、内容、所属博客类型(外键)、关键字)；

博客类型表t_blogType：
id、typeName、orderNo；
(主键、类型名称、序号)；

博主表t_blogger：
id、userName、password、profile、nickName、sign、imageName；
(主键、用户名、密码、个人简介、昵称、个性签名、头像名)；

评论表t_comment：
id、userIp、blogId、content、commentDate、state;
(主键、评论者IP、评论博客ID(外键)、评论内容、评论日期、评论状态(0未审核1审核通过2审核不通过))；

友情链接t_link：
id、linkName、linkUrl、orderNo;
(主键、链接名称、链接地址、序号)；

## 2 配置文件

web.xml：整个web项目的配置文件，启动web项目时，tomcat首先会读取web.xml的配置信息。

整个web.xml会创建一个ServletContext的容器，整个项目会共享这个上下文；

1. 定义spring的核心配置文件applicationContext.xml：使用\<context-param>标签，会把name作为key，value(配置文件路径)作为值存入ServletContext中，以便程序中可以读取这个配置文件；
2. 创建spring监听器：使用\<listener>标签，当项目启动时会根据class属性配置的类路径(InitComponent)来创建监听，这个类为整个项目做一些初始化操作，初始化时执行其中的contextInitialized方法，这里是把一些常用信息但是又不经常更新的信息放入ServletContext容器中，使得程序需要的时候不用每次都去数据库读取，提高速度，这些信息包括博客类型信息、博主信息、按年月分类的博客数量、友情链接；
3. 创建Shiro过滤器：作用是对登陆进行验证TODO
4. 创建encodingFilter编码过滤器：作用是将编码转换成utf-8；
5. 配置SpringMVC的前端控制器DispatcherServlet并在其中读取springmvc的配置文件路径；

------

springmvc.xml：springmvc的配置文件

1. 开启注解\<mvc:annotation-driven/>，并配置注解要扫描的包；
2. 配置视图解析器：负责把service层返回的结果进行视图解析找到对应的页面；

------

applicationContext.xml：spring的核心配置文件  

首先是mybatis的相关配置：

1. 配置数据源，即连接数据库的信息；
2. 配置mybatis的sqlsessionfactory工厂，其中需要定义数据源、自动扫描mapper.xml文件路径和mybatis配置文件的路径；
3. 配置dao接口所在包名，spring会自动扫描这个包下面的类；

其次是shrio的相关配置：

1. 配置自定义myRealm，指向自定义类名称MyRealm；
2. 配置安全管理器securityManager，属性是myRealm；
3. 配置Shrio过滤器shiroFilter进行身份验证，属性是securityManager以及验证失败返回登录页面；
4. 开启shrio注解

最后是spring的相关配置：

1. 配置事务管理器transactionManager，属性是数据源datasource；
2. 配置事务通知属性txAdvice，其中定义事务的传播属性；
3. 配置事务切面，使用\<aop:config>标签，属性有切入点也就是要增强的方法，以及事务通知也就是增强的内容；
4. 开启注解扫描的包；

------

mybatis-config.xml：mybatis的配置文件

大部分内容转移到了spring的核心配置文件中，保证spring容器启动就能够初始化得到数据库连接；

## 3 博主操作

### 3.1 博主实体类 - Blogger

代表博主实体类，属性和数据库表中的属性保持一致，采用ORM的思想，把数据映射成对象(最好实体类属性和数据库列重名，否则还要编写转化代码)；

### 3.2 博主后台登陆页面 - login.jsp

1. 提示用户输入用户名和密码并进行验证，在前端页面先进行判断是否为空的验证，不为空才通过post方式提交一个blogger实体类给BloggerController进行正确性验证；
2. 如果正确性验证不通过会返回给前端页面错误信息，前端把错误信息显示出来(用户名或密码不正确)；
3. 如果不通过后台还会把用户提交的用户名和密码返回回来填充输入框，避免用户需要重新输入；

### 3.3 博主操作controller层 - BloggerController

属性：**bloggerService**：service层的引用，查询博主信息使用；

方法：

**1. login()**

1. 获取前端提交的blogger实体类，取出其中的用户名和密码；
2. 通过自定义的工具类CryptographyUtil进行MD5加密(需要设置salt)；
3. 利用Shiro进行验证(TODO)，如果验证通过则跳转到后台管理页面main.jsp；
4. 验证不通过会在request中设置blogger(前台取出填充输入框)和erroInfo(前台显示错误提示信息)属性然后跳转回登陆页面；

**2. aboutMe()**

博主主界面关于博主按钮调用，负责通过调用bloggerService引用的find方法查询博主信息，并跳转到博主信息页面info.jsp；通过构建一个ModelAndView对象实现；

### 3.4 博主操作service层 - BloggerService接口和BloggerServiceImpl实现类

属性：**bloggerDao**：dao层的引用，service层的所有方法都委托到了dao层进行具体操作；

方法：

1. `Blogger getByUserName(String userName)`：通过用户名获取博主实体类；
2. `Integer update(Blogger blogger)`：更新博主信息，参数是一个不完整的blogger实体，只会对参数中有的属性进行更新。注意：由于博主信息不经常更新且只有一个，这里会把更新后的博主信息存到session中，以便其他地方直接读取不用再调用函数去数据库查询；
3. `Blogger find()`：查找一个博主，由于只存在一个博主，所以无参数；

### 3.5 博主操作dao层 - BloggerDao接口和BloggerMapper.xml

BloggerDao接口只定义需要的方法，具体实现通过BloggerMapper.xml进行配置。且方法和service层完全一致，因为service层的每个方法就是通过调用dao层的对应方法实现的；

**BloggerMapper.xml**

首先定义\<mapper namespace="com.blog.dao.BloggerDao">指定需要对应的dao接口及路径；

定义一个resultMap结构代表将数据库查询得到的列映射成博主实体类的属性；

对应dao接口的三个方法，需要在xml文件中配置，主要配置参数parameterType、返回值resultMap和对应的SQL语句。注意每个方法对应的标签ID需要和方法名保持一致；

1. getByUserName：`select * from t_blogger where userName = #{userName}`
2. update：`update t_blogger` 注意：更新博主信息时不一定要把所有信息都输入更新，这里可以进行判断，对非空的有效输入进行更新即可，主要通过\<set>标签嵌套\<if>标签分别判断每一个属性信息是否非空；
3. find：`select * from t_blogger limit 1` 虽然返回类型是集合但是限定了查询数量为1(只有1个)；

注意：由于在applicationContext.xml配置了需要自动扫描的mapper.xml文件路径，所以不再需要为每一个mapper.xml文件在主配置文件中进行配置；

## 4 博客类别

### 4.1 博客类别实体类 - BlogType

代表数据库中的博客类别表，属性和数据库列名保持一致。

为了统计某一个博客类型下面博客的数量，为博客类型添加了一个blogCount属性，表示本类型下博客的数量；

### 4.2 博客类别页面 - blogTypeManage.jsp

主要提供显示和修改两大功能

显示：访问页面就查询当前数据库中的博客类别，并显示博客类别的编号、博客类别名称、排序序号(首页显示顺序)；查询操作访问的是BlogTypeAdminController的list方法；

修改：提供添加、修改、删除功能；

1. 添加：点击顶部的添加按钮弹出添加输入对话框，要求输入博客类别名称和排序序号(编号是主键自增)，调用的是BlogTypeAdminController的save方法，且没有参数。点击确认后会感觉后台调用的结果提示是否添加成功，并刷新显示页面reload；
2. 修改：选中某个类别然后点击修改(前端会判断是否选中的是一条数据，不能不选或者多选)，弹出修改对话框，修改后保存，调用的也是BlogTypeAdminController的save方法，但是有blogType实体类参数。点击确认后会感觉后台调用的结果提示是否修改成功，并刷新显示页面reload；
3. 删除：选中一个或多个类型点击删除(前端会判断是否选中了类别)，弹出确认删除对话框，确认后将要删除的博客类别id拼接成字符串，调用BlogTypeAdminController的delete方法，根据调用后台函数的结果判断是否成功，并显示给用户是否删除成功的提示，并刷新显示页面reload；

### 4.3 博客类别Controller层 - BlogTypeAdminController

属性：**blogService(删除类别时用来统计某个类别下是否有博客)** 和 **blogTypeService**

方法：

1. **list**：查询博客类别列表，前台传入的参数包括分页信息page(代表第几页)和rows(代表多少行)，内部通过分页实体类PageBean进行封装，得到页开始的行start和页大小size；调用blogTypeService的list方法并传入分页参数，同时调用getTotal方法查询总共有多少类；最好把查询的数据转成json格式通过工具类ResponseUtil写入response中返回；
2. **save**：添加和修改博客类别，根据是否传入博客类别对象blogType区分，分别调用blogTypeService的添加方法add和修改方法update，并把操作结果保存为一个"success"属性放入repsonse中返回；
3. **delete**：删除博客类别，前台传入的是要删除类别的id拼接成的字符串，首先查分得到有效id，针对每条遍历调用blogTypeService的delete方法删除，注意针对每个类别先调用blogService的getBlogByTypeId获取该类别下博客的数量，如果不为0则不能删除(exist字段放入reponse中)，为0成功删除写入"success"字段放入response中；

### 4.4 博客类别Service层 - BlogTypeService接口和BlogTypeServiceImpl实现类

属性：**blogTypeDao**：dao层的引用，service层的所有方法都委托到了dao层进行具体操作；

方法：

1. `List<BlogType> countList()`：无参数查询所有博客类型列表；
2. `BlogType findById(Integer id)`：根据id查询一条博客类型；
3. `List<BlogType> list(Map<String, Object> paramMap)`：不固定参数查询博客类型列表，参数是map结果代表一个博客类别的属性键值对；
4. `Long getTotal(Map<String, Object> paramMap)`：不固定参数查询博客类型数；
5. `Integer add(BlogType blogType)`：添加一个博客类别(返回值代表是否成功)；
6. `Integer update(BlogType blogType)`：修改一个博客类别；
7. `Integer delete(Integer id)`：根据博客类别id删除一个博客类别；

### 4.5 博客类别dao层 - BlogTypeDao接口和BlogTypeMapper.xml

BlogTypeDao接口只定义需要的方法，具体实现通过BlogTypeMapper.xml进行配置。且方法和service层完全一致，因为service层的每个方法就是通过调用dao层的对应方法实现的；

**BlogTypeMapper.xml**

首先定义\<mapper namespace="com.blog.dao.BlogTypeDao">指定需要对应的dao接口及路径；

定义一个resultMap结构代表将数据库查询得到的列映射成博客类别实体类的属性；

对应dao接口的7个方法，需要在xml文件中配置，主要配置参数parameterType、返回值resultMap和对应的SQL语句。注意每个方法对应的标签ID需要和方法名保持一致；

1. countList：查询所有博客类别，由于博客类别实体类BlogType添加了一个统计博客数量属性，所以查询时要统计出来；

```mysql
select t2.id,t2.typeName,count(t1.id) as blogCount 
from t_blog t1 right join t_blogType t2 
on t1.typeId=t2.id group by t2.typeName order by t2.orderNo
```

2. findById：`select * from t_blogType where id=#{id}`
3. list：`select * from t_blogType` 根据传入的分页参数，需要通过limit限制查询的范围；
4. getTotal：`select count(*) from t_blogType`
5. add：`insert into t_blogType(typeName,orderNo) values(#{typeName},#{orderNo})`
6. update：`update t_blogType`根据参数map判断需要更新的信息(类别名称和排序序号)；
7. delete：`delete from t_blogType where id=#{id}`

## 5 博客管理

### 5.1 博客实体类 - Blog

代表一篇博客文章实体类，属性和数据库表中的属性保持一致，采用ORM的思想，把数据映射成对象(最好实体类属性和数据库列重名，否则还要编写转化代码)；

注意：添加了三个额外的属性

- String contentNoTag：表示纯文本格式的博客内容(因为原始的博客内容含有标签等非内容信息)；
- String releaseDateStr：博客发布时间的字符串表示；
- Integer blogCount：按照日期分组的博客数量统计信息；

### 5.2 博客操作页面 - blogManage.jsp、writeBlog.jsp、modifyBlog.jsp

**blogManage.jsp**  

博客信息管理页面，基本结构和功能同博客类别管理界面一致，提供查询和修改两大功能；

显示：访问页面就查询当前数据库中的博客，并显示博客的编号、博客标题、发布日期和博客所属类别；

查询操作访问的是BlogAdminController的list方法；

1. 额外提供一个搜索框，用于根据博客标题进行查询博客；
2. 每一个博客的标题都是可点击的，点击调用BlogController的details方法跳转到相应的博客详细页面；

修改：提供修改、删除；

1. 修改：点击修改，首先判断选中的是不是一个博客，然后将选中的博客id作为参数打开一个新的modifyBlog.jsp新标签页；
2. 删除：逻辑和删除博客类别一致，选中一个或多个，提示确认然后调用BlogAdminController的delete方法删除；

**writeBlog.jsp**

博客编写页面，提示用户输入博客的关心信息，包括博客标题、所属类别(下拉菜单可选，这里直接从ServletContext中获取的，初始化时放入的，所以如果更新了博客类别，需要手动刷新，否则这里取的还是旧值)、博客编辑器(ueditor)、关键字。最后发布按钮保存博客；

核心是保存功能实现，首先取得各个输入框中的输入，判断是否为空，然后调用BlogAdminController的save方法添加一条博客，感觉调用返回结果提示用户是否保存成功；

**modifyBlog.jsp**

修改页面和编写页面完全一致，不同的是进入修改页面首先会根据传入的博客id，调用BlogAdminController的findById方法查询该条博客的所有原始信息，然后填充各个输入框供用户修改；

### 5.3 博客操作controller层 - BlogAdminController

属性：blogService 和 blogIndex（lucene索引使用，添加博客的时候要添加一条索引，删除的时候也要对应删除索引）

方法：

1. **list**：查询博客列表，前台传入的参数包括分页信息page(代表第几页)和rows(代表多少行)，内部通过分页实体类PageBean进行封装，得到页开始的行start和页大小size；特殊的管理页面的根据标题查询也是通过list方法，利用了模糊查询，将标题作为参数，调用blogService的list方法并传入分页参数，同时调用getTotal方法查询博客数量；最后把查询的数据转成json格式通过工具类ResponseUtil写入response中返回；
2. **sava**：添加和修改博客，根据是否传入博客对象blog区分，分别调用blogService的添加方法add和修改方法update，并把操作结果保存为一个"success"属性放入repsonse中返回；特殊的添加和修改的同时还要分别调用blogIndex的addIndex和updateIndex方法更新索引信息；
3. **delete**：根据博客id删除一条或多条博客，前台传入的是要删除博客的id拼接成的字符串，首先查分得到有效id，针对每条遍历调用blogService的delete方法删除，注意要同步调用blogIndex的deleteIndex删除索引，成功删除写入"success"字段放入response中；
4. **findById**：根据博客主键编号查询一条博客信息，调用的是blogService的findById方法，查询结果写入response中返回；

### 5.4 博客操作service层 - BlogService接口和BlogServiceImpl实现类

属性：blogDao 和 commentDao（删除博客时用来级联删除对应的评论）

方法：

1. `List<Blog> countList()`：无参数查询博客列表(供首页使用)；
2. `List<Blog> list(Map<String,Object> map)`：带参数查询博客列表；
3. `Long getTotal(Map<String,Object> map)`：带参数查询博客数量；
4. `Blog findById(Integer id)`：根据主键查询一条博客信息；
5. `Integer add(Blog blog)`：添加一条博客；
6. `Integer update(Blog blog)`：修改一条博客；
7. `Integer delete(Integer id)`：根据主键删除一条博客；
8. `Integer getBlogByTypeId`：根据类型查询博客数量（首页使用）；
9. `Blog getLastBlog(Integer id)`：上一篇（博客详情页上一篇功能）；
10. `Blog getNextBlog(Integer id)`：下一篇（博客详情页上一篇功能）；

### 5.5 博客操作dao层 - BlogDao接口和BlogMapper.xml

BlogDao接口只定义需要的方法，具体实现通过BlogMapper.xml进行配置。且方法和service层完全一致，因为service层的每个方法就是通过调用dao层的对应方法实现的；

**BlogMapper.xml**

首先定义\<mapper namespace="com.blog.dao.BlogDao">指定需要对应的dao接口及路径；

定义一个resultMap结构代表将数据库查询得到的列映射成博客实体类的属性；

对应dao接口的7个方法，需要在xml文件中配置，主要配置参数parameterType、返回值resultMap和对应的SQL语句。注意每个方法对应的标签ID需要和方法名保持一致；

1. countList：无参数查询博客列表，按照博客日期进行分组查询，并按照日期排序，结果是日期和对应的数量

```mysql
select date_format(releaseDate,'%Y年%m月') as releaseDateStr,count(*) as blogCount
		from t_blog group by date_format(releaseDate,'%Y年%m月')
		order by date_format(releaseDate,'%Y年%m月') desc
```

2. list：`select * from t_blog`根据参数查询博客列表，参数有标题、所属类别、发布日期，并按照日期排序，最后利用limit限制查询的范围；
3. getTotal：`select count(*) from t_blog`根据参数统计博客数量，参数有标题、所属类别、发布日期；
4. findById：`select * from t_blog where id=#{id}`
5. add：`insert into t_blog values(null,#{title},#{summary},now(),0,0,#{content},#{blogType.id},#{keyWord})`
6. update：`update t_blog...where id=#{id}`将不为空的参数进行更新
7. delete：`delete from t_blog where id=#{id} `
8. getBlogByTypeId：`select count(*) from t_blog where typeId=#{typeId}`统计某个类别下的博客数量；
9. getLastBlog：`select * from t_blog where id&lt;#{id} order by id desc limit 1`
10. getNextBlog：`select * from t_blog where id&gt;#{id} order by id limit 1`

## 6 评论管理

### 6.1 评论实体类 - Comment

代表某篇博客下面的某个评论，采用ORM的思想，把数据映射成对象(最好实体类属性和数据库列重名，否则还要编写转化代码)；

### 6.2 评论管理页面 - commentManage.jsp 和 commentReview.jsp

**commentManage.jsp**

评论管理界面，提供评论的显示和删除功能；

**显示**：访问页面就查询当前数据库中的评论，并显示对应博客的编号、用户的IP地址、评论内容、评论日期和评论的状态；查询操作访问的是CommentAdminController的list方法；

注意：数据库中评论的状态是用数字表示，0未审核，1审核通过，2审核未通过，显示的时候需要转化一下；每个评论对应的博客标题是可以点击的链接，点击会跳转到博客详细页面；

**删除**：选中一个或多个评论点击删除，提示确认，确认后调用CommentAdminController的delete的方法删除评论，调用后提示成功或失败；

**commentReview.jsp**

评论审核页面，提供审核评论功能；

显示：访问页面就查询所有未审核的评论，显示信息和评论管理页面一致，除了没有最后的评论状态，查询调用的CommentAdminController的list方法，且传入state=0(未审核)的参数；

审核：选中一条或多条评论，选择审核通过或者不通过，提示确认，然后把选择评论的id拼接成字符串作为参数，调用CommentAdminController的review方法，根据返回值提示成功或失败；

### 6.3 评论管理controller层 - CommentAdminController

属性：commentService，service层的引用；

方法：

1. **list**：查询评论列表，除了分页参数page和rows，还有state审核状态，将参数封装成map结构后调用commentService的list方法查询，同时调用getTotal方法查询符合参数的评论总数，然后把查询结果转换成json格式存入response中返回给前台；(这里对日期做了格式转换)；
2. **delete**：删除评论，参数是要删除评论的id拼接成的字符串，拆分后调用commentService的delete方法遍历删除，并将删除结果存入"success"字段返回给前台；
3. **review**：评论审核，参数是要审核的评论id拼接的字符串，以及是否审核通过state的值，拆分ID后将id和state组合成Comment对象执行commentService的update方法，更新评论的审核状态，并把更新结果存入: "success"字段返回给前台；

### 6.4 评论管理service层 - CommentService接口和CommentServiceImpl实现类

属性：commentDao，dao层的引用

方法：

1. `int add(Comment comment)`：添加一条评论；
2. `int update(Comment comment)`：更新一条评论；
3. `List<Comment> list(Map<String,Object> map)`：评论查询；
4. `Long getTotal(Map<String,Object> map)`：评论数量查询；
5. `Integer delete(Integer id)`：根据评论id删除评论；

### 6.5 评论管理dao层 - CommentDao接口和CommentMapper.xml

CommentDao接口只定义需要的方法，具体实现通过CommentMapper.xml进行配置。且方法和service层完全一致，因为service层的每个方法就是通过调用dao层的对应方法实现的；

添加了一个额外的方法

`Integer deleteByBlogId(Integer blogId)`：根据博客的ID删除评论，当删除某个博客时需要级联删除对应的评论，调用的就是这个方法；

**CommentMapper.xml**

首先定义\<mapper namespace="com.blog.dao.CommentDao">指定需要对应的dao接口及路径；

定义一个resultMap结构代表将数据库查询得到的列映射成评论实体类的属性；

1. add：`insert into t_comment values(null,#{userIp},#{blog.id},#{content},now(),0)`添加一条评论(博客前台页面调用)；
2. update：`update t_comment...where id=#{id}`更新评论状态，参数主要是评论的状态更新；
3. list：`select * from t_comment`根据参数查询评论列表，参数主要有所属博客ID、审核状态、以及分页参数limit范围限定，最后按照评论发布日期排序；
4. getTotal：`select count(*) from t_comment`根据参数查询评论数量，参数主要就是评论的状态；
5. delete：`delete from t_comment where id=#{id}`根据评论ID删除；
6. deleteByBlogId：`delete from t_comment where blogId=#{blogId}`根据博客ID删除对应的评论；

## 7 链接管理

### 7.1 链接实体类 - Link

代表网站首页的友情链接部分，采用ORM的思想，把数据映射成对象(最好实体类属性和数据库列重名，否则还要编写转化代码)；

### 7.2 链接管理界面 - linkManage.jsp

主要提供显示和修改两大功能

显示：访问页面就查询当前数据库中的友情链接，并显示友情链接的编号、友情链接名称、友情链接地址和排序序号；查询操作访问的是LinkAdminController的list方法；

修改：提供添加、修改、删除功能；

1. 添加：点击顶部的添加按钮弹出添加输入对话框，要求输入友情链接名称、地址和排序序号，调用的是LinkAdminController的save方法，且没有参数。点击确认后会感觉后台调用的结果提示是否添加成功，并刷新显示页面reload；
2. 修改：选中某个链接然后点击修改(前端会判断是否选中的是一条数据，不能不选或者多选)，弹出修改对话框，修改后保存，调用的也是LinkAdminController的save方法，但是有link实体类参数。点击确认后会感觉后台调用的结果提示是否修改成功，并刷新显示页面reload；
3. 删除：选中一个或多个类型点击删除(前端会判断是否选中了类别)，弹出确认删除对话框，确认后将要删除的链接id拼接成字符串，调用LinkAdminController的delete方法，根据调用后台函数的结果判断是否成功，并显示给用户是否删除成功的提示，并刷新显示页面reload；

### 7.3 链接管理controller层 - LinkAdminController

属性：linkService，service层引用；

方法：

1. **list**：查询链接列表，参数是分页参数page和rows，封装成map结构后条用linkService的list方法查询符合条件链接，同时调用linkService的getTotal方法查询链接数量，然后把查询结果转换成json格式存入response中返回给前台；

2. **delete**：删除链接，参数是要删除链接的id拼接成的字符串，拆分后调用linkService的delete方法遍历删除，并将删除结果存入"success"字段返回给前台；
3. **save**：添加和修改链接，根据是否传入链接对象link区分，分别调用linkService的添加方法add和修改方法update，并把操作结果保存为一个"success"属性放入repsonse中返回；

### 7.4 链接管理service层 - LinkService接口和LinKServiceImpl实现类

属性：linkDao，dao层引用，service层所有的方法实现都给交dao层实现；

方法：

1. `Link findById(Integer id)`：根据id查询一条友情链接；
2. `List<Link> list(Map<String,Object> paramMap)`：不固定参数查询友情链接列表；
3. `Long getTotal(Map<String,Object> paramMap)`：不固定参数查询友情链接数；
4. `Integer add(Link link)`：添加一条友情链接；
5. `Integer update(Link link)`：修改一条链接；
6. `Integer delete(Integer id)`：根据链接ID删除一条链接；

### 7.5 链接管理dao层 - LinkDao接口和LinkMapper.xml

LinkDao接口只定义需要的方法，具体实现通过LinkMapper.xml进行配置。且方法和service层完全一致，因为service层的每个方法就是通过调用dao层的对应方法实现的；

**LinkMapper.xml**

首先定义\<mapper namespace="com.blog.dao.LinkDao">指定需要对应的dao接口及路径；

定义一个resultMap结构代表将数据库查询得到的列映射成评论实体类的属性；

1. findById：`select * from t_link where id=#{id}`根据链接id查询链接；
2. list：`select * from t_link order by orderNo`按照序号排序并根据分页参数通过limit限定查询的范围；
3. getTotal：`select count(*) from t_link`统计链接的数量；
4. add：`insert into t_link(linkName,linkUrl,orderNo) values(#{linkName},#{linkUrl},#{orderNo})` 从传入的link对象参数中取出相应的属性插入；
5. update：`update t_link...where id=#{id}`根据传入的link对象取出不为空的参数，对其进行更新；
6. delete：`delete from t_link where id=#{id}`根据链接ID删除一条链接；

## 8 修改个人信息

### 8.1 修改个人信息页面 - modifyInfo.jsp

提供用户信息的修改，包括用户名username、昵称nickname、个性签名、个人头像和个人简介；进入页面的时候首先获取个人原始信息填充所有输入框供用户修改，这里直接从session中取得(MyRealm中放入)不是从数据查询，因为博主信息不经常变化，提高效率；

其中查询用户简介调用的是BloggerAdminController的find方法，此方法也是直接从session中取得blogger对象并转换成json格式返回的，所以前端页面需要取得json格式后解析出个人简介，然后填充ueditor编辑器；

修改后的信息点击提交，前端先对修改的信息进行是否为空的判断，不为空在调用BloggerAdminController的save方法更新博主的信息，根据执行结果提示成功或失败；

### 8.2 个人信息管理controller层 - BloggerAdminController

属性：bloggerService，service层引用

方法：

1. save：传入的参数是一个blogger类对象和一个头像的文件，首先把头像文件复制到项目路径下，头像的名称是日期+原始文件名，然后把文件名设置到blogger对象中，调用bloggerService的update方法更新博主信息，并把执行结果写入reponse中返回；
2. find：获取博主的json格式数据，这里直接从session中取得，没有直接查询数据库；
3. modifyPassword：修改密码，根据参数传入的博主id和新密码(MD5加密)构造一个blogger对象，调用bloggerService的update方法更新博主密码；(修改密码功能前端定义在了主界面main.jsp中)
4. logout：安全退出，用户退出登陆，直接调用`SecurityUtils.getSubject().logout()`方法退出并重定向到登陆页面login.jsp

### 8.3 系统设置controller层 - SystemAdminController

提供唯一方法refreshSystem，负责刷新系统缓存。由于博客类别、博主信息、友情链接、按年月分类的博客数量等数据不经常更新，没有必要每次都去数据库查询，导致效率下降，因此在初始化时将这些信息存入了ServletContext容器中，每次都从中直接获得，也因此如果更新了以上信息不更新ServletContext中的内容就会导致读取到的和数据库中的不一致，所以本方法就是为了查询数据库更新ServletContext中的信息；

博客类别：调用blogTypeService的countList方法查询所有博客类别；

博主信息：调用bloggerService的find方法查询唯一博主信息；

按年月分类的博客数量：调用blogService的countList方法统计博客数量；

友情链接：调用linkService的list方法查询所有的链接；

### 8.4 初始化controller层 - InitComponent

在项目启动的时候负责初始化操作，将博客类别、博主信息、按年月分类博客数量、友情链接信息查询出来存入ServletContext中，供其他地方直接获取，不用查数据库；

## 9 个人博客系统

### 9.1 博客主界面

**index.jsp**

博客首页页面的整体布局是三部分；

第一部分是顶部的菜单栏，显示首页按钮、关于博主按钮、登陆后台按钮，以及根据关键字搜索框；

第二部分是右侧的侧边栏，显示博主信息、博客按日志类别分类、按日期分类、友情链接(其中的信息是直接从ServletContext中获取的)；

第三部分是主信息显示页面，初始时负责显示博客列表，后续所有点击产生的页面跳转都在部分中显示；

**info.jsp**

首页点击关于博主按钮跳转，负责显示博主的个人简介，信息也是从ServletContext中直接获取的；

**list.jsp**

访问首页时初始的博客显示页面，将所有博客信息按照日期排序显示（博客列表信息是从IndexController中传递过来的）；

每条博客会显示发布日期、博客标题、摘要信息、以及阅读数和点击数；

底部会显示翻页功能：首页、上一页、页码列表、下一页和尾页；

点击某个博客时会跳转到详细页面view.jsp，具体是通过调用BlogController的details方法传入博客ID进行跳转；

**view.jsp**

博客信息详情页面，主要有三大部分：

第一部分：博客详细信息：标题、分享按钮、发布时间、博客所属类别、阅读数、点击数、博客正文内容、关键字(以上都是通过BlogController传入的blog对象直接获取)以及上下篇按钮(通过传入的pageCode)；

第二部分：评论列表部分：评论楼层、评论者IP、评论内容以及评论时间（都是从BlogController传入的commentList中获取）；

第三部分：发表评论部分：评论输入框、验证码输入以及发表按钮(提交首先进行为空判断，然后调用CommentController的save方法保存一条评论)；

**result.jsp**

根据关键字进行查询的结果显示页面，主要显示符合条件的博客列表，具体每条博客包含标题、摘要、URL地址和发布日期，列表底部提供上一页下一页的翻页功能；

### 9.2 主界面博客列表controller层 - IndexController、BlogController和commentController

**IndexController**

在web.xml中配置了项目的访问欢迎页，项目初始必须经过的就是IndexController的index方法，这个方式通过设置一个ModelAndView跳转到index.jsp主界面，进而把博客列表信息传递过去给list.jsp页面显示；

属性：blogService，service层应用；

方法：只有一个index方法负责初始化博客列表以及一些翻页操作传递给index.jsp主界面；

主要是通过设置键值对的方式把信息保存到ModelAndView对象中，然后前端可以通过键值取得相应的信息显示出来；

1. page参数为空只显示一页，设置`page = 1`;
2. 翻页信息start和size，表示第几页和本页有几条博客；
3. 博客类型查询，当点击主页右侧的具体类别时会传入类别ID然后查询该类别下的博客列表；
4. 博客日期查询，当点击主页右侧的日期时会传入日期信息然后查询该日期下的博客列表；
5. 将以上参数构建map集合调用blogService的list方法查询出博客信息设置到mav中；
6. 通过分页参数参数PageUtil工具类，把分页信息整合成字符串pageCode设置到mav中；

**BlogController**

负责点击博客标题跳转到博客详细页、实现上一篇下一篇功能、根据关键字查询博客、查询结果的翻页；

属性：blogService、commentService、blogIndex；

方法：

1. details：根据博客ID跳转到博客详细页。首先根据传入的博客ID参数调用blogService的findByID方法出博客对象blog放入ModelAndView对象mav中；然后将对应博客的阅读数加1，调用blogService的upate方法更新；然后设置跳转view.jsp页面负责显示博客详细信息；调用commentServiced的list方法查询出博客对应的评论列表放入mav；查询出博客的关键字单独设置到mav中，最后设置跳转到index页面；
2. genUpAndDownPageCode：根据本博客的上一篇和下一篇博客(通过blogServicve的getLastBlog和getNextBlog方法查询）构建前端代码字符串；
3. q：根据关键字查询方法。参数的参数是关键字，使用lucene构建的索引blogIndex中的searchBlog方法查询符合条件的博客列表，同时设置翻页参数，最后跳转到index页面；
4. genUpAndDownPageCode：查询结果的翻页功能，这里只提供上一页和下一页，特殊的第一页没有上一页，最后一页没有下一页，构建前端代码字符串；

**commentController**

博客详细页面的评论提供功能；

属性：commentService、blogService；

方法：save方法负责提交评论：首先判断验证码是否正确，然后调用commentService的add方法添加一条评论，然后调用blogService的findById方法查询出对应博客，调用update方法更新对应博客的评论数+1；

## 10 工具类

### 10.1 翻页实体类 - PageBean

属性：表示当前是第几页page、页面的大小pageSize、以及从第几条数据开始查询start；

这个类的作用就是构造时传入page和pageSize参数，然后返回从第几条数据开始查询start（page-1）xpageSize;

### 10.2 常量工具类 - Const

将一些常用的字符串保存为静态字符串常量，直接通过类名引用；

### 10.3 密码加密工具类 - CryptographyUtil

负责把用户的密码进行MD5加密返回；

### 10.4 日期格式处理工具类 - DateJsonValueProcessor

实现JsonValueProcessor接口，覆写processObjectValue方法，把不同的日期格式转换为字符串格式；

### 10.5 日期工具类 - DateUtil

得到当前秒的字符串表示，以及将日期对象按照格式转成字符串；

### 10.6 翻页工具类 - PageUtil

生成翻页的前端代码

### 10.7 Response写入工具类 - ResponseUtil

负责把数据写入response中；

### 10.8 字符串操作类 - StringUtil

用于判断字符串是否为空，字符串前后加上%用于模糊查询、滤掉字符中的空格等；

