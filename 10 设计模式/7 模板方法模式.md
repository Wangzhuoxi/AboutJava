# 1 模板方法模式介绍

定义一个操作中的算法框架，而将一些步骤延迟到子类中。使子类可以不改变一个算法的结构即可重定义该算法的某些步骤。

- 定义一个操作中的算法框架，而将一些步骤延迟到子类中。
  - WriteArticle中有一个writeAnCompleteArticle()方法，该方法定义了发文章的所有步骤，但是这些步骤大多是抽象的，得由子类来实现。
- 使子类可以不改变一个算法的结构即可重定义该算法的某些步骤
  - 外界是通过调用writeAnCompleteArticle()方法来写文章的，子类如果改变具体的实现就会间接改变了算法的细节。

![æ¨¡æ¿æ¹æ³æ¨¡å¼çéç¨ç±»å¾](https://segmentfault.com/img/remote/1460000017755964)

在模板方法模式中，也有几个术语：

- **基本方法**：在子类实现，并且在模板方法中被调用
- **模板方法**：定义了一个框架，实现对基本方法的调用，完成固定的逻辑。

模板方法模式很简单，一个抽象类有基本方法(等着被子类实现的方法)，有模板方法(对外暴露、调用基本方法、定义了算法的框架)，那就完事了。

# 2 模板方法的优缺点

优点：

- 封装不变的部分，扩展可变的部分。把认为是不变的部分的算法封装到父类，可变部分的交由子类来实现！
- 提取公共部分的代码，行为由父类控制，子类实现！

缺点：

- 抽象类定义了部分抽象方法，这些抽象的方法由子类来实现，子类执行的结果影响了父类的结果(子类对父类产生了影响)，会带来阅读代码的难度！

# 3 模板方法模式JDK应用

最经典的就是JUC包下的AQS(AbstractQueuedSynchronizer)了。AQS是什么？

AQS其实就是一个可以给我们实现锁的框架。内部实现的关键是：先进先出的队列、state状态

我们可以看一下AQS定义的`acquire()`

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

`acquire()`相当于模板方法，`tryAcquire(arg)`相当于基本方法。

