# 1 单例模式概述

单例模式定义很简单：一个类中能创建一个实例，所以称之为单例！

那我们什么时候会用到单例模式呢？？

- 那我们想想既然一个类中只能创建一个实例了，那么可以说这是跟类的状态与对象无关的了。
- 频繁创建对象、管理对象是一件耗费资源的事，我们只需要创建一个对象来用就足够了！

能使用一个对象来做就不用实例化多个对象！这就能减少我们空间和内存的开销~

那有可能有的人又会想了：我们使用`静态类.doSomething()`和使用单例对象调用方法的效果是一样的啊。

没错，效果就是一样的。使用`静态类.doSomething()`体现的是基于对象，而使用单例设计模式体现的是面向对象。

单例模式好处:

- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；
- 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。

为什么不使用全局变量确保一个类只有一个实例呢？

我们知道全局变量分为静态变量和实例变量，静态变量也可以保证该类的实例只存在一个。只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

但是，如果说这个对象非常消耗资源，而且程序某次的执行中一直没用，这样就造成了资源的浪费。利用单例模式的话，我们就可以实现在需要使用时才创建对象，这样就避免了不必要的资源浪费。 不仅仅是因为这个原因，在程序中我们要尽量避免全局变量的使用，大量使用全局变量给程序的调试、维护等带来困难。

# 2 单例模式的代码

编写单例模式的代码其实很简单，就分了三步：

- 将构造函数私有化
- 在类的内部创建实例
- 提供获取唯一实例的方法

## 2.1 饿汉式

```java
public class Java3y {
    // 1.将构造函数私有化，不可以通过new的方式来创建对象
    private Java3y(){}
    // 2.在类的内部创建自行实例
    private static Java3y java3y = new Java3y();
    // 3.提供获取唯一实例的方法
    public static Student getJava3y() {
        return java3y;
    }
}
```

这种代码我们称之为：“**饿汉式**”：一上来就创建对象了，如果该实例从始至终都没被使用过，则会造成内存浪费。

## 2.2 简单懒汉式

既然说一上来就创建对象，如果没有用过会造成内存浪费：那么我们就设计用到的时候再创建对象！

```java
public class Java3y {
    // 1.将构造函数私有化，不可以通过new的方式来创建对象
    private Java3y(){}
    // 2.1先不创建对象，等用到的时候再创建
    private static Java3y java3y = null;
    // 2.1调用到这个方法了，证明是要被用到的了
    public static Java3y getJava3y() {
        // 3. 如果这个对象引用为null，我们就创建并返回出去
        if (java3y == null) {
            java3y = new Java3y();
        }
        return java3y;
    }
}
```

上面的代码行不行？在单线程环境下是行的，在多线程环境下就不行了！

要解决也很简单，我们只要加锁就行了（使用synchronized关键字）

## 2.3 双重检测机制(DCL)懒汉式

上面那种直接在方法上加锁的方式其实不够好，因为在方法上加了内置锁在多线程环境下性能会比较低下，所以我们可以将锁的范围缩小。

```java
public class Java3y {
    private Java3y() {
    }
    private static Java3y java3y = null;
    public static Java3y getJava3y() {
        if (java3y == null) {
            // 将锁的范围缩小，提高性能
            synchronized (Java3y.class) {
                java3y = new Java3y();
            }
        }
        return java3y;
    }
}
```

那上面的代码可行吗？？不行，因为虽然加了锁，但还是有可能创建出两个对象出来的：

- 线程A和线程B同时调用`getJava3y()`方法，他们同时判断`java==null`，得出的结果都是为null，所以进入了if代码块了
- 此时线程A得到CPU的控制权-->进入同步代码块-->创建对象-->返回对象
- 线程A完成了以后，此时线程B得到了CPU的控制权。同样是-->进入同步代码块-->创建对象-->返回对象
- 很明显的是：Java3y类返回了不止一个实例！所以上面的代码是不行的！

厉害的程序员又想到了：进入同步代码块时再判断一下对象是否存在就稳了吧！

```java
public class Java3y {
    private Java3y() {
    }
    private static Java3y java3y = null;
    public static Java3y getJava3y() {
        if (java3y == null) {
            // 将锁的范围缩小，提高性能
            synchronized (Java3y.class) {
                // 再判断一次是否为null
                if (java3y == null) {
                    java3y = new Java3y();
                }
            }
        }
        return java3y;
    }
}
```

其实还不稳！这里会有重排序的问题：

要解决也十分简单，加上我们的volatile关键字就可以了，volatile有内存屏障的功能！

所以说，完整的DCL代码是这样子的：

```java
public class Java3y {
    private Java3y() {
    }
    private static volatile Java3y java3y = null;
    public static Java3y getJava3y() {
        if (java3y == null) {
            // 将锁的范围缩小，提高性能
            synchronized (Java3y.class) {
                // 再判断一次是否为null
                if (java3y == null) {
                    java3y = new Java3y();
                }
            }
        }
        return java3y;
    }
}
```

说明：

1. 第一次判断主要是为了提高性能
2. 第二次判断由于上了锁在这里判断为空就够了

## 2.4 静态内部类懒汉式

还可以使用静态内部类这种巧妙的方式来实现单例模式！它的原理是这样的：

- 当任何一个线程第一次调用`getInstance()`时，都会使SingletonHolder被加载和被初始化，此时静态初始化器将执行Singleton的初始化操作。(被调用时才进行初始化！)
- 初始化静态数据时，Java提供了的线程安全性保证。(所以不需要任何的同步)

```java
public class Java3y {
    private Java3y() {
    }
    // 使用内部类的方式来实现懒加载
    private static class LazyHolder {
        // 创建单例对象
        private static final Java3y INSTANCE = new Java3y();
    }
    // 获取对象
    public static final Java3y getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

静态内部类这种方式是非常推荐使用的！很多人没接触过单例模式的都不知道有这种写法，这种写法很优化也高效！

## 2.5 枚举方式实现

使用枚举就非常简单了：

```java
public enum Java3y3y {
    JAVA_3_Y_3_Y,
}
```

那这种有啥好处？？枚举的方式实现：

- 简单，直接写就行了
- 防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候(安全)！

这种也较为推荐使用！

# 3 总结

总的来说单例模式写法有5种：

- 饿汉式
- 简单懒汉式(在方法加锁)
- DCL双重检测加锁(进阶懒汉式)
- 静态内部类实现懒汉式(最推荐写法)
- 枚举方式(最安全、简洁写法)