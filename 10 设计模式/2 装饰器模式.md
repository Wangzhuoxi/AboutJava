# 1 对象增强的常用方式

很多时候我们可能对Java提供给我们的对象不满意，不能满足我们的功能。此时我们就想对Java原对象进行增强，能够实现我们想要的功能就好~

一般来说，实现对象增强有三种方式：

- 继承：继承父类，子类扩展
- 装饰器模式：使用“包装”的方式来增强对象
- 代理模式：使用代理的方式来增强对象

## 1.1 继承

最简单的方式就是继承父类，子类扩展来达到目的。虽然简单，但是这种方式的缺陷非常大：

1. 如果父类是带有数据、信息、属性的话，那么子类无法增强。
2. 子类实现了之后需求无法变更，增强的内容是固定的。

## 1.2 装饰模式

电话接口：

```javascript
// 一个良好的设计是抽取成接口或者抽象类的
public interface Phone {
    // 可以打电话
    void call();
}
```

具体的实现：

```java
public class IphoneX implements Phone {
    @Override
    public void call() {
        System.out.println("打电话给周围的人");
    }
}
```

上面我们已经拥有了一个接口还有一个默认实现。包装模式是这样干的：

首先我们弄一个装饰器，它实现了接口，以组合的方式接收我们的默认实现类。

```java
// 装饰器，实现接口
public abstract class PhoneDecorate implements Phone {
    // 以组合的方式来获取默认实现类
    private Phone phone;
    public PhoneDecorate(Phone phone) {
        this.phone = phone;
    }
    @Override
    public void call() {
        phone.call();
    }
}
```

有了装饰器以后，我们的扩展都可以以装饰器为基础进行扩展，继承装饰器来扩展就好了！

我们想要在打电话之前听音乐：

```java
// 继承着装饰器来扩展
public class MusicPhone extends PhoneDecorate {
    public MusicPhone(Phone phone) {
        super(phone);
    }
    // 定义想要扩展的功能
    public void listenMusic() {
        System.out.println("继续跑 带着赤子的骄傲，生命的闪耀不坚持到底怎能看到，与其苟延残喘不如纵情燃烧");
    }
    // 重写打电话的方法
    @Override
    public void call() {
        // 在打电话之前听音乐
        listenMusic();
        super.call();
    }
}
```

现在我也想在打完电话后通知当前的时间，于是我们也继承装饰类来扩展：

```java
// 这里继承的是MusicPhone装饰器类
public class GiveCurrentTimePhone extends PhoneDecorate  {
    public GiveCurrentTimePhone(Phone phone) {
        super(phone);
    }
    // 自定义想要实现的功能：给出当前的时间
    public void currentTime() {
        System.out.println("当前的时间是：" + System.currentTimeMillis());
    }
    // 重写要增强的方法
    @Override
    public void call() {
        super.call();
        // 打完电话后通知一下当前时间
        currentTime();
    }
}
```

可以完成任务：

```java
// 创建出最原始的实现类
Phone phone = new IphoneX();
// 装饰成打电话之前可以听音乐的功能
phone = new MusicPhone(phone);
// 装饰成打电话之后可以通知当前时间的功能
phone = new GiveCurrentTimePhone(phone);
phone.call();
```

就目前这样看起来，比我直接继承父类要麻烦，而功能效果是一样的....我们继续往下看~~

此时，我不想在打电话之前听到彩铃了，很简单：我们不装饰它就好了！(注释掉)

此时，我想在打电话前报告一下时间，在打完电话之后听彩铃。

- 注意：虽然说要改动类中的代码，但是这种改动是合理的。因为我定义出的`GiveCurrentTimePhone类`和`MusicPhone类`本身从语义上就没有规定扩展功能的执行顺序
- 而继承不一样：先继承Phone->实现MusicPhone->再继承MusicPhone实现GiveCurrentTimePhone。这是固定的，从继承的逻辑上已经写死了具体的代码，是难以改变的。

这里只需要修改MusicPhone和GiveCurrentTimePhone中的代码顺序即可。

# 2 装饰模式讲解

可能有的同学在看完上面的代码之后，还是迷迷糊糊地不知道装饰模式是怎么实现“装饰”的。下面我就再来解析一下：

- 第一步：我们有一个Phone接口，该接口定义了Phone的功能
- 第二步：我们有一个最简单的实现类iPhoneX
- 第三步：写一个装饰器抽象类PhoneDecorate，以**组合**(构造函数传递)的方式接收我们最简单的实现类iPhoneX。其实装饰器抽象类的作用就是**代理**(核心的功能还是由最简单的实现类iPhoneX来做，只不过在扩展的时候可以添加一些没有的功能而已)。
- 第四步：想要扩展什么功能，就继承PhoneDecorate装饰器抽象类，将想要增强的对象(最简单的实现类iPhoneX或者已经被增强过的对象)传进去，完成我们的扩展！

![img](https://segmentfault.com/img/remote/1460000014771841?w=1471&h=620)

往往我们的代码可以省略起来，成了这个样子(是不是和IO的非常像！)

```java
// 先增强听音乐的功能，再增强通知时间的功能
Phone phone = new GiveCurrentTimePhone(new MusicPhone(new IphoneX()));
```
**装饰模式的优缺点**

优点：

- 装饰类和被装饰类是可以独立的，低耦合的。互相都不用知道对方的存在.
- 装饰模式是继承的一种替代方案，无论包装多少层，返回的对象都是is-a的关系(上面的例子：包装完还是Phone类型)。
- 实现动态扩展，只要继承了装饰器就可以动态扩展想要的功能了。

缺点：

- 多层装饰是比较复杂的，提高了系统的复杂度。不利于我们调试~

# 3 总结

最后来补充一下包装模式和代理模式的类图：

![img](https://segmentfault.com/img/remote/1460000014771843?w=2448&h=3264)

![img](https://segmentfault.com/img/remote/1460000014771844?w=2448&h=3264)

对象增强的三种方式：

- 继承
- 包装模式
- 代理模式

那么只要遇到Java提供给我们的API不够用，我们增强一下就行了。在写代码时，某个类被写死了，功能不够用，增强一下就可以了！

