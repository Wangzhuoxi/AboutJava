# 1 代理模式简介

代理模式是面向对象编程中比较常见的设计模式。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170629213938736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

需要注意的有下面几点：

- 用户只关心接口功能，而不在乎谁提供了功能。上图中接口是 Subject。
- 接口真正实现者是上图的 RealSubject，但是它不与用户直接接触，而是通过代理。
- 代理就是上图中的 Proxy，由于它实现了 Subject 接口，所以它能够直接与用户接触。
- 用户调用 Proxy 的时候，Proxy 内部调用了 RealSubject。所以，Proxy 是中介者，它可以增强 RealSubject 操作。

# 2 静态代理

背景：我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。

现在用代码来进行模拟。

首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。

```java
public interface Movie {
    void play();
}
```

然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。

```java
public class RealMovie implements Movie {
	@Override
	public void play() {
		System.out.println("您正在观看电影 《肖申克的救赎》");
	}
}
```

这个表示真正的影片。它实现了 Movie 接口，play() 方法调用时，影片就开始播放。那么 Proxy 代理呢？

```java
public class Cinema implements Movie {
	RealMovie movie;
	public Cinema(RealMovie movie) {
		super();
		this.movie = movie;
	}
	@Override
	public void play() {
		guanggao(true);
		movie.play();
		guanggao(false);
	}
	public void guanggao(boolean isStart){
		if (isStart) {
			System.out.println("电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！");
		} else {
			System.out.println("电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！");
		}
	}
}
```

Cinema 就是 Proxy 代理对象，它有一个 play() 方法。不过调用 play() 方法时，它进行了一些相关利益的处理，那就是广告。现在，我们编写测试代码。

```java
public class ProxyTest {
	public static void main(String[] args) {		
		RealMovie realmovie = new RealMovie();		
		Movie movie = new Cinema(realmovie);	
		movie.play();
	}
}
```

然后观察结果：

```
电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！
您正在观看电影 《肖申克的救赎》
电影马上结束了，爆米花、可乐、口香糖9.8折，买回家吃吧！
```

现在可以看到，代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。

上面介绍的是静态代理的内容，为什么叫做静态呢？因为它的类型是事先预定好的，比如上面代码中的 Cinema 这个类。下面要介绍的内容就是动态代理。

# 3 动态代理

既然是代理，那么它与静态代理的功能与目的是没有区别的，唯一有区别的就是动态与静态的差别。

那么在动态代理的中这个动态体现在什么地方？

上一节代码中 Cinema 类是代理，我们需要手动编写代码让 Cinema 实现 Movie 接口，而在动态代理中，我们可以让程序在运行的时候自动在内存中创建一个实现 Movie 接口的代理，而不需要去定义 Cinema 这个类。这就是它被称为动态的原因。

假设有一个大商场，商场有很多的柜台，有一个柜台卖茅台酒。我们进行代码的模拟。

```java
public interface SellWine {
	 void maiJiu();
}
```

SellWine 是一个接口，你可以理解它为卖酒的许可证。

```java
public class MaotaiJiu implements SellWine {
    @Override
    public void maiJiu() {
        System.out.println("我卖得是茅台酒。");
    }
}
```

然后创建一个类 MaotaiJiu，对的，就是茅台酒的意思。

我们还需要一个柜台来卖酒：

```java
public class GuitaiA implements InvocationHandler {
	private Object pinpai;
	public GuitaiA(Object pinpai) {
		this.pinpai = pinpai;
	}
	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		System.out.println("销售开始  柜台是： "+ this.getClass().getSimpleName());
		method.invoke(pinpai, args);
		System.out.println("销售结束");
		return null;
	}
}
```

GuitaiA 实现了 InvocationHandler 这个类，这个类是什么意思呢？大家不要慌张，待会我会解释。

然后，我们就可以卖酒了。

```java
public class Test {
	public static void main(String[] args) {
		MaotaiJiu maotaijiu = new MaotaiJiu();	
		InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);
		SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),
				MaotaiJiu.class.getInterfaces(), jingxiao1);
		dynamicProxy.maiJiu();		
	}
}
```

这里，我们又接触到了一个新的概念，没有关系，先别管，先看结果。

```
销售开始  柜台是： GuitaiA
我卖得是茅台酒。
销售结束
```

看到没有，我并没有像静态代理那样为 SellWine 接口实现一个代理类，但最终它仍然实现了相同的功能，这其中的差别，就是之前讨论的动态代理所谓“动态”的原因。

## 3.1 动态代理语法

动态代码涉及了一个非常重要的类 Proxy。正是通过 Proxy 的静态方法 newProxyInstance 才会动态创建代理。

```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
```

- loader 自然是类加载器
- interfaces 代码要用来代理的接口
- h 一个 InvocationHandler 对象

### InvocationHandler

InvocationHandler 是一个接口，官方文档解释说，每个代理的实例都有一个与之关联的 InvocationHandler 实现类，如果代理的方法被调用，那么代理便会通知和转发给内部的 InvocationHandler 实现类，由它决定处理。

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

InvocationHandler 内部只是一个 invoke() 方法，正是这个方法决定了怎么样处理代理传递过来的方法调用。

- proxy 代理对象
- method 代理对象调用的方法
- args 调用的方法中的参数

因为，Proxy 动态产生的代理会调用 InvocationHandler 实现类，所以 InvocationHandler 是实际执行者。

GuitaiA 就是实际上卖酒的地方。

现在，我们加大难度，我们不仅要卖茅台酒，还想卖五粮液。

```java
public class Wuliangye implements SellWine {
	@Override
	public void maiJiu() {
		System.out.println("我卖得是五粮液。");
	}
}
```

Wuliangye 这个类也实现了 SellWine 这个接口，说明它也拥有卖酒的许可证，同样把它放到 GuitaiA 上售卖。

```java
public class Test {
	public static void main(String[] args) {
		MaotaiJiu maotaijiu = new MaotaiJiu();
		Wuliangye wu = new Wuliangye();

		InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);
		InvocationHandler jingxiao2 = new GuitaiA(wu);
		
		SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),
				MaotaiJiu.class.getInterfaces(), jingxiao1);
		SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),
				MaotaiJiu.class.getInterfaces(), jingxiao2);
		
		dynamicProxy.mainJiu();	
		dynamicProxy1.mainJiu();	
	}
}
```

我们来看结果：

```
销售开始  柜台是： GuitaiA
我卖得是茅台酒。
销售结束
销售开始  柜台是： GuitaiA
我卖得是五粮液。
销售结束
```

有人会问，dynamicProxy 和 dynamicProxy1 什么区别没有？他们都是动态产生的代理，都是售货员，都拥有卖酒的技术证书。

我现在扩大商场的经营，除了卖酒之外，还要卖烟。

首先，同样要创建一个接口，作为卖烟的许可证。

```java
public interface SellCigarette {
	void sell();
}
```

然后，卖什么烟呢？我是湖南人，那就芙蓉王好了。

```java
public class Furongwang implements SellCigarette {
	@Override
	public void sell() {
		System.out.println("售卖的是正宗的芙蓉王，可以扫描条形码查证。");
	}
}
```

然后再次测试验证：

```java
public class Test {

	public static void main(String[] args) {
		MaotaiJiu maotaijiu = new MaotaiJiu();		
		Wuliangye wu = new Wuliangye();		
		Furongwang fu = new Furongwang();
		
		InvocationHandler jingxiao1 = new GuitaiA(maotaijiu);
		InvocationHandler jingxiao2 = new GuitaiA(wu);	
		InvocationHandler jingxiao3 = new GuitaiA(fu);
		
		SellWine dynamicProxy = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),
				MaotaiJiu.class.getInterfaces(), jingxiao1);
		SellWine dynamicProxy1 = (SellWine) Proxy.newProxyInstance(MaotaiJiu.class.getClassLoader(),
				MaotaiJiu.class.getInterfaces(), jingxiao2);	
		
        dynamicProxy.mainJiu();	
		dynamicProxy1.mainJiu();
		
		SellCigarette dynamicProxy3 = (SellCigarette) Proxy.newProxyInstance(Furongwang.class.getClassLoader(),
				Furongwang.class.getInterfaces(), jingxiao3);
	
		dynamicProxy3.sell();	
	}
}
```

然后，查看结果：

```java
销售开始  柜台是： GuitaiA
我卖得是茅台酒。
销售结束
销售开始  柜台是： GuitaiA
我卖得是五粮液。
销售结束
销售开始  柜台是： GuitaiA
售卖的是正宗的芙蓉王，可以扫描条形码查证。
销售结束
```

结果符合预期。大家仔细观察一下代码，同样是通过 Proxy.newProxyInstance() 方法，却产生了 SellWine 和 SellCigarette 两种接口的实现类代理，这就是动态代理的魔力。

## 3.2 动态代理的秘密

一定有同学对于为什么 Proxy 能够动态产生不同接口类型的代理感兴趣，我的猜测是肯定通过传入进去的接口然后通过反射动态生成了一个接口实例。

动态生成的代理类名称是 【包名+$Proxy+id序号】。

SellWine 接口的代理类名是：`com.sun.proxy.$Proxy0`
SellCigarette 接口的代理类名是：`com.sun.proxy.$Proxy1`

这说明动态生成的 proxy class 与 Proxy 这个类同一个包。

下面用一张图让大家记住动态代理涉及到的角色。

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170629220323673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

红框中 `$Proxy0`就是通过 Proxy 动态生成的。
`$Proxy0`实现了要代理的接口。
`$Proxy0`通过调用 `InvocationHandler`来执行任务。

# 4 Cglib代理

JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。

CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。

JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

Cglib不是java自带的API，我们要使用cglib代理必须引入 cglib的jar包。

接口：

```java
public interface A {
    void buyCar();
    void sallCar(String string);
}
```

实现类：

```java
public class AImpl implements A {
    public void buyCar() {
        System.out.println("我要买车");
    }
    public void sallCar(String s){
        System.out.println("sall car" + s);
    }
    public String aa(){
        return "aa";
    }
}
```

代理类：

```java
public class CglibMethodInterceptor implements MethodInterceptor {
    public Object intercept(Object object , Method method , Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("Before");
        Object result = methodProxy.invokeSuper(object,args);
        System.out.println("After");
        return result;
    }
}
```

测试：

```java
public class CglibProxyTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(AImpl.class);
        enhancer.setCallback(new CglibMethodInterceptor());
        AImpl aImpl = (AImpl) enhancer.create();
        aImpl.buyCar();
        aImpl.sallCar("dd");
    }
}
```

代理类定义了一个拦截器，在调用目标方法之前，cglib回调MethodInterceptor接口方法拦截，来实现自己的业务逻辑，类似于JDK中的InvocationHandler接口。也就是通过intercept 调用methodProxy.invokeSuper来调用委托类的方法，而在intercept中可以做其他工作。

```java
public Object intercept(Object object , Method method , Object[] args, MethodProxy methodProxy)
```

- object：为cglib动态生成的代理实例
- method：为上文中实体类所调用的被代理的方法调用
- args：为method参数数值列表
- methodProxy：为生成代理类对方法的代理引用

- 返回：从代理实例方法调用返回的值

其中，methodProxy.invokeSuper(object,args)：调用代理类实例上的proxy方法的父类方法

简单一点就是，调用代理类实例的父类方法，为什么是父类方法，因为在创建代理类实例时，需要将代理类设置为委托类的子类，下面会有提到。

在写好代理类后，需要创建一个代理类的实例，来调用方法。

代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展。

创建代理对象的几个步骤:

```java
Enhancer enhancer = new Enhancer();   //1
enhancer.setSuperclass(AImpl.class); // 2
enhancer.setCallback(new CglibMethodInterceptor()); // 3
AImpl aImpl = (AImpl) enhancer.create();    //  4
aImpl.buyCar();
aImpl.sallCar("dd");
```

1. 创建Enhancer实例。
2. 继承被委托类，也就是说enhance对应的类为Alpml的子类。
3. enhancer.setCallback()这个方法，我们需要传入CglibMethodInterceptor的实例作为回调的对象，并且把它放入到一个Callback类型的数组里面。然后去判断这个数组是否合法。
4. 最后一步enhancer.create()返回的是一个增强的目标类的实例，此时的AImpl对象已经不是以前那个AImpl类的， 而是一个增强后的AImpl类的实例了，每个方法都有代理类中的增加语句。

# 5 三种代理方式的对比

CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。

| **代理方式**  | **实现**                                                     | **优点**                                                     | **缺点**                                                     | **特点**                                                   |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| JDK静态代理   | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口     | 实现简单，容易理解                                           | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 | 好像没啥特点                                               |
| JDK动态代理   | 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 | 不需要硬编码接口，代码复用率高                               | 只能够代理实现了接口的委托类                                 | 底层使用反射机制进行方法的调用                             |
| CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对final类以及final方法进行代理                           | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 |

# 6 代理的作用

主要作用，还是在不修改被代理对象的源码上，进行功能的增强。

这在 AOP 面向切面编程领域经常见。

在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。

主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等等。

# 7 总结

- 代理分为静态代理和动态代理两种。
- 静态代理，代理类需要自己编写代码写成。
- 动态代理，代理类通过 Proxy.newInstance() 方法生成。
- 不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。
- 静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。
- 动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。
- 代理模式本质上的目的是为了增强现有代码的功能。