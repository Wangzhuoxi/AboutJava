## [什么是非阻塞同步？](https://www.cnblogs.com/sloveling/p/11933500.html) 		

​		

同步：多线程并发访问共享数据时，保证共享数据再同一时刻只被一个或一些线程使用

阻塞：就是read时，内核缓冲区中必须有数据，如果没有数据那么就一直等待

非阻塞：就是read时，内核缓冲区中如果没有数据，也可以立刻返回，errno为EGAIN,下一次再进行读取即可。

实例：AtomicInteger

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

        return var5;
    }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

阻塞同步和非阻塞同步都是实现线程安全的两个保障手段，非阻塞同步对于阻塞同步而言主要解决了阻塞同步中线程阻塞和唤醒带来的性能问题，那什么叫做非阻塞同步呢？在并发环境下，某个线程对共享变量先进行操作，如果没有其他线程争用共享数据那操作就成功；如果存在数据的争用冲突，那就才去补偿措施，比如不断的重试机制，直到成功为止，因为这种乐观的并发策略不需要把线程挂起，也就把这种同步操作称为非阻塞同步（操作和冲突检测具备原子性）。在硬件指令集的发展驱动下，使得 "操作和冲突检测" 这种看起来需要多次操作的行为只需要一条处理器指令便可以完成，这些指令中就包括非常著名的CAS指令（Compare-And-Swap比较并交换）。



简单来说，就是如果比较后如果返回成功，就返回结果；执行后如果比较失败，就再来一次。

 