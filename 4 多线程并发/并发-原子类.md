# 1 Unsafe

## 1.1 Unsafe简介

Unsafe类，来源于`sun.misc`包。该类封装了许多类似指针操作，可以直接进行内存管理、操纵对象、阻塞/唤醒线程等操作。Java本身不直接支持指针的操作，所以这也是该类命名为Unsafe的原因之一。

J.U.C中的许多CAS方法，内部其实都是Unsafe类在操作。

比如`AtomicBoolean`的`compareAndSet`方法：

![clipboard.png](https://segmentfault.com/img/bVbexr1?w=703&h=115)

`unsafe.compareAndSwapInt`方法是个native方法。（如果对象中的字段值与期望值相等，则将字段值修改为x，然后返回true；否则返回false)：

入参的含义如下：

| 参数名称 | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| o        | 需要修改的对象                                               |
| offset   | 需要修改的字段到对象头的偏移量(通过偏移量，可以快速定位修改的是哪个字段) |
| expected | 期望值                                                       |
| x        | 要设置的值                                                   |

Unsafe类中CAS方法都是native方法，需要通过CAS原子指令完成。在讲AQS时，里面有许多涉及CLH队列的操作，其实就是通过Unsafe类完成的指针操作。

## 1.2 Unsafe对象的创建

Unsafe是一个final类，不能被继承，也没有公共的构造器，只能通过工厂方法**getUnsafe**获得Unsafe的单例。

但是**getUnsafe**方法限制了调用该方法的类的类加载器必须为**Bootstrap ClassLoader**。

Java中的类加载器可以大致划分为以下三类：

| 类加载器名称                             | 作用                                                         |
| :--------------------------------------- | :----------------------------------------------------------- |
| Bootstrap类加载器(Bootstrap ClassLoader) | 主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是JVM自身的一部分，它负责将 【JDK的安装目录】/lib路径下的核心类库，如rt.jar |
| 扩展类加载器(Extension ClassLoader)      | 该加载器负责加载【JDK的安装目录】jrelibext目录中的类库，开发者可以直接使用该加载器 |
| 系统类加载器(Application ClassLoader)    | 负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，也是默认的类加载器 |

所以在用户代码中直接调用**getUnsafe**方法，会抛出异常。因为用户自定义的类一般都是由系统类加载器加载的。

但是，是否就真的没有办法获取到Unsafe实例了呢？当然不是，要获取Unsafe对象的方法很多，这里给出一种通过反射的方法：

```java
Field f = Unsafe.class.getDeclaredField("theUnsafe");
f.setAccessible(true);
Unsafe unsafe = (Unsafe) f.get(null);
```

但是，除非对Unsafe的实现非常清楚，否则应尽量避免直接使用Unsafe来进行操作。

# 2 AtomicInteger

AtomicInteger，应该是atomic框架中用得最多的原子类了。顾名思义，AtomicInteger是Integer类型的线程安全原子类，可以在应用程序中以原子的方式更新int值。

### 2.1 创建AtomicInteger对象

AtomicInteger提供了两个构造器，使用默认构造器时，内部int类型的value值为0：

```java
AtomicInteger atomicInt = new AtomicInteger();
```

AtomicInteger类的内部并不复杂，所有的操作都针对内部的int值——value，并通过Unsafe类来实现线程安全的CAS操作：

我们来看下**incrementAndGet**内部：

内部调用了Unsafe类的**getAndAddInt**方法，以原子方式将value值增加1，然后返回增加前的原始值。

### 2.2 AtomicInteger的使用

AtomicInteger中有一个比较特殊的方法——**lazySet**：

**lazySet**方法是**set**方法的不可见版本。什么意思呢？

我们知道通过volatile修饰的变量，可以保证在多处理器环境下的“可见性”。也就是说当一个线程修改一个共享变量时，其它线程能立即读到这个修改的值。volatile的实现最终是加了内存屏障：

1. 保证写volatile变量会强制把CPU写缓存区的数据刷新到内存
2. 读volatile变量时，使缓存失效，强制从内存中读取最新的值
3. 由于内存屏障的存在，volatile变量还能阻止重排序

**lazySet**内部调用了Unsafe类的**putOrderedInt**方法，通过该方法对共享变量值的改变，不一定能被其他线程立即看到。也就是说以普通变量的操作方式来写变量。

为什么会有这种奇怪方法？什么情况下需要使用lazySet呢？

考虑下面这样一个场景：

```java
private AtomicInteger ai = new AtomicInteger();
lock.lock();
try
{
    // ai.set(1);
}
finally
{
    lock.unlock();
}
```

由于锁的存在：

- **lock()**方法获取锁时，和volatile变量的读操作一样，会强制使CPU缓存失效，强制从内存读取变量。
- **unlock()**方法释放锁时，和volatile变量的写操作一样，会强制刷新CPU写缓冲区，把缓存数据写到主内存

所以，上述`ai.set(1)`可以用`ai.lazySet(1)`方法替换：

由锁来保证共享变量的可见性，以设置普通变量的方式来修改共享变量，减少不必要的内存屏障，从而提高程序执行的效率。

| 方法声明                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) | 使用IntBinaryOperator 对当前值和x进行计算，并更新当前值，返回计算后的新值 |
| int addAndGet(int delta)                                     | 以原子方式将给定值与当前值相加，返回相加后的新值             |
| boolean compareAndSet(int expect, int update)                | 如果当前值 == expect，则以原子方式将该值设置为给定的更新值（update） |
| int decrementAndGet()                                        | 以原子方式将当前值减 1，返回新值                             |
| int get()                                                    | 获取当前值                                                   |
| int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) | 使用IntBinaryOperator 对当前值和x进行计算，并更新当前值，返回计算前的旧值 |
| int getAndAdd(int delta)                                     | 以原子方式将给定值与当前值相加，返回旧值                     |
| int getAndDecrement()                                        | 以原子方式将当前值减 1，返回旧值                             |
| int getAndIncrement()                                        | 以原子方式将当前值加 1，返回旧值                             |
| int getAndSet(int newValue)                                  | 以原子方式设置为给定值，并返回旧值                           |
| int getAndUpdate(IntUnaryOperator updateFunction)            | 使用IntBinaryOperator 对当前值进行计算，并更新当前值，返回计算前的旧值 |
| int incrementAndGet()                                        | 以原子方式将当前值加 1，返回新值                             |
| void lazySet(int newValue)                                   | 设置为给定值，但不保证值的改变被其他线程立即看到             |
| void set(int newValue)                                       | 设置为给定值                                                 |
| int updateAndGet(IntUnaryOperator updateFunction)            | 使用IntBinaryOperator 对当前值进行计算，并更新当前值，返回计算后的新值 |
| boolean weakCompareAndSet(int expect, int update)            | weakCompareAndSet无法保证除操作目标外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。 |

与**AtomicInteger**类似的原子类还有**AtomicBoolean**和**AtomicLong**，底层都是通过Unsafe类做CAS操作，来原子的更新状态值。

# 3 AtomicReference

AtomicReference，顾名思义，就是以原子方式更新对象引用。

可以看到，AtomicReference持有一个对象的引用——**value**，并通过Unsafe类来操作该引用:

**为什么需要AtomicReference？难道多个线程同时对一个引用变量赋值也会出现并发问题？**

引用变量的赋值本身没有并发问题，也就是说对于引用变量var ，类似下面的赋值操作本身就是原子操作:
`Foo var = ... ;`

AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。

我们知道，当多个线程同时访问共享资源时，一般需要以加锁的方式控制并发：上述访问方式其实是一种对共享资源加**悲观锁**的访问方式。

而AtomicReference提供了**以无锁方式访问共享资源**的能力，看看如何通过AtomicReference保证线程安全，

总结出AtomicReference的一般使用模式如下：

```java
AtomicReference<Object> ref = new AtomicReference<>(new Object());
Object oldCache = ref.get();

// 对缓存oldCache做一些操作
Object newCache  =  someFunctionOfOld(oldCache); 

// 如果期间没有其它线程改变了缓存值，则更新
boolean success = ref.compareAndSet(oldCache , newCache);
```

**compareAndSet**方法会将入参的**expect**变量所指向的对象和AtomicReference中的引用对象进行比较，如果两者指向同一个对象，则将AtomicReference中的引用对象重新置为**update**，修改成功返回true，失败则返回false。也就是说，**AtomicReference其实是比较对象的引用**。

## 3.1 CAS操作可能存在的问题

CAS操作可能存在**ABA**的问题，就是说：

假如一个值原来是A，变成了B，又变成了A，那么CAS检查时会发现它的值没有发生变化，但是实际上却变化了。

一般来讲这并不是什么问题，比如数值运算，线程其实根本不关心变量中途如何变化，只要最终的状态和预期值一样即可。

但是，有些操作会依赖于对象的变化过程，此时的解决思路一般就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A - 2B - 3A。

## 3.2 AtomicStampedReference的引入

AtomicStampedReference就是上面所说的加了版本号的AtomicReference。

### 3.2.1 AtomicStampedReference原理

先来看下如何构造一个AtomicStampedReference对象，AtomicStampedReference只有一个构造器：

可以看到，除了传入一个初始的引用变量**initialRef**外，还有一个**initialStamp**变量，**initialStamp**其实就是版本号（或者说时间戳），用来唯一标识引用变量。

在构造器内部，实例化了一个**Pair**对象，**Pair**对象记录了对象引用和时间戳信息，采用int作为时间戳，实际使用的时候，要保证时间戳唯一（一般做成自增的），如果时间戳如果重复，还会出现**ABA**的问题。

AtomicStampedReference的所有方法，其实就是Unsafe类针对这个**Pair**对象的操作。
和AtomicReference相比，AtomicStampedReference中的每个引用变量都带上了pair.stamp这个版本号，这样就可以解决CAS中的ABA问题了。

### 3.2.2 AtomicStampedReference使用

来看下AtomicStampedReference的使用：

```java
AtomicStampedReference<Foo> asr = new AtomicStampedReference<>(null,0);  // 创建AtomicStampedReference对象，持有Foo对象的引用，初始为null，版本为0

int[] stamp=new int[1];
Foo oldRef = asr.get(stamp);   // 调用get方法获取引用对象和对应的版本号
int oldStamp=stamp[0];         // stamp[0]保存版本号

asr.compareAndSet(oldRef, null, oldStamp, oldStamp + 1)   //尝试以CAS方式更新引用对象，并将版本号+1
```

我们知道，AtomicStampedReference内部保存了一个pair对象，该方法的逻辑如下：

如果AtomicStampedReference内部pair的引用变量、时间戳与入参**expectedReference**、**expectedStamp**都一样，说明期间没有其它线程修改过AtomicStampedReference，可以进行修改。此时，会创建一个新的Pair对象（casPair方法，因为Pair是Immutable类）。

但这里有段优化逻辑，就是如果 `newReference == current.reference && newStamp == current.stamp`，说明用户修改的新值和AtomicStampedReference中目前持有的值完全一致，那么其实不需要修改，直接返回true即可。

## 3.3 AtomicMarkableReference

我们在讲**ABA**问题的时候，引入了AtomicStampedReference。

AtomicStampedReference可以给引用加上版本号，追踪引用的整个变化过程，如：
A -> B -> C -> D - > A，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了3次。

但是，有时候，我们并不关心引用变量更改了几次，只是单纯的关心**是否更改过**，所以就有了**AtomicMarkableReference**：

可以看到，AtomicMarkableReference的唯一区别就是**不再用int标识引用，而是使用boolean变量——表示引用变量是否被更改过**。

从语义上讲，AtomicMarkableReference对于那些不关心引用变化过程，只关心引用变量是否变化过的应用会更加友好。

# 4 Atomic数组

Atomic数组，顾名思义，就是能以原子的方式，操作数组中的元素。

JDK提供了三种类型的原子数组：`AtomicIntegerArray`、`AtomicLongArray`、`AtomicReferenceArray`。

这三种类型大同小异，AtomicIntegerArray对应AtomicInteger，AtomicLongArray对应AtomicLong，AtomicReferenceArray对应AtomicReference。

其实阅读源码也可以发现，这些数组原子类与对应的普通原子类相比，只是多了通过索引找到内存中元素地址的操作而已。

注意：原子数组并不是说可以让线程以原子方式一次性地操作数组中所有元素的数组，而是指对于数组中的每个元素，可以以原子方式进行操作。

说得简单点，**原子数组类型**其实可以看成**原子类型组成的数组**。

比如：

```java
AtomicIntegerArray  array = new AtomicIntegerArray(10);
array.getAndIncrement(0);   // 将第0个元素原子地增加1
```

等同于

```java
AtomicInteger[]  array = new AtomicInteger[10];
array[0].getAndIncrement();  // 将第0个元素原子地增加1
```

## 4.1 AtomicIntegerArray原理

**AtomicIntegerArray**其实和其它原子类区别并不大，只不过构造的时候传入的是一个**int[]**数组，然后底层通过**Unsafe**类操作数组：

可以看到，**AtomicIntegerArray**提供了两种构造器，本质都是内部利用**array**变量保存一个**int[]**数组引用。

另外，**AtomicIntegerArray**利用**Unsafe**类直接操作**int[]**对象的内存地址，以达到操作数组元素的目的，几个关键的变量解释如下：

```java
int base = unsafe.arrayBaseOffset(int[].class);
```


Unsafe类的**arrayBaseOffset**方法：返回指定类型数组的第一个元素地址相对于数组起始地址的偏移值。

```java
int scale = unsafe.arrayIndexScale(int[].class);
```


Unsafe类的**arrayIndexScale**方法：返回指定类型数组的元素所占用的字节数。比如int[]数组中的每个int元素占用4个字节，就返回4。

那么，通过`base + i * sacle` 其实就可以知道 索引**i**的元素在数组中的内存起始地址。
但是，观察**AtomicIntegerArray**的**byteOffset**方法，是通过`i << shift + base` 的公式计算元素的起始地址的：
$$
i<<shift+base = i * 2^{shift}+base
$$
这里，
$$
2^{shift}
$$
其实就等于**scale**。

`shift = 31 - Integer.numberOfLeadingZeros(scale)`，`Integer.numberOfLeadingZeros(scale)`是将**scale**转换为2进制，然后从左往右数连续0的个数。

读者可以自己计算下：
`shift = 31 - Integer.numberOfLeadingZeros(4) = 31 - 29 =2`

之所以要这么绕一圈，其实是处于性能的考虑，通过移位计算乘法的效率往往更高。

# 5 FieldUpdater

在`java.util.concurrent.atomic`包中，由三个比较特殊的原子类：`AtomicIntegerFieldUpdater`、`AtomicLongFieldUpdater`、`AtomicReferenceFieldUpdater`。
通过名称可以看到，这几类的功能大致相同，只是针对的类型有所不同。

所谓**AtomicXXXFieldUpdater**，就是可以**以一种线程安全的方式操作非线程安全对象的某些字段**。光这么说有点难理解，我们通过一个例子来看下。

**AtomicIntegerFiledUpdater**的引入，使得我们可以在**不修改用户代码（调用方）的情况下，就能实现并发安全性**。

这也是**AtomicXXXFieldUpdater**引入的一个重要原因，单纯从功能上来讲，能用**AtomicXXXFieldUpdater**实现的并发控制，同步器和其它原子类都能实现，但是使用**AtomicXXXFieldUpdater**，符合面向对象设计的一个基本原则——开闭原则，尤其是对一些遗留代码的改造上。

另外，使用**AtomicXXXFieldUpdater**，不需要进行任何同步处理，单纯的使用CAS+自旋操作就可以实现同步的效果。这也是整个atomic包的设计理念之一。

## 5.1 AtomicReferenceFieldUpdater原理

`AtomicIntegerFieldUpdater`、`AtomicLongFieldUpdater`、`AtomicReferenceFieldUpdater`这三个类大同小异，**AtomicIntegerFieldUpdater**只能处理**int**原始类型的字段，**AtomicLongFieldUpdater**只能处理long原始类型的字段，**AtomicReferenceFieldUpdater**可以处理所有引用类型的字段。

本节以**AtomicReferenceFieldUpdater**为例，介绍下FiledUpdater的基本原理。

### 5.1.1 AtomicReferenceFieldUpdater对象的创建

AtomicReferenceFieldUpdater本身是一个抽象类，没有公开的构造器，只能通过静态方法**newUpdater**创建一个AtomicReferenceFieldUpdater子类对象：

newUpdater的三个入参含义如下：

| 入参名称  | 含义           |
| :-------- | :------------- |
| tclass    | 目标对象的类型 |
| vclass    | 目标字段的类型 |
| fieldName | 目标字段名     |

**AtomicReferenceFieldUpdaterImpl**是AtomicReferenceFieldUpdater的一个内部类，并继承了AtomicReferenceFieldUpdater。AtomicReferenceFieldUpdater的API，基本都是委托AtomicReferenceFieldUpdaterImpl 来实现的。

来看下**AtomicReferenceFieldUpdaterImpl** 对象的构造，其实就是一系列的权限检查：

通过源码，可以看到**AtomicReferenceFieldUpdater**的使用必须满足以下条件：

1. AtomicReferenceFieldUpdater只能修改对于它可见的字段，也就是说对于目标类的某个字段field，如果修饰符是private，但是AtomicReferenceFieldUpdater所在的使用类不能看到field，那就会报错；
2. 目标类的操作字段，必须用volatile修饰；
3. 目标类的操作字段，不能是static的；
4. AtomicReferenceFieldUpdater只适用于引用类型的字段；

### 5.1.2 AtomicReferenceFieldUpdater的方法原理

AtomicReferenceFieldUpdater中所有的方法都是基于**Unsafe**类操作，看下最常用的方法**compareAndSet**：

![clipboard.png](https://segmentfault.com/img/bVbeI9x?w=707&h=113)

通过偏移量**offset**获取字段的地址，然后利用Unsafe进行CAS更新。

# 6 LongAdder

JDK1.8时，`java.util.concurrent.atomic`包中提供了一个新的原子类：`LongAdder`。

根据Oracle官方文档的介绍，LongAdder在高并发的场景下会比它的前辈————AtomicLong 具有更好的性能，代价是消耗更多的内存空间：

**为什么要引入LongAdder？ AtomicLong在高并发的场景下有什么问题吗？ 如果低并发环境下，LongAdder和AtomicLong性能差不多，那LongAdder是否就可以替代AtomicLong了？**

## 6.1 LongAdder简介

### 6.1.1 为什么要引入LongAdder？

我们知道，**AtomicLong**是利用了底层的CAS操作来提供并发性的，比如**addAndGet**方法：

上述方法调用了**Unsafe**类的**getAndAddLong**方法，该方法是个**native**方法，它的逻辑是采用自旋的方式不断更新目标值，直到更新成功。

在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时**AtomicLong**的自旋会成为瓶颈。

这就是**LongAdder**引入的初衷——解决高并发环境下**AtomicLong**的自旋瓶颈问题。

### 6.1.2 LongAdder快在哪里？

既然说到**LongAdder**可以显著提升高并发环境下的性能，那么它是如何做到的？这里先简单的说下**LongAdder**的思路，第二部分会详述**LongAdder**的原理。

我们知道，**AtomicLong**中有个内部变量**value**保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。

**LongAdder**的基本思路就是**分散热点**，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。

ConcurrentHashMap中的“分段锁”其实就是类似的思路。

### 6.1.3 LongAdder能否替代AtomicLong？

可以看到，**LongAdder**提供的API和**AtomicLong**比较接近，两者都能以原子的方式对long型变量进行增减。

但是**AtomicLong**提供的功能其实更丰富，尤其是**addAndGet**、**decrementAndGet**、**compareAndSet**这些方法

**addAndGet**、**decrementAndGet**除了单纯的做自增自减外，还可以立即获取增减后的值，而**LongAdder**则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的控制计数，做计数比较，**AtomicLong**也更合适。

另外，从空间方面考虑，**LongAdder**其实是一种“空间换时间”的思想，从这一点来讲**AtomicLong**更适合。当然，如果你一定要跟我杠现代主机的内存对于这点消耗根本不算什么，那我也办法。

总之，低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。适合的才是最好的，如果真出现了需要考虑到底用AtomicLong好还是LongAdder的业务场景，那么这样的讨论是没有意义的，因为这种情况下要么进行性能测试，以准确评估在当前业务场景下两者的性能，要么换个思路寻求其它解决方案。

## 6.2 LongAdder原理

之前说了，**AtomicLong**是多个线程针对单个热点值value进行原子操作。而**LongAdder**是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作。

比如有三个ThreadA、ThreadB、ThreadC，每个线程对value增加10。

对于**AtomicLong**，最终结果的计算始终是下面这个形式：

value=10+10+10=30

但是对于**LongAdder**来说，内部有一个`base`变量，一个`Cell[]`数组。

`base`变量：非竞态条件下，直接累加到该变量上

`Cell[]`数组：竞态条件下，累加个各个线程自己的槽`Cell[i]`中

最终结果的计算是下面这个形式：
$$
value=base+ \sum_{i=0}^{n}Cell[i]
$$

### 6.2.1 LongAdder的内部结构

**LongAdder**只有一个空构造器，其本身也没有什么特殊的地方，所有复杂的逻辑都在它的父类**Striped64**中。

来看下**Striped64**的内部结构，这个类实现一些核心操作，处理64位数据。

**Striped64**只有一个空构造器，初始化时，通过Unsafe获取到类字段的偏移量，以便后续CAS操作：

上面有个比较特殊的字段是`threadLocalRandomProbe`，可以把它看成是线程的hash值。这个后面我们会讲到。

定义了一个内部Cell类，这就是我们之前所说的槽，每个Cell对象存有一个value值，可以通过**Unsafe**来CAS操作它的值：

其它的字段：

可以看到**Cell[]**就是之前提到的槽数组，**base**就是非并发条件下的基数累计值。

### 6.2.2 LongAdder的核心方法

假设现在有一个**LongAdder**对象la，四个线程A、B、C、D同时对la进行累加操作。

①**ThreadA调用add方法（假设此时没有并发）：**

初始时Cell[]为null，base为0。所以ThreadA会调用**casBase**方法（定义在**Striped64**中），因为没有并发，CAS操作成功将base变为10：

可以看到，如果线程A、B、C、D线性执行，那**casBase**永远不会失败，也就永远不会进入到**base**方法的if块中，所有的值都会累积到**base**中。

那么，如果任意线程有并发冲突，导致**caseBase**失败呢？

失败就会进入if方法体会先再次判断**Cell[]**槽数组有没初始化过，如果初始化过了，以后所有的CAS操作都只针对槽中的Cell；否则，进入**longAccumulate**方法。

整个**add**方法的逻辑如下图：

![clipboard.png](https://segmentfault.com/img/bVbeOyW?w=663&h=748)

可以看到，只有从未出现过并发冲突的时候，base基数才会使用到，一旦出现了并发冲突，之后所有的操作都只针对`Cell[]`数组中的单元Cell。
如果`Cell[]`数组未初始化，会调用父类的`longAccumelate`去初始化`Cell[]`，如果`Cell[]`已经初始化但是冲突发生在`Cell`单元内，则也调用父类的`longAccumelate`，此时可能就需要对`Cell[]`扩容了。

**这也是LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。**

我们来看下**Striped64**的核心方法**longAccumulate**到底做了什么：

上述代码首先给当前线程分配一个hash值，然后进入一个自旋，这个自旋分为三个分支：

- **CASE1：Cell[]数组已经初始化**
- **CASE2：Cell[]数组未初始化**
- **CASE3：Cell[]数组正在初始化中**

**2 Cell[]数组未初始化**

初始时**Cell[]**数组还没有初始化，所以会进入分支②：

首先会将**cellsBusy**置为**1-加锁状态**

然后，初始化**Cell[]**数组（初始大小为2），根据当前线程的hash值计算映射的索引，并创建对应的**Cell**对象，**Cell**单元中的初始值x就是本次要累加的值。

**3 Cell[]数组正在初始化中**

如果在初始化过程中，另一个线程ThreadB也进入了**longAccumulate**方法，就会进入分支③：

可以看到，分支③直接操作**base**基数，将值累加到**base**上。

**1 Cell[]数组已经初始化**

如果初始化完成后，其它线程也进入了**longAccumulate**方法，就会进入分支①：

![clipboard.png](https://segmentfault.com/img/bVbeOz3?w=1235&h=859)

### 6.2.3 LongAdder的sum方法

返回累加的和，也就是当前时刻的计数值。

此返回值可能不是绝对准确的，因为调用这个方法时还有其他线程可能正在进行计数累加，方法的返回时刻和调用时刻不是同一个点，在并发的情况下，这个值只是近似准确的计数值。

需要注意的是，这个方法只能得到某个时刻的近似值，这也就是**LongAdder**并不能完全替代**LongAtomic**的原因之一。

## 6.3 LongAdder的其它兄弟

JDK1.8时，`java.util.concurrent.atomic`包中，除了新引入**LongAdder**外，还有引入了它的三个兄弟类：**LongAccumulator**、**DoubleAdder**、**DoubleAccumulator**

### 6.3.1 LongAccumulator

**LongAccumulator**是**LongAdder**的增强版。**LongAdder**只能针对数值的进行加减运算，而**LongAccumulator**提供了自定义的函数操作。

通过**LongBinaryOperator**，可以自定义对入参的任意操作，并返回结果（**LongBinaryOperator**接收2个long作为参数，并返回1个long）

**LongAccumulator**内部原理和LongAdder几乎完全一样，都是利用了父类**Striped64**的**longAccumulate**方法。这里就不再赘述了，读者可以自己阅读源码。

### 6.3.2 DoubleAdder和DoubleAccumulator

从名字也可以看出，**DoubleAdder**和**DoubleAccumulator**用于操作double原始类型。

与**LongAdder**的唯一区别就是，其内部会通过一些方法，将原始的double类型，转换为long类型，其余和**LongAdder**完全一样：

