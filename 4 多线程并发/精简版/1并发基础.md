#### 1 线程和进程?

**进程**：程序的一次执行过程，是系统运行程序的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

**线程**：线程是一个比进程更小的执行单位，多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，线程间切换负担比进程小，线程也被称为轻量级进程。

**线程与进程的区别**：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

**多线程的优点**：提高了CPU和IO的利用率，分解系统任务。

**多线程的缺点**：内存泄漏、上下文切换、死锁等。

**上下文切换**：任务从保存到再加载的过程就是一次上下文切换。

#### 2 线程状态转换

![img](https://camo.githubusercontent.com/4a6f561b717ec25dd125fd3e93c61570a5e74f95/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61646662343237642d336232312d343064372d613134322d3735376634656437333037392e706e67)

1. **新建**new：创建后尚未启动
2. **可运行**Runnable：包含了操作系统的运行态和就绪态
3. **阻塞**Blocking：等待获取一个排它锁，如果其线程释放了锁就会结束此状态
4. **无限期等待**Waiting：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片
   进入方法：Object.wait/Thread.join/LockSupport.park
   退出方法：Object.notify/Object.notifyAll/LockSupport.unpark
5. **限期等待**Timed Waiting：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒
   进入方法：Thread.sleep/Object.wait/Thread.join/LockSupport.parkNanos
   退出方法：时间结束/Object.notify/Object.notifyAll/被调用的线程执行完(join)/LockSupport.unparkNanos
6. **死亡**Terminated：可能是线程结束任务后自己结束，也可能是异常而结束。

阻塞和等待的区别：阻塞是被动的，等待获取锁；等待是主动的。

**sleep方法和wait方法区别和共同点：**

- 两者最主要的区别在于：sleep方法没有释放锁，而wait方法释放了锁 。
- 两者都可以暂停线程的执行。
- Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
- wait方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify或者notifyAll方法。sleep方法执行完成后，线程会自动苏醒。

#### 3 使用线程

- 实现 Runnable 接口；
- 实现 Callable 接口；
- 继承 Thread 类；

实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。

**线程优先级**：线程优先级具有继承特性和随机性。（1~10，默认5）

#### 4 中断机制

一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。

通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。

调用 interrupt() 方法会设置线程的中断标记，调用 interrupted() 方法会判断线程的中断状态并清除。

调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。

#### 5 互斥同步

第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。

**synchronized关键字**：

1. 同步一个代码块：底层是moniterenter和moniterexit关键字
2. 同步一个实例方法：作用于同一个对象，底层是ACC_SYNCHRONIZED关键字
3. 同步一个静态方法：作用于整个类

**ReentrantLock显式锁**：通过lock和unlock来锁定代码块

两者的比较：

1. **锁的实现**：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
2. **性能**：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized与ReentrantLock大致相同。
3. **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。
4. **公平锁**：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
5. **锁绑定多个条件**：一个 ReentrantLock 可以同时绑定多个 Condition 对象。

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。

#### 6 线程之间的协作

当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，就需要对线程进行协调。

**join方法**：在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

**wait/notify/notifyAll方法**：调用wait使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用notify或者notifyAll来唤醒挂起的线程。它们属于Object类。

只能用在同步方法或者同步控制块中使用，否则会在运行时抛出异常。

使用 wait() 挂起期间，线程会释放锁，来让其他线程进入同步代码块执行notify方法唤醒挂起线程。

**await/signal/signalAll方法**：JUC提供了Condition类来实现线程之间的协调，可以在Condition上调用await方法使线程等待，其它线程调用signal或signalAll方法唤醒等待的线程。

相比于wait这种等待方式，await可以指定等待的条件，因此更加灵活。

**wait() 和 sleep() 的区别** ：wait是Object 的方法，而sleep是Thread的静态方法；wait会释放锁，sleep不会。

#### 7 Java 内存模型

Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。

![img](https://camo.githubusercontent.com/42696b8f0b2cfbf78024f9cd0d806e0e6decb5fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38623765626261642d393630342d343337352d383465332d6634313230393964313730632e706e67)

**内存模型三大特性**

- **原子性**：内存模型保证了上述交互是原子性，但64位数据会被分两次32位来操作，所以不具有原子性。
  实现方式：synchronized/AtomicInteger
- **可见性**：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。
  实现方式：volatile/synchronized/final
- **有序性**：在本线程内观察，所有操作都是有序的，在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。
  实现方式：volatile/synchronized

**先行发生原则**

1. 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作。
2. 管程锁定规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。
3. volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
4. 线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
5. 线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。
6. 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。
7. 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
8. 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。

#### 8 线程安全

线程安全有以下几种实现方式：

**不可变**：不可变的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。

不可变的类型：final关键字修饰的基本类型、String、枚举类型、Number部分子类、Collections.unmodifiableXXX() 方法获取的不可变的集合。

**互斥同步**：synchronized 和 ReentrantLock。

**非阻塞同步**：互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

CAS(乐观并发策略)：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。

AtomicInteger：整数原子类 AtomicInteger 的方法调用了Unsafe类的CAS操作。

**无同步方案**：栈封闭/线程本地存储/可重入代码

#### 9 锁优化

锁的四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态

**自旋锁**：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。（自适应自旋锁）

**锁消除**：对于被检测出不可能存在竞争的共享数据的锁进行消除。

**锁粗化**：如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。

**轻量级锁**：轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

**偏向锁**：偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

#### 10 死锁

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

**死锁必须具备以下四个条件**：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**如何避免线程死锁**：只要破坏产生死锁的四个条件中的其中一个就可以。

1. 破坏互斥条件：无法破坏
2. 破坏请求与保持条件：一次性申请所有的资源
3. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。