## 锁框架

### 1 接口

Lock接口：synchronized增强版，提供了限时锁等待、锁中断、锁尝试。

- lock()：锁不可用则阻塞直到可用。
- lockInteruptibly()：锁不可用可以被中断。

Condition接口：是Object类wait/notify/notifyAll的替代品，和Lock配合使用。

执行wait等待会立即释放锁，等待其他线程唤醒。

ReadWriteLock接口：提供独占的写锁和共享的读锁。使用于读多写少、读操作时间长的场景

### 2 ReentrantLock

实现了Lock接口，一种可重入的独占锁。比synchronized功能更强大，利用AQS实现。

可以指定公平/非公平策略。公平适用于线程持有锁的时间较长或线程请求锁的平均间隔较长。

### 3 ReentrantReadWriteLock

实现ReadWriteLock接口，具有如下特点：

支持公平/非公平、支持锁重入、支持锁降级、Condition条件等待（读锁无法获取）

### 4 LockSupport

工具类用来创建阻塞原语，核心park和unpark。内部使用许可（上限为1）来阻塞和唤醒。

park方法会响应中断但不会抛出异常，park的重载可以传入一个blocker对象提供监视诊断。

### 5 AQS

AQS框架提供一套通用的机制来管理同步状态、阻塞/唤醒线程、管理等待队列。

AQS框架分离了构建同步器时的一系列关注点，它的所有操作都围绕着资源——同步状态来展开，并替用户解决了如下问题：（模板方法设计模式）

1. 资源是可以被同时访问？还是在同一时间只能被一个线程访问？（共享/独占功能）
2. 访问资源的线程如何进行并发管理？（等待队列）
3. 如果线程等不及资源了，如何从等待队列退出？（超时/中断）

AQS框架将剩下的一个问题留给用户：什么是资源？如何定义资源是否可以被访问？

- ReentrantLock：资源表示独占锁。State为0表示锁可用；为1表示被占用；为N表示重入的次数
- CountDownLatch：资源表示倒数计数器。State为0表示计数器归零，所有线程都可以访问资源；为N表示计数器未归零，所有线程都需要阻塞。
- Semaphore：资源表示信号量或者令牌。State≤0表示没有令牌可用，所有线程都需要阻塞；大于0表示由令牌可用，线程每获取一个令牌，State减1，线程没释放一个令牌，State加1。
- ReentrantReadWriteLock：资源表示共享的读锁和独占的写锁。state逻辑上被分成两个16位的unsigned short，分别记录读锁被多少线程使用和写锁被重入的次数。

综上AQS框架提供了以下功能：

- 提供一套模板方法：tryAcquire/tryRelease/tryAcquireShared/tryReleaseShared/isHeldExclusively
- 支持中断和超时
- 支持独占和共享
- 支持Condition条件等待

**AQS原理简述**

AQS框架分离了构建同步器时的一系列关注点，它的所有操作都围绕着资源——同步状态来展开，因此，围绕着资源，衍生出三个基本问题：

1. 同步状态的管理（单个int来保存，并暴露getState、setState和compareAndSetState方法）

2. 阻塞/唤醒线程的操作（通过LockSupport工具类）

3. 线程等待队列的管理（CLH队列，节点是对线程的包装，分为独占和共享）

等待队列状态值：

- CANCELLED(1)：取消。表示当前结点被中断或超时，需要移出队列
- SIGNAL(-1)：发信号。表示后驱结点被阻塞了（当前结点在入队后、阻塞前，应确保将其prev结点类型改为SIGNAL，以便prev结点取消或释放时将当前结点唤醒。）
- CONDITION(-2)：Condition专用。表示当前结点在Condition队列中，因为等待某个条件而被阻塞了
- PROPAGATE(-3)：传播。适用于共享模式（比如连续的读操作结点可以依次进入临界区，设为PROPAGATE有助于实现这种迭代操作。）
- INITIAL(0)：默认。新结点会处于这种状态

对于CLH队列，当线程请求资源时，如果请求不到，会将线程包装成结点，将其挂载在队列尾部。

### 6 AQS的独占功能

以ReentrantLock为例，说明AQS的（公平）独占功能。

假设：ThreadA、ThreadB、ThreadC，一个公平的独占锁，3个线程会依次尝试去获取锁。

1. ThreadA首先获取锁：核心方法是实现的tryAcquire方法尝试获取锁，此时获取成功，等待队列为空。
2. ThreadB开始获取锁：tryAcquire获取失败，将当前线程包装成共享节点添加到等待队列尾部（插入的过程使用自旋保证插入成功），然后调用acquireQueued先尝试让首节点获取锁，失败后将前驱状态设为SIGNAL（-1）确保自己可以被唤醒然后阻塞。
3. ThreadC开始获取锁：过程同上。
4. ThreadA释放锁：核心方法是实现的tryRelease方法尝试释放锁，成功后唤醒队列的首节点（ThreadB）。
5. ThreadB唤醒后继续执行：ThreadB唤醒后先返回一个中断标志，表示在阻塞期间是否被中断过。然后自旋获取锁，成功后设置队列新的首节点。
6. ThreadB释放锁：过程和ThreadA一样，唤醒队首节点（ThreadC），ThreadC从阻塞处继续执行，然后尝试获取锁，成功后执行，最后释放锁，同样去唤醒首节点，此时没有线程等待，过程结束。

**非公平策略原理**：不同点就是少了队列中是否有其它线程排在当前线程前的判断。

**中断的支持**：lockInterruptibly方法支持响应中断，在acquireQueued中只是用一个标志记录中断，而lockInterruptibly会直接抛出异常。

**限时等待的支持**：tryLock方法在指定的时间内尝试获取锁，获取不到就返回。在超时前不断尝试获取锁，获取不到则阻塞，加上了等待时间的判断。

### 7 AQS的Condition等待

Condition接口的实现类在AQS内部ConditionObject，复用AQS的节点维护一个条件队列。

假设现在有3个线程：ThreadA、ThreadB、ThreadC，一个Conditon实现对象。

1. ThreadA调用lock方法获取锁然后调用await方法：先判断一次中断，然后将线程包装成节点插入**条件队列**（state=CONDITION-2），插入完后会释放锁，最后判断当前节点是否在**等待队列**中，不在则阻塞。
2. ThreadB获取到锁并调用signal方法：删除条件队列队首节点，插入到等待队列中（过程是上述的独占插入过程）
3. ThreadB释放锁：释放后会去唤醒等待队列的队首节点（ThreadA）
4. ThreadA从唤醒处继续执行：被唤醒后尝试获取锁成功。

总结：当线程在指定Condition对象上等待的时候，其实就是将线程包装成结点，加入了条件队列，然后阻塞。当线程被通知唤醒时，则是将条件队列中的结点转换成等待队列中的结点，之后的处理就和独占功能完全一样。

### 8 AQS的共享功能

以CountDownLatch为例，分析AQS的共享功能。

假设现在有3个线程，ThreadA、ThreadB、mainThread，CountDownLatch初始计数为1：`CountDownLatch switcher = new CountDownLatch(1);`

1. 创建CountDownLatch：需要传入初始计数值，就是同步状态state的值。
2. ThreadA调用await()方法等待：await方法响应中断。核心方法是实现的tryAcquireShared方法尝试获取锁（当state=0才能成功），获取失败后将当前线程包装成共享节点插入等待队列，然后再尝试获取锁一次失败就进入阻塞（前驱置为SIGNAL-1）
3. ThreadB调用await()方法等待：过程同上
4. 主线程main调用countDown()放行：调用后计数值减为0则唤醒等待队列队首节点（ThreadA）。
5. ThreadA从原阻塞处继续向下执行：ThreadA自旋尝试获取锁（计数值为0表示无锁状态），成功后传播唤醒后续节点（ThreadB）
6. ThreadB从原阻塞处继续向下执行：过程同上，获取成功并唤醒后续节点（等待队列没有节点了）

总结：共享功能的结点，一旦被唤醒，会向队列后部传播状态，以实现共享结点的连续唤醒。这也是共享的含义，当锁被释放时，所有持有该锁的共享线程都会被唤醒，并从等待队列移除。

### 9 ReentrantReadWriteLock

**RRW的公平策略原理**

RRW对象的创建：可以选择公平/非公平策略，可以分别获取RRW上的读锁和写锁。

1. ThreadA调用读锁的lock()方法：读锁是共享锁，核心是tryAcquireShared方法的实现，尝试获取锁此时成功（写锁0读锁1）
   读锁获取成功的条件：写锁未被其他线程占用/等待队列队首没有其他线程/读锁重入次数没有到最大值/CAS操作修改同步状态成功
2. ThreadB调用读锁的lock()方法：由于读锁是共享锁，且此时写锁未被占用，所以此时ThreadB也可以拿到读锁（写锁0读锁2）
3. ThreadC调用写锁的lock()方法：写锁是独占锁，核心是tryAcquire方法的实现，由于存在读锁，会加入等待队列，就是独占锁的请求过程。（写锁0读锁2）
4. ThreadD调用读锁的lock()方法：过程和ThreadB一样。（写锁0读锁3）
5. ThreadA释放读锁：核心是tryReleaseShared方法的实现，尝试释放锁并将读锁数量减1。（写锁0读锁2）
6. ThreadB释放读锁：同上（写锁0读锁1）
7. ThreadD释放读锁：同上（写锁0读锁0），此时读锁为0，自旋唤醒等待队列队首节点（ThreadC）
8. ThreadC从原阻塞处继续向下执行：ThreadC唤醒后尝试获取锁，并从等待队列中移除（写锁1读锁0）
9. ThreadC释放写锁：就是独占锁的锁方式过程。

补充：如果头结点后面还有等待的共享结点，会以传播的方式依次唤醒，这个过程就是共享结点的唤醒过程。

在**非公平策略**中，写锁的获取永远不需要排队，这其实时性能优化的考虑，因为大多数情况写锁涉及的操作时间耗时要远大于读锁，频次远低于读锁，这样可以防止写线程一直处于饥饿状态。

总结：当RRW等待队列队首是共享节点，说明当前写锁被占用，当写锁释放时，会以传播的方式唤醒头结点之后紧邻的各个共享结点；当RRW的等待队列队首结点是独占结点，说明当前读锁被使用，当读锁释放归零后，会唤醒队首的独占结点。

RRW的特殊之处其实就是用一个int值表示两种不同的状态（低16位表示写锁的重入次数，高16位表示读锁的使用次数）

### 10 StampedLock

对读写锁RRW的增强，优化了读锁、写锁的访问，同时使读写锁之间可以互相转换，更细粒度控制并发。

RRW存在饥饿的问题：读多写少的情况下，写线程很容易饥饿，公平策略可以缓解，但是牺牲吞吐量。

StampedLock的特点：

1. 获取锁时返回一个stamp（0表示失败，非0表示成功），释放锁需要一个stamp，需要和获取时的一致。
2. 不可重入。
3. 三种访问方式：读模式、写模式、乐观读模式。
4. 支持读锁和写锁的互相转换。
5. 不支持Condition等待。

**StampedLock原理**

1. StampedLock对象的创建：提供读锁、写锁的获取。
2. ThreadA调用writeLock获取写锁：尝试获取锁成功，如果获取失败就阻塞，不响应中断，返回0表示获取成功。
   等待队列中节点的状态只有三种状态：0初始状态，-1等待中，1取消。另外还有一个cowait字段表示读栈。
3. ThreadB调用readLock获取读锁：获取失败加入等待队列，再尝试获取一次，仍然失败后前驱置为-1后阻塞。
4. ThreadC调用readLock获取读锁：过程同上，但是插入等待队列时是链接到ThreadB的cowait栈指针中（头插法），然后阻塞，此时并没有把ThreadB的状态置为-1。
5. ThreadD调用writeLock获取写锁：获取失败后，包装成写节点插入等待队列，设置前驱（ThreadB）状态-1阻塞
6. ThreadE调用readLock获取读锁：获取失败后，包装成读节点插入等待队列，设置前驱（ThreadD）状态-1阻塞。
7. ThreadA调用unlockWrite释放写锁：释放锁后唤醒队首节点（ThreadB）
8. ThreadB被唤醒后继续向下执行：唤醒后尝试获取读锁成功，然后从读栈栈顶开始唤醒所有栈中线程。（ThreadC）
9. ThreadC被唤醒后继续向下执行：唤醒后尝试获取读锁成功，此时B和C都拿到了读锁，D和E还在阻塞。
10. ThreadB和ThreadC释放读锁：释放锁并将读锁数量减1，读锁数量为0后才去唤醒队首节点（ThreadD）
11. ThreadD被唤醒后继续向下执行：唤醒后尝试获取写锁成功继续执行。
12. ThreadD调用unlockWrite释放写锁：释放写锁后唤醒队首节点（ThreadE）
13. ThreadE被唤醒后继续向下执行：ThreadE被唤醒后继续执行，由于是读线程，也会唤醒cowait中所有线程。

StampedLock的等待队列与RRW的CLH队列相比，有以下特点：

1. 当入队一个线程时，如果队尾是读结点，不会直接链接到队尾，而是链接到该读结点的cowait链中，cowait链本质是一个栈；
2. 当入队一个线程时，如果队尾是写结点，则直接链接到队尾；
3. 唤醒线程的规则和AQS类似，都是首先唤醒队首结点。区别是StampedLock中，当唤醒的结点是读结点时，会唤醒该读结点的cowait链中的所有读结点（顺序和入栈顺序相反，也就是后进先出）。

------

## 同步器

### 1 CountDownLatch

倒数计数器：先设定一个计数初始值，当计数降到0时，将会触发一些事件。

初始计数值在构造CountDownLatch对象时传入，每调用一次 **countDown()** 方法，计数值就会减1。

线程可以调用CountDownLatch的**await**方法进入阻塞，当计数值降到0时，所有之前调用**await**阻塞的线程都会释放。

CountDownLatch的初始计数值一旦降到0，无法重置。

### 2 CyclicBarrier

栅栏：可以循环使用，让线程到达栅栏时被阻塞(调用await方法)，直到到达栅栏的线程数满足指定数量要求时，栅栏才会打开放行。

构造器：传入计数总数，还可以传入一个Runnable任务，最后一个任务到达后立即执行该任务。

**CyclicBarrier对异常的处理**：阻塞过程中线程被中断抛出BrokenBarrierException表示当前栅栏已经损坏，解散所有等待的线程。

**CyclicBarrier原理**

CyclicBarrier没有自己去实现AQS框架的API，而是利用了`ReentrantLock`和`Condition`。

CyclicBarrier是可以循环复用的，所以CyclicBarrier的每一轮任务都需要对应一个generation 对象。

generation 对象内部有个broken字段，用来标识当前轮次的栅栏是否已经损坏。

nextGeneration方法用来创建一个新的generation 对象，并唤醒所有等待线程，重置内部参数。

**CyclicBarrier的await方法**

1. 判断栅栏是否已经损坏或当前线程已经被中断，如果是会分别抛出异常；
2. 如果当前线程是最后一个到达的线程，会尝试执行最终任务（如果构造**CyclicBarrier**对象时有传入**Runnable**的话），执行成功即返回，失败会破坏栅栏；
3. 对于不是最后一个到达的线程，会在**Condition**队列上等待，为了防止被意外唤醒，这里用了一个自旋操作。

### 3 Semaphore

信号量：控制同时访问共享资源的最大线程数量。访问共享资源是需要获取许可，许可足够才能访问，否则就要等待，使用完共享资源后要归还许可。（支持公平/非公平）

**Semaphore原理**

假设现在一共3个线程：ThreadA**、**ThreadB**、**ThreadC，一个许可数为2的公平策略的Semaphore

1. 创建公平策略的Semaphore对象：指定许可数量。
2. ThreadA调用acqure方法：核心是tryAcquireShared方法的实现，尝试获取指定数量的许可(线程可以一次获取多个许可)，如果许可数不够，返回负数，成功返回>=0。此时获取成功设置剩余许可为1（state=1）
3. ThreadB调用acqure(2)方法：此时许可不足，将线程包装成共享节点加入等待队列，再尝试过去一次，失败设置前驱SIGNAL后阻塞。
4. ThreadC调用acqure()方法：过程和B相同。
5. ThreadA调用release()方法：ThreadA归还一个许可，设置state=2，唤醒队首节点（ThreadB）
6. ThreadB从原阻塞处继续执行：唤醒后尝试获取许可设置state=0，传播方式唤醒后继节点（ThreadC）
7. ThreadC从原阻塞处继续执行：ThreadC唤醒后尝试获取许可，但是失败后再次被阻塞。
8. ThreadB调用release(2)方法：归还2个许可，设置state=2，唤醒队首节点ThreadC
9. ThreadC从原阻塞处继续执行：唤醒后获取许可成功，继续执行。

注意：Semaphore不是锁，只能限制同时访问资源的线程数，至于对数据一致性的控制，Semaphore是不关心的。如果是只有一个许可的Semaphore，可以当作锁使用。

Semaphore的非公平策略：和公平的区别就是不会去查看队首是否有其他线程，直接尝试获取许可。

Semaphore的特殊方法：reducePermits（立即减少指定数量的许可）、drainPermits（清空许可）

### 4 Exchanger

交换器：用来线程间交换数据。

Thread1线程到达栅栏后，会首先观察有没其它线程已经到达栅栏，如果没有就会等待，如果已经有其它线程Thread2已经到达了，就会以成对的方式交换各自携带的信息。

首先判断数据交换方式：如果多槽交换数组为空则单槽交换，如果为不为空或者单槽交换失败则多槽交换。

**单槽交换**（并发量低时）

1. 首先到达的线程：设置Exchange对象的solt字段指向自己，表示槽位被占用；然后自旋等待，等待一段时间还是没有匹配出现就阻塞。
2. 稍后到达的线程：通过solt字段判断自己是后到达的，先把solt置空；把先到达线程携带的数据取出返回，同时把自己携带的数据存入先到达线程中，最后唤醒先到达的线程。
3. 首先到达的线程被唤醒：线程唤醒后，返回取到的数据，完成了数据交换。

**多槽位交换**（并发量高时）

如果在单槽交换中，同时出现了多个配对线程竞争修改slot槽位，导致某个线程CAS修改slot失败时，就会初始化arena多槽数组，后续所有的交换都会走多槽交换。

多槽交换的整体流程和单槽交换类似，主要区别在于它会根据当前线程的数据携带结点Node中的index字段计算出命中的槽位。

- 如果槽位被占用，说明已经有线程先到了，之后的处理和单槽交换一样；
- 如果槽位有效且为null，说明当前线程是先到的，就占用槽位，然后按照：`spin->yield->block`这种锁升级的顺序进行优化的等待，等不到配对线程就会进入阻塞。

### 5 Phaser

多阶段栅栏：多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级。

- 阶段phase：在CyclicBarrier中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。Phaser中的栅栏叫阶段（有计数值，从0到MAX），类似CyclicBarrier中的Generation，只不过Generation没有计数。
- 参与者parties：就是参与的线程，CyclicBarrier中参与者构造后就不能变，Phaser构造后还可以注册/注销参与者。
- 到达arrive和进阶advice：参与者到达当前阶段后，状态会由unarrived变为arrived，当到达的参与者满足注册数量后就进行进阶advice，也就是phase+1。
- 终止termination：代表Phaser对象终止，类似CyclicBarrier的栅栏被破坏。
- 分层tiering：当一个Phaser有大量参与者时，性能急剧下降，分层可以降低竞争。

**Phaser原理**

Phaser是一个树形结构。

树的根结点root链接着两个“无锁栈”，用于保存等待线程，所有Phaser对象都共享这两个栈。（比如当线程等待Phaser进入下一阶段时，会根据当前阶段的奇偶性，把自己挂到某个栈中）

当首次将某个Phaser结点链接到树中时，会同时向该结点的父结点注册一个参与者。

1. 对于一个孤立的Phaser结点：其等待的参与者，就是显式注册的参与者。
2. 对于一个非孤立的Phaser叶子结点：这种情况和1一样。
3. 对于一个非孤立非叶子的Phaser结点：
   这种情况，结点所等待的参与者数目包含两部分：直接显式注册的参与者（通过构造器或register方法）/ 子结点的数目。

只要当根结点的所有参与者都到达后（也就是到达参数者数等于其子结点数），所有等待线程才会放行，栅栏才会进入下一阶段。

------

## 原子类

### 1 Unsafe

封装了许多类似指针操作，可以直接进行内存管理、操纵对象、阻塞/唤醒线程等操作。

J.U.C中的许多CAS方法，内部其实都是Unsafe类在操作。如果对象中的字段值与期望值相等，则将字段值修改为x，然后返回true；否则返回false

Unsafe是一个final类，不能被继承，也没有公共的构造器，只能通过工厂方法**getUnsafe**获得Unsafe的单例。

但是getUnsafe方法限制了调用该方法的类的类加载器必须为Bootstrap ClassLoader。

所以用户代码直接调用getUnsafe会抛出异常，但是可以通过反射的方法获取（不建议）。

### 2 AtomicInteger

Integer类型的线程安全原子类，可以在应用程序中以原子的方式更新int值。（AtomicLong、AtomicBoolean）

提供两个构造函数，默认值为0。

内部所有操作都是针对内部value值，并通过Unsaft类实现线程安全的CAS操作。

### 3 AtomicReference

以原子方式更新对象引用。

AtomicReference的引入是为了可以用一种类似乐观锁的方式操作共享资源，在某些情景下以提升性能。

当多个线程同时访问共享资源时，一般需要以加锁的方式控制并发（悲观锁），而AtomicReference提供了以无锁方式访问共享资源的能力（乐观锁CAS操作）。

**CAS操作可能存在的问题**：ABA问题

ABA问题解决方法：AtomicStampedReference带有版本号，内部维护Pair对象用来记录对象引用和版本号，当CAS操作时，只有内部Pair的引用变量和版本都都和参数一致时才能进行修改。

AtomicMarkableReference：不关系引用变量改变了几次，只关系是否改变过，用bool变量表示。

### 4 Atomic数组

`AtomicIntegerArray`、`AtomicLongArray`、`AtomicReferenceArray`

原子数组并不是说可以让线程以原子方式一次性地操作数组中所有元素的数组，而是指对于数组中的每个元素，可以以原子方式进行操作。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

利用Unsafe类直接操作int[]对象的内存地址，以达到操作数组元素的目的，通过`base + i * sacle` 其实就可以知道 索引**i**的元素在数组中的内存起始地址，其中base是数组首元素地址，scale每个元素占用的大小。

### 5 FieldUpdater

`AtomicIntegerFieldUpdater`、`AtomicLongFieldUpdater`、`AtomicReferenceFieldUpdater`

以一种线程安全的方式操作非线程安全对象的某些字段，使得我们可以在不修改用户代码（调用方）的情况下，就能实现并发安全性。

能用AtomicXXXFieldUpdater实现的并发控制，同步器和其它原子类都能实现，但是使用AtomicXXXFieldUpdater通过自旋+CAS就能实现同步，符合面向对象设计的一个基本原则——开闭原则，尤其是对一些遗留代码的改造上。

必须满足以下条件才能使用：

1. AtomicReferenceFieldUpdater只能修改对于它可见的字段，也就是说对于目标类的某个字段field，如果修饰符是private，但是AtomicReferenceFieldUpdater所在的使用类不能看到field，那就会报错；
2. 目标类的操作字段，必须用volatile修饰；
3. 目标类的操作字段，不能是static的；
4. AtomicReferenceFieldUpdater只适用于引用类型的字段；

### 6 LongAdder

高并发的情况下替代AtomicLong。AtomicLong是利用了底层的CAS操作来提供并发性的，在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时AtomicLong的自旋会成为瓶颈。

AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。

LongAdder的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。（思路类似于ConcurrentHashMap中的分段锁）

**LongAdder原理**

内部存在一个base变量，一个cell[]数组。在非竞态条件下，直接累加到base上，竞态条件下，累加到各个线程自己的槽cell[i]中，最终的结果就是base+cell数组全体的和。

LongAdder设计的精妙之处：尽量减少热点冲突，不到最后万不得已，尽量将CAS操作延迟。

Cell数组的初始化：

1. 还未初始化：首先锁定状态，保证只能有一个线程初始化数组，初始化数组，根据线程的hash值映射到对应的位置。
2. 正在初始化：此时线程会直接把数加到base基数上。
3. 已经初始化：映射到对应的位置进行加操作。

LongAdder返回的sum结果是近似值。

**LongAccumulator**：LongAdder的增强版，LongAdder只能进行加减，LongAccumulator提供自定义函数操作

**DoubleAdder和DoubleAccumulator**：操作double类型的数据

------

## 集合

### 1 ConcurrentHashMap

**基本结构**

内部维护了一个Node类型的数组table，数组每个位置代表一个桶，插入键值对会映射到不同的桶。

一共包含4个类型的桶：普通节点Node、红黑树节点TreeBin(-2)、扩容节点ForwardingNode(-1)、保留节点ReservationNode(-3)。（还包括红黑树内部的节点TreeNode）

在JDK1.8之前，ConcurrentHashMap采用了分段锁的设计思路，以减少热点域的冲突。JDK1.8时不再延续，转而直接对每个桶加锁，并用“红黑树”链接冲突结点。

**Put操作**

根据key计算hash值，然后通过hash值和table容量进行运算，计算得到key所映射的索引，就是对应桶的位置。

计算索引的方式：`i=(n-1)&hash`（table的大小必须为2的幂次可以保证key在table中的均匀分布，减少冲突）

put操作共有4中情况：

1. 首次初始化table：采用懒加载，首次插入才会初始化table。注意sizeCtl初始化前是table的大小，初始化后是0.75*n，相当于设置了扩容阈值。
2. table[i]的桶为空：直接通过CAS操作占用桶。
3. table[i]对应节点是ForwardingNode扩容节点：说明此时table正在扩容，需要协助扩容。
4. table[i]的桶已经存在数据：分两种情况链表（尾插）和红黑树，还会涉及链表到红黑树的转换。

**Get操作**

根据key的hash值计算映射到table中桶的位置，

1. 如果table[i]和key相同直接返回
2. 如果是普通链表节点就按链表方式查询
3. 如果是TreeBin节点按照红黑树方式查询，当存在写锁的时候读，不会阻塞而是按照链表的形式查询。
4. 如果是ForwardingNode表示在扩容，转到新的table中查找
5. 如果是ReservationNode直接返回null

**计数操作**：思路和LongAdder一样，采用base+cell数组的方式。

**扩容操作**：主要分为两步：

1. table数组的扩容：新建一个2倍大小的数组，单线程完成不允许并发。
2. 数据迁移：rehash过程，table数组大小是2的幂次还可以保证rehash后的值要么还是i，要么是i+n，这种方式可以使多个线程同时进行数据迁移，互不影响，每个线程负责一定区域的桶。

**扩容时机**：两个时机：

- 链表转红黑树：当链表大小超过一定数量(8)后，如果table的容量比64小，直接进行table扩容，不进行红黑树转换。
- table容量超过阈值：table已经满需要进行扩容

扩容过程是在自旋中完成，从右往左迁移，直到某个线程完成第一个table区间段退出。

迁移共有4种情况：

1. table[i]的桶为空：说明无数据，直接放一个ForwardingNode用来占位，表示迁移完成。
2. table[i]的桶已经迁移完成：被ForwardingNode占用了，直接跳过。
3. table[i]的桶未迁移完成：分为链表迁移和红黑树迁移。
   链表迁移：首先遍历链表，将链表分为两部分，分别链接到新table的槽中。
   红黑树迁移：按照链表的方式迁移，如果节点数超过/小于阈值，会涉及红黑树和链表的互相转换。
4. 当前是最后一个迁移任务或者发生扩容冲突：最后一个进行收尾（设置table指向新数组，再遍历一遍就数组看是否都被ForwardingNode占用）；如果发生扩容冲突，任何一个线程不能进行迁移。

### 2 ConcurrentSkipListMap

跳表结构：类似链表，查询/插入/删除的时间复杂度都是`O(logn)`，是一种空间换时间的思想。

节点类型：普通节点Node（最底层的链表节点，保存实际的数据，按照key有序排列），索引节点Index（除底层链表其余各层链表的非头节点，包含指向下、右、底层的指针），头索引节点HeadIndex（各层链表的头节点，保存了level表示层号，向上增大）

整个跳表还有一个head指针表示最上层链表的头指针，base_header表示最底层链表的头指针。

**Put操作**：

先找到底层链表的插入点插入数据，（在查找过程中会删除一些已标记删除的节点）分层数是通过随机生成算法确定的，如果需要增加分层，就需要在各层级中加入Index节点。

**remove操作**

删除时不是立即删除而是懒删除，先找到待删除的节点然后插入一个value为null的标记节点，最后解除被删除节点的index节点之间的引用，这样该节点就被孤立，后续查找或者插入的时候会被完全清除。

**get操作**

首先找到小于且最接近给定key的节点，然后在底层链表上顺序查找。

### 3 ConcurrentSkipListSet

内部是对ConcurrentSkipListMap的封装，注意插入元素的时候用一个Boolean.TRUE作为value.

### 4 CopyOnWriteArrayList

适用于读多写少的场景，采用写时复制的思想，可以使读写不会冲突，可以并发进行，只有在多线程同时写时才需要同步。内部有一个显式锁用于对修改操作同步。

**基本原理**

get操作：不加锁，直接返回对应位置的值。

add操作：先加锁，创建一个新数组(n+1)，并将原数组复制到新数组，新元素插到尾部，最后引用指向新数组。

remove操作：先加锁，同样复制到新数组进行。

迭代操作：仅仅返回一个快照，不会抛出异常，不准确。

**存在的问题**：内存占用问题和数据一致性问题

### 5 CopyOnWriteArraySet

内部是对CopyOnWriteArrayList的封装，通过addAllAbsent方法保证数据的唯一性。

### 6 ConcurrentLinkedQueue

基于链表，完全采用自旋+CAS来实现，当多个线程同时修改队列，CAS失败失败后进入下一次自旋直到成功。

内部是一个简单的链表，入队元素就是插入一个Node节点，字段head指向队列头，tail指向队列尾。

**入队操作**：在队尾插入元素e，直到成功。（由于入队元素一定要插入到队尾，但并发情况下队尾节点随时变化，所以需要定位最新的队尾节点，并在入队时判断队尾节点是否改变，如果改变需要重新设置队尾指针，然后在下一次自旋中继续尝试入队）

**出队操作**：移除队首元素，直到成功。（采用懒删除的方法，先把头节点置为null，然后第二次在改变head指针）

总结：不具备数据一致性，遍历的同时可能存在并发修改，这是并不会报错，但是会看不到修改的内容。

### 7 ConcurrentLinkedDeque

双端队列：头尾都可以入队和出队（可以当作并发栈来使用）。add/remove/get抛出异常，offer/poll/peek返回特殊值。

**原理**：内部和ConcurrentLinkedQueue类似，只不过是双端队列，特别的内部含有两个特殊字段PREV_TERMINATOR和NEXT_TERMINATOR在节点删除的时候使用。

**入队操作**：队头队尾都可以插入元素e，直到成功。（head和tail采用hop跳的方式提升效率）

**出队操作**：队头队尾都可以弹出元素，直到成功。

总结：同样不具备数据一致性。

### 8 BlockingQueue

阻塞队列：采用锁来实现，适用于生产者消费者模式。当线程插入元素put，如果队列已满则阻塞直到非满；当线程取出元素take，如果队列为空则阻塞线程直到非空。以下都是它的实现类。

### 9 ArrayBlockingQueue

底层基于环形数组实现，是一种有界阻塞队列；容量构造制定后不能更改；插入元素在队尾，删除元素在队头；支持公平/非公平策略（公平是指线程从阻塞到唤醒以请求的顺序来添加/删除元素，非公平指谁抢到锁谁先操作）

内部通过ReentrantLock锁保证并发，并创建两个Conditon对象，在队列满是时，插入线程需要在notFull上等待；队列空时，删除线程需要在notEmpty上等待。

**插入元素**：当队列满时，则调用线程会在notFull条件队列上等待，否则就入队。

**删除元素**：删除元素时，如果队列空了，则线程需要在notEmpty条件队列上等待，否则就出队一个元素。

**总结**：对于队列的修改需要加全局锁，在超高并发的环境可能出现性能瓶颈。

### 10 LinkedBlockingQueue

基于单链表实现，是一种近似有界阻塞队列（构造可指定大小不指定就是`Interger.MAX_VALUE`）。

内部维护两把锁takelock（控制出队的并发）和putlock（控制入队的并发），保证了出队和入队可以并发执行，提升了吞吐量。

内部通过一个AtomicInteger记录元素的个数，以保证修改元素时的数据一致性。

**插入元素**：需要获得putlock，如果队列满了，当前线程需要在notFull条件上等待，否则插入队列尾部。

1. 每入队一个元素，如果队列未满，则需要唤醒其他可能正在等待的入队线程；
2. 每入队一个元素，都要判断队列是否为空，如果为空，说明有可能存在等待的出队线程，需要唤醒它。

为什么不像ArrayBlockingQueue那样，入队完成后直接唤醒一个在notEmpty上等待的出队线程？

- 因为ArrayBlockingQueue中出队入队是同一把锁，不会并发执行，入队一个就可以通知等待的出队线程。
- 而LinkedBlockingQueue中是两把不同的锁，可以并发执行，如果入队后马上通知出队，在持有putlock的同时回去获取takelock很容易造成死锁，性能也会降低。

**删除元素**：需要获得takelock，如果队列为空，则出队线程需要在notEmpty条件上等待，否则从队首出一个元素

1. 每出队一个元素，如果队列非空，则需要唤醒其它可能正在等待的出队线程
2. 每出队一个元素，都要判断下队列是否满，如果是满的，说明可能存在正在等待的入队线程，需要唤醒它

**总结**：(和ArrayBlockingQueue的区别)队列大小不同、底层结构不同、加锁机制不同、不能指定公平/非公平。

### 11 PriorityBlockingQueue

底层基于堆（基于数组实现）实现，是一种无界阻塞队列，构造时可以指定大小，它是一种优先级队列，按照权重大小的顺序出队。它是真正的无界队列（初始容量11，满了会扩容），因此插入元素不会阻塞。

内部通过ReentrantLock保证并发安全，只有一个等待条件notEmpty。

**插入元素**：首先获取全局锁，如果队列满了就进行扩容，先把元素插入二叉树右下方，然后进行堆的调整使整体有序。

**扩容**：插入后内部数组满了进行扩容，先释放锁（扩容和删除可以并行），扩容后是原数组的2倍。

**删除元素**：先获取全局锁，如果队列为空则阻塞线程，否则把堆的堆顶元素出队，然后把最后一个元素放到堆顶位置，调整堆结构使整体有序。

### 12 SynchronousQueue

底层基于栈和队列实现，特点如下（和Exchanger类似）：

1. 入队线程和出队线程必须一一匹配，否则任意先到达的线程会阻塞
2. 内部不保存任何元素（容量为0），数据直接在配对的生产者和消费者之间传递
3. 支持公平/非公平策略（公平基于队列，非公平基于栈）
4. 采用无锁算法实现并发安全

**非公平策略**：TransferStack栈结构，有三种节点类型Request(未配对的消费者)，Data(未配对的生产者)，Fulfilling(配对成功的消费者/生产者)

Put操作：入队指定元素e，如果没有另一个线程进行出队操作就阻塞。

Get操作：出队一个元素，如果没有另一个线程进行入队操作就阻塞。

出队入队委托给了同一个方法：

1. 栈为空或栈顶节点类型和入队节点相同则阻塞调用线程。
2. 栈顶节点还未配对成功，且与当前入队节点匹配，则进行配对操作（配对后会弹出这两个节点）。
3. 栈顶节点正在进行配对中，直接进行下一个节点的配对。

**公平策略**：TransferQueue队列结构，思路类似，必须一一匹配。

**总结**：TransferQueue主要用于线程间交换数据，采用无锁算法，内部通过栈和队列保存阻塞线程。

### 13 DelayQueue

底层基于已有的PriorityBlockingQueue实现，一种无界阻塞队列。里面的元素必须实现`Delayed`接口，只有当对象的剩余有效时间小瑜<=0才会出队，由于优先级队列的存在，每次出队的都是剩余时间<=0的最小元素。

**Put操作**：由于使无界队列不会阻塞，需要注意当首次入队元素时，需要唤醒一个出队线程。

**Take操作**：自旋中完成，如果队列为空直接阻塞出队线程，在available条件上等待；队列非空，要看队首元素有效期，如果过期直接出队，如果未过期，要看当前线程是否是第一个到达的出队线程，如果不是就无线等待，如果是就限期(队首的剩余时间)等待。

总结：用于缓存或者定时任务。

### 14 LinkedBlockingDeque

底层基于双端链表实现，采用ReentrantLock实现同步，是一种近似有界的阻塞队列。

**Put操作**：分为队尾入队和队首入队，如果队列已满则阻塞线程，插入成功唤醒一个正在等待的出队线程。

**Take操作**：分为队尾出队和队首出队，如果队列为空则阻塞线程。

**总结**：增加了队首入队和队尾出队的操作，适用于工作窃取算法的实现。

### 15 LinkedTransferQueue

具备阻塞队列的常用功能，存在特殊方法`transfer`，当队列为空一般会阻塞消费者等待生产者存入元素，而transfer方法：当有消费者阻塞等待时，生产者不会将元素入队而是直接交给消费者；当生产者发现没有消费者等待时，才会把元素入队，然后阻塞等待消费者的到来。

内部是单链表结构，节点有数据节点和请求节点(通过isData字段区分)，只有不同类型的节点才能匹配，item字段保存值，匹配前后发生变化。

匹配前：数据节点item=数据节点值；请求节点item=null

匹配后：数据节点item=null；请求节点item=this

总结：LinkedTransferQueue兼具了SynchronousQueue的特性以及无锁算法的性能，并且是一种无界队列，和SynchronousQueue相比可以存储实际的数据，和其他阻塞队列相比采用无锁算法性能有所提升。

------

## 执行器

### 1 executors框架

- **Executor**接口：解耦任务本身和任务的执行，只有一个excute方法，传入一个待执行的任务。
- **ExecutorService**接口：对Excutor的增加，加入了生命周期管理。提供了以下功能：关闭执行器禁止任务提交、监视执行器的状态、提供对异步任务的支持、提供对批处理任务的支持。
- **ScheduledExecutorService**接口：定时和周期性任务支持，通过一系列的schedule方法。

- **Executors类**：生成executor的工厂，用于创建上述接口的实现类对象，提供了以下5类构造器。
  - **固定线程数的线程池**：newFixedThreadPool()方法返回ThreadPoolExecutor实例，它是ExecutorService接口实现类。构造可以传入一个ThreadFactory对象决定线程池内部线程的创建方式。
  - **单个线程的线程池**：newSingleThreadExecutor()方法，其实返回的就是容量为1的固定线程池（返回的实例多了一层包装，是为了将一些诸如设置线程大小的方法屏蔽掉）
  - **可缓存的线程池**：newCachedThreadPool()方法，返回的还是ThreadPoolExecutor实例，只不过指定了超时时间，超过指定时间没有使用就回收。
  - **可延时/周期调度的线程池**：newScheduledThreadPool()方法，返回的是ScheduledExecutorService接口的实例。
  - **Fork/Join线程池**：newWorkStealingPool()方法。

### 2 ThreadPoolExecutor

没有直接实现ExecutorService接口，而是继承实现了ExecutorService接口的AbstractExecutorService抽象类。

AbstractExecutorService提供了ExecutorService接口的默认实现（submit、invokeAny、invokeAll）

其中的submit方法：首先将Runnable任务和返回值value封装成一个FutureTask对象(Future接口实现类，同时也实现了Runnable接口)，然后通过execute方法执行任务，最后返回异步任务对象。

**基本原理**

Executors工厂内部创建的三种线程池都是实例化了ThreadPoolExecutor对象。

逻辑上将自身管理的线程分为两部分：核心线程池和非核心线程池

提交任务时会创建一个工作线程(封装了Runnable任务和执行该任务的Thread对象)，它在逻辑上从属于核心线程池或非核心线程池。

**线程池的状态和管理**

通过一个AtomicInteger变量，低29位保存线程数，高3位保存线程池状态。

线程池状态：Running、Shutdown、stop、Tidying、Termination

ThreadPoolExecutor通过一个HashSet来保存工作线程。

线程工厂：指定线程池中线程的创建方式，可以解耦对象的创建和使用，还可以批量配置线程信息。

**调度流程**：核心submint方法用来提交一个待执行的任务。

如果工作线程数小于核心线程池上限则直接新建一个工作线程并执行任务；如果大于则尝试将任务加入到队列中等待以后执行，如果加入失败(队列已满)，则在总线程池未满的情况下新建一个工作线程立即执行任务，否则执行拒绝策略。

**工作线程**

- **创建**：首先对线程池状态进行判断，如果不接受新任务或者工作线程超出限制则返回false；然后再去创建工作线程并执行任务，将任务包装成Worker对象，加入到工作线程集合中，最后调用工作线程的Thread对象的start方法执行任务。
- **执行**：不断从队列中取出任务(如果工作线程携带任务则执行携带的任务)；控制执行线程的中断(如果线程池正在停止，则线程必须时中断状态，否则必须是非中断状态)；调用task.run执行任务；处理工作线程的退出工作。
- **清理**：将退出的工作线程清理掉，然后查看线程池是否需要终止。

**任务的获取**：通过自旋不断地从阻塞队列获取一个任务，阻塞队列不同对应地策略不同（直接提交：synchronousQueue，无界任务队列：LinkedTransferQueue,LinkedBlokingQueue，有界任务队列：ArrayBlockingQueue）

**拒绝策略**：当核心线程池满了且任务队列也满了，非核心线程池也满了，就要执行拒绝策略。

1. AbortPolicy：默认，抛出一个异常
2. DiscardPolicy：什么都不做，等任务自己回收
3. DiscardOldestPolicy：丢弃任务队列中最近的一个任务并执行当前任务
4. CallerRunsPolicy：以自身线程(调用者)来执行任务

**线程池的关闭**

- shuntdown：切换到Shutdown状态，同时中断所有空闲的工作线程，最后尝试结束线程池。注意如果Runnable任务不响应中断则无法终止任务。
- shutdownnow：切换到Stop状态，同时中断所有的工作线程，无论空闲还是运行，同时返回任务队列中的所有任务

### 3 ScheduledThreadPoolExecutor

实现了ScheduledExecutorService接口，这个接口在ExecutorService接口基础上引入Future模式用于限时或周期性调度任务。 

ScheduledThreadPoolExecutor继承了ThreadPoolExecutor这个普通线程池，TPE中的任务都实现了Runnable接口，但是STPE中的任务对Runnable任务进行了包装成RunnableScheduledFuture任务，它可以异步的执行（延时/周期任务）

TPE中需要指定一个阻塞队列作为任务队列，STPE中任务队列是DelayQueue，即每次从队列中获取的任务都是最先到期的任务。

**基本原理**：核心方法是schedule方法（把普通的Runnable任务包装成ScheduleFutureTask任务）

1. 首先任务被提交后，会先判断线程池状态如果不是running会执行拒绝策略；
2. 然后把任务添加到阻塞队列中（DelayQueue无界一定会成功）；
3. 创建一个工作线程，加入到核心线程池或者非核心线程池。（核心线程池未满放入其中，满了不会像TPE再去创建属于非核心线程的工作线程而是直接返回）

只有当设置核心线程数位0时，为了保证线程的执行才会去创建一个属于非核心线程的工作线程。

4. 最后线程池中的工作线程回去任务队列获取任务并执行，执行完后如果是周期任务会重新插入队列中等待下次执行

### 4 Future模式

主要作用是异步的执行任务，并在需要的时候获取结果。

**Callable接口**：表示一个具有返回结果的任务。

**凭证**：调用方调用后立即返回拿到一个凭证，在真正需要结果的时候使用凭证去获取结果。

**凭证特点**：在将来的某个时间点可以通过凭证获取结果/支持任务的取消。

FutureTask类就是真是的凭证，它实现了Future接口(需要异步返回结果)，还实现了Runnable接口(需要作为任务执行)，既可以包装Callable任务也可以包装Runnable任务（最后都转成了Callable任务）。

**Future接口的方法**：`isCancelled`和`isDone`监控任务的执行状态；`cancel`取消任务；两个`get`方法用于获取结果。

整个Future模式其实就三个核心组件：

- **真实任务/数据类**（通常任务执行比较慢，或数据构造需要较长时间），即示例中的ComplexTask
- **Future接口**（调用方使用该凭证获取真实任务/数据的结果），即Future接口
- **Future实现类**（用于对真实任务/数据进行包装），即FutureTask实现类

**FutureTask原理**：它代表一个异步任务，提交给Executor执行。

**FutureTask任务的状态**：new、completing、normal、exceptional、cancelled、interrupting、interrupted.

注意：只有任务状态时new才可以取消；执行任务时无论成功或异常，都要先过渡到completing状态。

内部通过Unsafe类CAS操作state状态字段来进行同步。

内部维持一个无锁栈，用来保存获取结果而阻塞的线程。

**任务的运行**：调用了run方法，查看state状态是否是new，不为new说明已经执行过了直接返回；正常执行后调用set方法设置任务结果；如果执行过程中抛出异常，调用setException设置异常信息。

**任务的取消**：cancel方法用于取消，参数`mayInterruptIfRunning`为true表示中断正在执行任务的线程，否则仅仅把任务状态置为cancelled；任务取消后，释放所有栈上等待的线程。

**结果获取**：通过get方法获取结果，如果任务状态时new/completing会阻塞线程，否则认为任务已经完成直接根据状态映射结果（normal返回任务结果/exceptional抛出ExecutionException/cancelled和interrupted抛出CancellationException）

**ScheduledFutureTask**：是ScheduledThreadPoolExecutor线程池的默认调度任务类。在普通FutureTask的基础上增加了周期/延时执行功能。

### 5 Fork/Join框架

**分治思想**：将大人物分解(Fork)成一系列子任务，子任务可以继续往下分解，当多个子任务执行完成后，将各自的结果合并(join)成一个大结果，最终合并成任务的结果。

**工作窃取算法**：每个线程对应自己的任务队列，当自己队列中的任务执行完后，尝试从其他线程的队列中窃取任务来执行(从队尾出队任务LinkedBlockingDeque)。

**核心组件**：

1. ForkJoinPool(线程池)：ExecutorService的实现类，负责工作线程管理，任务队列维护、任务调度流程控制。
2. ForkJoinTask(任务)：Future接口的实现类，核心是fork(分解任务)和join(合并结果)
3. ForkJoinWorkerThread(工作线程)：Thread的子类，作为线程池中的工作线程执行任务
4. WorkQueue(任务队列)：用于保存任务

**ForkJoinPool线程池**

任务：接收外部提交的任务、接收fork出的子任务提交、任务队列的初始化和管理、工作线程的创建和管理。

提交任务的方式：invoke(同步方法执行完成才返回)、execute(异步方法没有返回结果)、submit(异步有返回结果)

ForkJoinPool支持同步模式和异步模式（指的是工作线程的工作方式，同步是指对于任务队列中的任务采用后进先出方式执行，异步采用先进先出的方式执行）

**ForkJoinTask任务**

提交的Runnable或Callable任务会被适配成ForkJoinTask任务。

任务支持fork(任务自身的分解)和join(任务结果的合并)。

ForkJoinTask是一个抽象类，有两个实现类：RecursiveAction具有返回值，RecuriveTask没有返回值。

**ForkJoinWorkerThread工作线程**

每个工作线程都有一个自己的工作队列，它保存所属线程池的信息和与自己绑定的任务队列的信息。

工作线程优先处理自己队列中的任务，为空后窃取其他线程的队列任务。

**WorkQueue任务队列**

ForkJoinPool内部维护一个WorkQueue[]数组，当外部提交任务时如果数组还没有初始化就进行初始化；然后根据数组大小和线程随机数计算任务队列所在的索引(一定是偶数)，如果索引处没有任务队列就初始化一个再将任务入队，也就是说通过外部方法提交的任务一定在偶数索引且没有绑定工作线程。

**任务队列分为两类**：有工作线程绑定的任务队列，数组下标是奇数，它的任务由线程分解产生；没有工作线程绑定的任务队列，数组下标是偶数，它的任务由外部提交。

**任务调度流程**

1. 任务提交：外部提交任务/工作线程fork任务
2. 创建工作线程：根据情况创建或者唤醒工作线程执行任务
3. 任务执行：任务入队后，由工作线程开始执行，涉及到任务窃取、工作队列等待。
4. 任务结果获取：通过Join方法