java

java容器是每个java开发者必须打交道的东西，简单来说容器就是可以装载其他java对象的对象。

java提供了一套集合类容器，基本类型包括List、Set、Queue和Map

![Java并发容器的原理：7大并发容器详解、及使用场景](https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731214538_80111.jpg)

集合容器、并发容器、同步容器

# 1.什么是同步容器**

***<u>Java的集合容器框架中，主要有四大类别：List、Set、Queue、Map</u>***，大家熟知的这些集合类ArrayList、LinkedList、HashMap这些容器都是非线程安全的。

如果有多个线程并发地访问这些容器时，就会出现问题。因此，在编写程序时，在多线程环境下必须要求程序员手动地在任何访问到这些容器的地方进行同步处理，这样导致在使用这些容器的时候非常地不方便。

所以，Java先提供了同步容器供用户使用。

**同步容器可以简单地理解为通过synchronized来实现同步的容器**，比如Vector、Hashtable以及SynchronizedList等容器。

**2.同步容器，主要的分类**：

-  Vector
-  Stack
-  HashTable
-  Collections.synchronized方法生成

# 2.同步容器面临的问题 

可以通过查看Vector，Hashtable等这些同步容器的实现代码，**可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字synchronized。**

这样做的代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低。

例如： HashTable只要有一条线程获取了容器的锁之后，其他所有的线程访问同步函数都会被阻塞，因此同一时刻只能有一条线程访问同步函数。

<u>**因此为了解决同步容器的性能问题，所以才有了并发容器。**</u>

# 3.什么是并发容器 

java.util.concurrent包中提供了多种并发类容器。

并发类容器是专门针对多线程并发设计的，使用了**锁分段技术**，只对操作的位置进行同步操作，但是**其他没有操作的位置其他线程仍然可以访问，提高了程序的吞吐量。**

**采用了CAS算法和部分代码使用synchronized锁保证线程安全。**

![Java并发容器的原理：7大并发容器详解、及使用场景](https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731214553_88918.jpg)

## 七种并发容器：

### 1.ConcurrentHashMap

对应的非并发容器：HashMap

目标：代替Hashtable、synchronizedMap，支持复合操作

原理：JDK6中采用一种更加细粒度的加锁机制Segment“分段锁”，JDK8中采用CAS无锁算法。

### **2.CopyOnWriteArrayList**

对应的非并发容器：ArrayList

目标：代替Vector、synchronizedList

原理：利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用，并通过volatile 保证其可见性，当然写操作的锁是必不可少的了。

### **3.CopyOnWriteArraySet**

对应的非并发容器：HashSet

目标：代替synchronizedSet

原理：基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法，其遍历当前Object数组，如Object数组中已有了当前元素，则直接返回，如果没有则放入Object数组的尾部，并返回。

### **4.ConcurrentSkipListMap**

对应的非并发容器：TreeMap

目标：代替synchronizedSortedMap(TreeMap)

原理：Skip list（跳表）是一种可以代替平衡树的数据结构，默认是按照Key值升序的。

### **5.ConcurrentSkipListSet**

对应的非并发容器：TreeSet

目标：代替synchronizedSortedSet

原理：内部基于ConcurrentSkipListMap实现

### **6.ConcurrentLinkedQueue**

不会阻塞的队列

对应的非并发容器：Queue

原理：基于链表实现的FIFO队列（LinkedList的并发版本）

### **7.LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue**

对应的非并发容器：BlockingQueue

特点：拓展了Queue，增加了可阻塞的插入和获取等操作

原理：通过ReentrantLock实现线程安全，通过Condition实现阻塞和唤醒

实现类：

-  LinkedBlockingQueue：基于链表实现的可阻塞的FIFO队列
-  ArrayBlockingQueue：基于数组实现的可阻塞的FIFO队列
-  PriorityBlockingQueue：按优先级排序的队列



# 4.**ConcurrentHashMap的实现**

Hashtable实现同步是利用synchronized关键字进行锁定的，其是针对整张哈希表进行锁定的，即每次锁住整张表让线程独占，在线程安全的背后是巨大的浪费。

ConcurrentHashMap和Hashtable主要区别就是围绕着锁的粒度进行区别以及如何区锁定。

上图中，左边是Hashtable的实现方式，可以看到锁住整个哈希表

而右边则是ConcurrentHashMap的实现方式，***单独锁住每一个桶（segment）***.ConcurrentHashMap将哈希表分为16个桶（默认值），诸如get(),put(),remove()等常用操作只锁当前需要用到的桶,而size()才锁定整张表。

原来只能一个线程进入，现在却能同时接受16个写线程并发进入（写线程需要锁定，而读线程几乎不受限制）。

**所以，才有了并发性的极大提升。**

![Java并发容器的原理：7大并发容器详解、及使用场景](https://youzhixueyuan.com/blog/wp-content/uploads/2019/07/20190731214611_41896.jpg)

高并发编程，除了并发容器，还会涉及到并发工具类:CountDownLatch等，后续将详细的介绍并发工具类。

JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了**数组+链表+红黑树**的实现方式来设计，如下图所示：

![彻底搞清楚ConcurrentHashMap的实现原理(含JDK1.7和JDK1.8的区别)](https://youzhixueyuan.com/blog/wp-content/uploads/2018/11/2020050202351287.png)

**内部大量采用CAS操作，这里我简要介绍下CAS。**

CAS是compare and swap的缩写，即我们所说的比较交换。cas是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。**<u>悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。</u>**而乐观锁采取了一种宽泛的态度，**<u>通过某种方式不加锁来处理资源，</u>**比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。

CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。***CAS是通过无限循环来获取数据的***，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。

**JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。**

**Node：保存key，value及key的hash值的数据结构。其中value和next都用volatile修饰，保证并发的可见性。**

在JDK8中ConcurrentHashMap的结构，由于引入了红黑树，使得ConcurrentHashMap的实现非常复杂，我们都知道，红黑树是一种性能非常好的二叉查找树，其查找性能为O（logN），但是其实现过程也非常复杂，而且可读性也非常差

## 5.ConcurrentHashMap总结

**1.数据结构**：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。

**2.保证线程安全机制**：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。

**3.锁的粒度**：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。

**4.链表转化为红黑树**:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。

**5.查询时间复杂度**：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。