# 1 executors框架概述

## 1.1 executors框架简介

### 1.1.1 从Executor谈起

引入该接口的主要目的是**解耦任务本身和任务的执行**。我们之前通过线程执行一个任务时，往往需要先创建一个线程，然后调用线程的`start`方法来执行任务：

```java
new Thread(new(RunnableTask())).start();
```

上述RunnableTask是实现了Runnable接口的任务类

而Executor接口解耦了任务和任务的执行，该接口只有一个方法，入参为待执行的任务：

我们可以像下面这样执行任务，而不必关心线程的创建：

```java
Executor executor = someExecutor;       // 创建具体的Executor对象
executor.execute(new RunnableTask1());
executor.execute(new RunnableTask2());
...
```

由于Executor仅仅是一个接口，所以根据其实现的不同，执行任务的具体方式也不尽相同，比如：

**①同步执行任务**

DirectExecutor是一个同步任务执行器，对于传入的任务，只有执行完成后execute才会返回。

**②异步执行任务**

ThreadPerTaskExecutor是一个异步任务执行器，对于每个任务，执行器都会创建一个新的线程去执行任务。

注意：Java线程与本地操作系统的线程是一一映射的。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，对应操作系统线程会被回收。由于CPU资源是有限的，所以线程数量有上限，所以一般由线程池来管理线程的创建/回收，而上面这种方式其实是线程池的雏形。

**③对任务进行排队执行**

SerialExecutor 会对传入的任务进行排队（FIFO顺序），然后从队首取出一个任务执行。

J.U.C包中提供了很多Executor的具体实现类，我们以后会具体讲到，这里关键是理解Executor的设计思想——对任务和任务的执行解耦。

### 1.1.2 增强的Executor——ExecutorService

Executor接口提供的功能很简单，为了对它进行增强，J.U.C又提供了一个名为`ExecutorService`接口

可以看到，ExecutorService继承了Executor，它在Executor的基础上增强了对任务的控制，同时包括对自身生命周期的管理，主要有四类：

1. 关闭执行器，禁止任务的提交；
2. 监视执行器的状态；
3. 提供对异步任务的支持；
4. 提供对批处理任务的支持。

`Future`对象提供了对任务异步执行的支持，也就是说调用线程无需等待任务执行完成，提交待执行的任务后，就会立即返回往下执行。然后，可以在需要时检查Future是否有结果了，如果任务已执行完毕，通过`Future.get()`方法可以获取到执行结果——Future.get()是阻塞方法。

### 1.1.3 周期任务的调度——ScheduledExecutorService

在工业环境中，我们可能希望提交给执行器的某些任务能够定时执行或周期性地执行，这时我们可以自己实现Executor接口来创建符合我们需要的类，所以在ExecutorService的基础上，又提供了一个接口——`ScheduledExecutorService`，

ScheduledExecutorService提供了一系列schedule方法，可以在给定的延迟后执行提交的任务，或者每个指定的周期执行一次提交的任务.

## 1.2 生产executor的工厂

Executors框架就是用来解耦任务本身与任务的执行，并提供了三个核心接口来满足使用者的需求：

1. **Executor**：提交普通的可执行任务
2. **ExecutorService**：提供对线程池生命周期的管理、异步任务的支持
3. **ScheduledExecutorService**：提供对任务的周期性执行支持

既然上面三种执行器只是接口，那么就一定存在具体的实现类，J.U.C提供了许多默认的接口实现，如果要用户自己去创建这些类的实例，就需要了解这些类的细节，有没有一种直接的方式，仅仅根据一些需要的特性（参数）就创建这些实例呢？因为对于用户来说，其实使用的只是这三个接口。

JDK1.5时，J.U.C中还提供了一个`Executors`类，专门用于创建上述接口的实现类对象。Executors其实就是一个简单工厂，它的所有方法都是static的，用户可以根据需要，选择需要创建的执行器实例，Executors一共提供了**五类**可供创建的Executor执行器实例。

### 1.2.1 固定线程数的线程池

Executors提供了两种创建具有固定线程数的Executor的方法，固定线程池在初始化时确定其中的线程总数，运行过程中会始终维持线程数量不变。

的两种创建方法其实都返回了一个`ThreadPoolExecutor`实例。ThreadPoolExecutor是一个ExecutorService接口的实现类，用来调度其中的线程的执行。

```java
public static ExecutorService newFixedThreadPool(int nThreads);
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)
```

上面需要注意的是`ThreadFactory`这个接口：

```java
public interface ThreadFactory {
    Thread newThread(Runnable r);
}
```

既然返回的是一个线程池，那么就涉及线程的创建，一般我们需要通过` new Thread ()`这种方法创建一个新线程，但是我们可能希望设置一些线程属性，比如名称、守护程序状态、ThreadGroup 等等，线程池中的线程非常多，如果每个线程都这样手动配置势必非常繁琐，而ThreadFactory 作为一个线程工厂可以让我们从这些繁琐的线程状态设置的工作中解放出来，还可以由外部指定ThreadFactory实例，以决定线程的具体创建方式。

Executors提供了静态内部类，实现了ThreadFactory接口，最简单且常用的就是下面这个**DefaultThreadFactory** ：

可以看到，DefaultThreadFactory 初始化的时候定义了线程组、线程名称等信息，每创建一个线程，都给线程统一分配这些信息，避免了一个个手工通过new的方式创建线程，又可进行工厂的复用。

### 1.2.2 单个线程的线程池

除了固定线程数的线程池，Executors还提供了两种创建只有单个线程Executor的方法：

```java
public static ExecutorService newSingleThreadExecutor()
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)
```

可以看到，只有单个线程的线程池其实就是指定线程数为1的固定线程池，主要区别就是，返回的Executor实例用了一个`FinalizableDelegatedExecutorService`对象进行包装。

**为什么要多此一举，加上这样一个委托层？**因为返回的ThreadPoolExecutor包含一些设置线程池大小的方法——比如setCorePoolSize，对于只有单个线程的线程池来说，我们是不希望用户通过强转的方式使用这些方法的，所以需要一个包装类，只暴露ExecutorService本身的方法。

### 1.2.3 可缓存的线程池

有些情况下，我们虽然创建了具有一定线程数的线程池，但出于资源利用率的考虑，可能希望在特定的时候对线程进行回收（比如线程超过指定时间没有被使用），Executors就提供了这种类型的线程池：

```java
public static ExecutorService newCachedThreadPool()
public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)
```

可以看到，返回的还是ThreadPoolExecutor对象，只是指定了超时时间，另外线程池中线程的数量在`[0, Integer.MAX_VALUE]`之间。

### 1.2.4 可延时/周期调度的线程池

如果有任务需要延迟/周期调用，就需要返回ScheduledExecutorService接口的实例，`ScheduledThreadPoolExecutor`就是实现了ScheduledExecutorService接口的一种Executor

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)
```

### 1.2.5 Fork/Join线程池

Fork/Join线程池是比较特殊的一类线程池，在JDK1.7时才引入，其核心实现就是`ForkJoinPool`类。

```java
public static ExecutorService newWorkStealingPool(int parallelism)
public static ExecutorService newWorkStealingPool()
```

## 1.3 总结

至此，Executors框架的整体结构基本就讲解完了，此时我们的脑海中应有大致如下的一幅类继承图：

![clipboard.png](https://segmentfault.com/img/bVbhK5v?w=1696&h=812)

下面来回顾一下，上面的各个接口/类的关系和作用：

1. **Executor**
   执行器接口，也是最顶层的抽象核心接口， 分离了任务和任务的执行。
2. **ExecutorService**
   在Executor的基础上提供了执行器生命周期管理，任务异步执行等功能。
3. **ScheduledExecutorService**
   在ExecutorService基础上提供了任务的延迟执行/周期执行的功能。
4. **Executors**
   生产具体的执行器的静态工厂
5. **ThreadFactory**
   线程工厂，用于创建单个线程，减少手工创建线程的繁琐工作，同时能够复用工厂的特性。
6. **AbstractExecutorService**
   ExecutorService的抽象实现，为各类执行器类的实现提供基础。
7. **ThreadPoolExecutor**
   线程池Executor，也是最常用的Executor，可以以线程池的方式管理线程。
8. **ScheduledThreadPoolExecutor**
   在ThreadPoolExecutor基础上，增加了对周期任务调度的支持。
9. **ForkJoinPool**
   Fork/Join线程池，在JDK1.7时引入，时实现Fork/Join框架的核心类。

# 2 ThreadPoolExecutor

## 2.1 ThreadPoolExecutor简介

ThreadPoolExecutor，它是一种实现了ExecutorService接口的执行器，或者说线程池。

ThreadPoolExecutor并没有自己直接实现ExecutorService接口，因为它只是其中一种Executor的实现而已，所以Doug Lea把一些通用部分封装成一个抽象父类——**AbstractExecutorService**，供J.U.C中的其它执行器继承。如果读者需要自己实现一个Executor，也可以继承该抽象类。

### 2.1.1 AbstractExecutorService

**AbstractExecutorService**提供了 ExecutorService 接口的默认实现——主要实现了 submit、invokeAny 、invokeAll这三类方法.

ExecutorService的这三类方法几乎都是返回一个Future对象。而Future是一个接口，AbstractExecutorService既然实现了这些方法，必然要实现该Future接口，

AbstractExecutorService实现的**submit**方法：首先对Runnable和返回值value进行了封装，通过`newTaskFor`方法，封装成了一个**FutureTask**对象，然后通过execute方法执行任务，最后返回异步任务对象。

这里其实是模板方法模式的运用，execute是抽象方法，需要由继承AbstractExecutorService的子类来实现。

上述需要注意的是newTaskFor方法，该方法创建了一个Future对象：

FutureTask其实就是Future接口的实现类：

J.U.C中的Future接口是“Future模式”的多线程设计模式的实现，可以让调用方以异步方式获取任务的执行结果。而FutureTask便是这样一类支持异步返回结果的任务，既然是任务就需要实现Runnable接口，同时又要支持异步功能，所以又需要实现Future接口。J.U.C为了方便，新定义了一个接口——**RunnableFuture**，该接口同时继承Runnable和Future，代表支持异步处理的任务，而FutureTask便是它的默认实现。

### 2.1.2 线程池简介

回到ThreadPoolExecutor，从该类的命名也可以看出，这是一种线程池执行器。线程池大家应该并不陌生，应用开发中经常需要用到数据库连接池，数据库连接池里维护着一些数据库连接，当应用需要连接数据库时，并不是自己创建连接，而是从连接池中获取可用连接；当关闭数据库连接时，只是将该连接还给连接池，以供复用。

而线程池也是类似的概念，当有任务需要执行时，线程池会给该任务分配线程，如果当前没有可用线程，一般会将任务放进一个队列中，当有线程可用时，再从队列中取出任务并执行，如下图：

![clipboard.png](https://segmentfault.com/img/bVbhW8G?w=550&h=269)

线程池的引入，主要解决以下问题：

1. 减少系统因为频繁创建和销毁线程所带来的开销；
2. 自动管理线程，对使用方透明，使其可以专注于任务的构建。

## 2.2 ThreadPoolExecutor基本原理

### 2.2.1 构造线程池

Executors工厂方法创建的三种线程池：newFixedThreadPool、newSingleThreadExecutor、newCachedThreadPool，内部都是通过ThreadPoolExecutor的构造器实例化了ThreadPoolExecutor对象：

```java
/**
 * @param corePoolSize    核心线程池中的最大线程数
 * @param maximumPoolSize 总线程池中的最大线程数
 * @param keepAliveTime   空闲线程的存活时间
 * @param unit            keepAliveTime的单位
 * @param workQueue       任务队列, 保存已经提交但尚未被执行的线程
 * @param threadFactory   线程工厂(用于指定如果创建一个线程)
 * @param handler         拒绝策略 (当任务太多导致工作队列满时的处理策略)
 */
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory,RejectedExecutionHandler handler)
```

正是通过上述参数的组合变换，使得Executors工厂可以创建不同类型的线程池。这里先简要讲一下`corePoolSize`和`maximumPoolSize`这两个参数：

ThreadPoolExecutor在逻辑上将自身管理的线程池划分为两部分：**核心线程池（大小对应为corePoolSize）**、**非核心线程池（大小对应为maximumPoolSize-corePoolSize）**。
当我们向线程池提交一个任务时，将创建一个工作线程——我们称之为**Worker**，Worker在逻辑上从属于下图中的【核心线程池】或【非核心线程池】，具体属于哪一种，要根据corePoolSize、maximumPoolSize、Worker总数进行判断：

![clipboard.png](https://segmentfault.com/img/bVbhXaL?w=706&h=328)

注意：

1. ThreadPoolExecutor中只有一种类型的线程，名叫**Worker**，它是ThreadPoolExecutor定义的内部类，同时封装着Runnable任务和执行该任务的Thread对象，我们称它为【工作线程】，它也是ThreadPoolExecutor唯一需要进行维护的线程；
2. 【核心线程池】【非核心线程池】都是逻辑上的概念，ThreadPoolExecutor在任务调度过程中会根据`corePoolSize`和`maximumPoolSize`的大小，判断应该如何调度任务.

### 2.2.2 线程池状态和线程管理

到这里，读者可能会思考一个问题：既然是线程池，那么必然有线程池状态，同时也涉及对其中的工作线程（Worker）的管理，ThreadPoolExecutor是如何做的呢？

ThreadPoolExecutor内部定义了一个AtomicInteger变量——**ctl**，通过按位划分的方式，在一个变量中记录线程池状态和工作线程数——**低29位保存线程数**，**高3位保存线程池状态**：

可以看到，ThreadPoolExecutor一共定义了5种线程池状态：

- **RUNNING** : 接受新任务, 且处理已经进入阻塞队列的任务
- **SHUTDOWN** : 不接受新任务, 但处理已经进入阻塞队列的任务
- **STOP** : 不接受新任务, 且不处理已经进入阻塞队列的任务, 同时中断正在运行的任务
- **TIDYING** : 所有任务都已终止, 工作线程数为0, 线程转化为TIDYING状态并准备调用terminated方法
- **TERMINATED** : terminated方法已经执行完成

各个状态之间的流转图：

![clipboard.png](https://segmentfault.com/img/bVbhWhH?w=1732&h=682)

另外，我们刚才也提到工作线程（Worker），Worker被定义为ThreadPoolExecutor的内部类，实现了AQS框架，ThreadPoolExecutor通过一个HashSet来保存工作线程：

通过Worker的定义可以看到，每个Worker对象都有一个Thread线程对象与它相对应，当任务需要执行的时候，实际是调用内部Thread对象的start方法，而Thread对象是在Worker的构造器中通过`getThreadFactory().newThread(this)`方法创建的，创建的Thread将Worker自身作为任务，所以当调用Thread的`start`方法时，最终实际是调用了`Worker.run()`方法，该方法内部委托给`runWorker`方法执行任务，这个方法我们后面会详细介绍。

### 2.2.3 线程工厂

ThreadFactory用来创建单个线程，当线程池需要创建一个线程时，就要调用该类的`newThread(Runnable r)`方法创建线程（ThreadPoolExecutor中实际创建线程的时刻是在将任务包装成工作线程Worker时）。

ThreadPoolExecutor在构造时如果用户不指定ThreadFactory，则默认使用`Executors.defaultThreadFactory()`创建一个ThreadFactory，即Executors.DefaultThreadFactory：

这里的关键是要明白为什么需要用ThreadFactory来创建线程，而不是直接通过new Thread()的方式。这个问题在executors框架概述中已经谈过了，这样做的好处是：一来解耦对象的创建与使用，二来可以批量配置线程信息（优先级、线程名称、是否守护线程等），以自由设置池子中所有线程的状态。

## 2.3 线程池的调度流程

ExecutorService的核心方法是**submit**方法——用于提交一个待执行的任务，ThreadPoolExecutor并没有覆写submit方法，而是沿用了父类AbstractExecutorService的模板，然后自己实现了`execute`方法：

execute的执行流程可以用下图描述：

![clipboard.png](https://segmentfault.com/img/bVbjsWt?w=4106&h=4001)

一般来讲每个工作线程（Worker）都有一个Runnable任务和一个对应的执行线程Thread，当我们调用addWorker方法时，如果不传入相应的任务，那么就只是新建了一个没有任务的工作线程（Worker），该Worker就会从工作队列中取任务来执行（因为自己没有绑定任务）。如果传入了任务，新建的工作线程就会执行该任务。

将任务添加到队列后，需要判断工作线程数是否为0，如果是0那么就必须新建一个空任务的工作线程，将来在某一时刻它会去队列取任务执行，否则没有工作线程的话，该队列中的任务永远不会被执行。

另外，这里又要回到【工作线程】、【核心线程池】、【非核心线程池】、【总线程池】的概念上了。

> 再强调一遍，maximumPoolSize限定了整个线程池的大小，corePoolSize限定了核心线程池的大小，corePoolSize≤maximumPoolSize（当相等时表示为固定线程池）；maximumPoolSize-corePoolSize表示非核心线程池。

execute的整个执行流程关键是下面两点：

1. 如果工作线程数小于核心线程池上限（CorePoolSize），则直接新建一个工作线程并执行任务；
2. 如果工作线程数大于等于CorePoolSize，则尝试将任务加入到队列等待以后执行。如果加入队列失败了（比如队列已满的情况），则在总线程池未满的情况下（`CorePoolSize ≤ 工作线程数 ＜ maximumPoolSize`）新建一个工作线程立即执行任务，否则执行拒绝策略。

### 2.3.1 工作线程的创建

了解了ThreadPoolExecutor的整个执行流程，我们来看下它是如何添加工作线程并执行任务的，execute方法内部调用了**addWorker**方法来添加工作线程并执行任务

整个addWorker的逻辑并不复杂，分为两部分：

**第一部分**是一个自旋操作，主要是对线程池的状态进行一些判断，如果状态不适合接受新任务，或者工作线程数超出了限制，则直接返回false

这里需要注意的就是`core`参数，为true时表示新建的工作线程在逻辑上归属于核心线程池，所以需要判断条件 `工作线程数 < corePoolSize` 是否满足；core为false时表示在新增的工作线程逻辑上属于非核心线程池，所以需要判断条件 `工作线程数 < maximumPoolSize`是否满足。

经过第一部分的过滤，**第二部分**才真正去创建工作线程并执行任务：

首先将Runnable任务包装成一个Worker对象，然后加入到一个工作线程集合中（名为workers的HashSet），最后调用工作线程中的Thread对象的**start**方法执行任务，其实最终是委托到Worker的run方法执行：

### 2.3.2 工作线程的执行

**runWoker**用于执行任务，整体流程如下：

1. while循环不断地通过`getTask()`方法从队列中获取任务（如果工作线程自身携带着任务，则执行携带的任务）；
2. 控制执行线程的中断状态，保证如果线程池正在停止，则线程必须是中断状态，否则线程必须不是中断状态；
3. 调用`task.run()`执行任务；
4. 处理工作线程的退出工作。

确保正在停止的线程池（STOP/TIDYING/TERMINATED）不再接受新任务，如果有新任务那么该任务的工作线程一定是中断状态；确保正常状态的线程池（RUNNING/SHUTDOWN），其所执行的任务都是不能被中断的。

另外，getTask方法用于从任务队列中获取一个任务，如果获取不到任务，会跳出while循环，最终会通过processWorkerExit方法清理工作线程。注意这里的`completedAbruptly`字段，它表示该工作线程是否是因为中断而退出，while循环的退出有以下几种可能：

1. 正常情况下，工作线程会存活着，不断从任务队列获取任务执行，如果获取不到任务了（getTask返回null），会置completedAbruptly 为false，然后执行清理工作——`processWorkerExit(worker,false)；`
2. 异常情况下，工作线程在执行过程中被中断或出现其它异常，会置completedAbruptly 为true，也会执行清理工作——`processWorkerExit(worker,true)；`

### 2.3.3 工作线程的清理

通过上面的讨论，我们知道工作线程是在**processWorkerExit**中被清理的

processWorkerExit的作用就是将该退出的工作线程清理掉，然后看下线程池是否需要终止。

processWorkerExit执行完之后，整个工作线程的生命周期也结束了，我们可以通过下图来回顾下它的整个生命周期：

![clipboard.png](https://segmentfault.com/img/bVbhXiJ?w=3956&h=3561)

### 2.3.4 任务的获取

最后，我们来看下任务的获取，也就是**runWorker**中使用的`getTask`方法：

getTask方法的主要作用就是：通过自旋，不断地尝试从阻塞队列中获取一个任务，如果获取失败则返回null。

阻塞队列就是在我们构建ThreadPoolExecutor对象时，在构造器中指定的。由于队列是外部指定的，所以根据阻塞队列的特性不同，getTask方法的执行情况也不同。

我们可以根据业务需求、任务特点等选择上表中的某一种阻塞队列，根据Oracle官方文档的提示，任务在阻塞队列中排队一共有三种情况：

**1.直接提交**

即直接将任务提交给等待的工作线程，这时可以选择**SynchronousQueue**。因为SynchronousQueue是没有容量的，而且采用了无锁算法，所以性能较好，但是每个入队操作都要等待一个出队操作，反之亦然。

> 使用SynchronousQueue时，当核心线程池满了以后，如果不存在空闲的工作线程，则试图把任务加入队列将立即失败（execute方法中使用了队列的offer方法进行入队操作，而SynchronousQueue在调用offer时如果没有另一个线程等待出队操作，则会立即返回false），因此会构造一个新的工作线程（未超出最大线程池容量时）。
> 由于，核心线程池是很容易满的，所以当使用SynchronousQueue时，一般需要将`maximumPoolSizes` 设置得比较大，否则入队很容易失败，最终导致执行拒绝策略，这也是为什么Executors工作默认提供的缓存线程池使用SynchronousQueue作为任务队列的原因。

**2.无界任务队列**

无界任务队列我们的选择主要有**LinkedTransferQueue**、**LinkedBlockingQueue**（近似无界，构造时不指定容量即可），从性能角度来说LinkedTransferQueue采用了无锁算法，高并发环境下性能相对更好，但如果只是做任务队列使用相差并不大。

> 使用无界队列需要特别注意系统资源的消耗情况，因为当核心线程池满了以后，会首先尝试将任务放入队列，由于是无界队列所以几乎一定会成功，那么系统瓶颈其实就是硬件了。如果任务的创建速度远快于工作线程处理任务的速度，那么最终会导致系统资源耗尽。Executors工厂中创建固定线程池的方法内部就是用了LinkedBlockingQueue。

**3.有界任务队列**

有界任务队列，比如**ArrayBlockingQueue** ，可以防止资源耗尽的情况。当核心线程池满了以后，如果队列也满了，则会创建归属于非核心线程池的工作线程，如果非核心线程池也满了 ，才会执行拒绝策略。

### 2.3.5 拒绝策略

ThreadPoolExecutor在以下两种情况下会执行拒绝策略：

1. 当核心线程池满了以后，如果任务队列也满了，首先判断非核心线程池有没满，没有满就创建一个工作线程（归属非核心线程池）， 否则就会执行拒绝策略；
2. 提交任务时，ThreadPoolExecutor已经关闭了。

所谓拒绝策略，就是在构造ThreadPoolExecutor时，传入的**RejectedExecutionHandler**对象：

ThreadPoolExecutor一共提供了4种拒绝策略：

**1.AbortPolicy（默认）**

AbortPolicy策略其实就是抛出一个**RejectedExecutionException**异常：

**2.DiscardPolicy**

DiscardPolicy策略其实就是无为而治，什么都不做，等任务自己被回收：

**3.DiscardOldestPolicy**

DiscardOldestPolicy策略是丢弃任务队列中的最近一个任务，并执行当前任务：

**4.CallerRunsPolicy**

CallerRunsPolicy策略相当于以自身线程来执行任务，这样可以减缓新任务提交的速度。

## 2.4 线程池的关闭

ExecutorService接口提供两种方法来关闭线程池，这两种方法的区别主要在于是否会继续处理已经添加到任务队列中的任务。

### 2.4.1 shutdown

shutdown方法将线程池切换到**SHUTDOWN**状态（如果已经停止，则不用切换），并调用interruptIdleWorkers方法中断所有空闲的工作线程，最后调用tryTerminate尝试结束线程池：

这里要注意，如果执行Runnable任务的线程本身不响应中断，那么也就没有办法终止任务。

### 2.4.2 shutdownNow

shutdownNow方法的主要不同之处就是，它会将线程池的状态至少置为**STOP**，同时中断所有工作线程（无论该线程是空闲还是运行中），同时返回任务队列中的所有任务。

## 2.5 总结

最后，我们来回顾下ThreadPoolExecutor的整体结构，ThreadPoolExecutor的核心方法是execute，控制着工作线程的创建和任务的执行，如下图：

![clipboard.png](https://segmentfault.com/img/bVbjsWt?w=4106&h=4001)

同时，ThreadPoolExecutor中有几个比较重要的组件：阻塞队列、核心线程池、拒绝策略，它们的关系如下图，图中的序号表示execute的执行顺序，可以配合上面的流程图来理解：

![clipboard.png](https://segmentfault.com/img/bVbhXu3?w=746&h=425)

关于ThreadPoolExecutor这个线程池，最重要的是根据系统实际情况，合理进行线程池参数的设置以及阻塞队列的选择。现实情况下，一般会自己通过ThreadPoolExecutor的构造器去构建线程池，而非直接使用Executors工厂创建，因为这样更利于对参数的控制和调优。

另外，根据任务的特点，要有选择的配置核心线程池的大小：

- 如果任务是 **CPU 密集型**（需要进行大量计算、处理），则应该配置尽量少的线程，比如 CPU 个数 + 1，这样可以避免出现每个线程都需要使用很长时间但是有太多线程争抢资源的情况；
- 如果任务是 **IO密集型**（主要时间都在 I/O，CPU 空闲时间比较多），则应该配置多一些线程，比如 CPU 数的两倍，这样可以更高地压榨 CPU。

# 3 ScheduledThreadPoolExecutor

## 3.1 ScheduledThreadPoolExecutor简介

我们曾经提到过一种可对任务进行延迟/周期性调度的执行器（Executor），这类Executor一般实现了**ScheduledExecutorService**这个接口。ScheduledExecutorService在普通执行器接口（ExecutorService）的基础上引入了Future模式，使得可以限时或周期性地调度任务。

ScheduledThreadPoolExecutor其实是继承了ThreadPoolExecutor这个普通线程池，我们知道ThreadPoolExecutor中提交的任务都是实现了Runnable接口，但是ScheduledThreadPoolExecutor比较特殊，由于要满足任务的延迟/周期调度功能，它会对所有的Runnable任务都进行包装，包装成一个`RunnableScheduledFuture`任务。

RunnableScheduledFuture是Future模式中的一个接口，它的的作用就是可以异步地执行【延时/周期任务】。

另外，我们知道在ThreadPoolExecutor中，需要指定一个阻塞队列作为任务队列。ScheduledThreadPoolExecutor中也一样，不过特殊的是，ScheduledThreadPoolExecutor中的任务队列是一种特殊的延时队列（DelayQueue）。

DelayQueue底层基于优先队列（PriorityQueue）实现，是一种“堆”结构，通过该种阻塞队列可以实现任务的延迟到期执行（即每次从队列获取的任务都是最先到期的任务）。

ScheduledThreadPoolExecutor在内部定义了DelayQueue的变种——`DelayedWorkQueue`，它和DelayQueue类似，只不过要求所有入队元素必须实现**RunnableScheduledFuture**接口。

## 3.2 ScheduledThreadPoolExecutor基本原理

### 3.2.1 构造线程池

Executors使用`newScheduledThreadPool`工厂方法创建ScheduledThreadPoolExecutor：

ScheduledThreadPoolExecutor的构造器，内部其实都是调用了父类**ThreadPoolExecutor**的构造器，这里最需要注意的就是任务队列的选择——**DelayedWorkQueue**

### 3.2.2 线程池的调度

ScheduledThreadPoolExecutor的核心调度方法是`schedule`、`scheduleAtFixedRate`、`scheduleWithFixedDelay`，我们通过schedule方法来看下整个调度流程：

------

其中的**decorateTask**方法把Runnable任务包装成ScheduledFutureTask，用户可以根据自己的需要覆写该方法：

**注意：**ScheduledFutureTask是RunnableScheduledFuture接口的实现类，任务通过`period`字段来表示任务类型

ScheduledThreadPoolExecutor中的任务队列——**DelayedWorkQueue**，保存的元素就是ScheduledFutureTask。DelayedWorkQueue是一种**堆结构**，time最小的任务会排在堆顶（表示最早过期），每次出队都是取堆顶元素，这样最快到期的任务就会被先执行。如果两个ScheduledFutureTask的time相同，就比较它们的序号——sequenceNumber，序号小的代表先被提交，所以就会先执行。

------

schedule的核心是其中的**delayedExecute**方法：

通过delayedExecute可以看出，ScheduledThreadPoolExecutor的整个任务调度流程大致如下图：

![clipboard.png](https://segmentfault.com/img/bVbiwzr?w=3731&h=2121)

我们来分析这个过程：

1. 首先，任务被提交到线程池后，会判断线程池的状态，如果不是**RUNNING**状态会执行拒绝策略。
2. 然后，将任务添加到阻塞队列中。（注意，由于DelayedWorkQueue是无界队列，所以一定会**add**成功）
3. 然后，会创建一个工作线程，加入到核心线程池或者非核心线程池：

如果核心线程池未满，则新建的工作线程会被放到核心线程池中。如果核心线程池已经满了，ScheduledThreadPoolExecutor不会像ThreadPoolExecutor那样再去创建归属于非核心线程池的工作线程，而是直接返回。也就是说，**在ScheduledThreadPoolExecutor中，一旦核心线程池满了，就不会再去创建工作线程。**

**什么时候会创建一个归属于非核心线程池的工作线程？**
答案是，当通过setCorePoolSize方法设置核心线程池大小为0时，这里必须要保证任务能够被执行，所以会创建一个工作线程，放到非核心线程池中。

最后，线程池中的工作线程会去任务队列获取任务并执行，当任务被执行完成后，如果该任务是周期任务，则会重置time字段，并重新插入队列中，等待下次执行。这里注意从队列中获取元素的方法：

- 对于核心线程池中的工作线程来说，如果没有超时设置（`allowCoreThreadTimeOut == false`），则会使用阻塞方法**take**获取任务（因为没有超时限制，所以会一直等待直到队列中有任务）；如果设置了超时，则会使用**poll**方法（方法入参需要超时时间），超时还没拿到任务的话，该工作线程就会被回收。
- 对于非工作线程来说，都是调用poll获取队列元素，超时取不到任务就会被回收。

上述就是ScheduledThreadPoolExecutor的核心调度流程，通过我们的分析可以看出，相比ThreadPoolExecutor，ScheduledThreadPoolExecutor主要有以下几点不同：

1. 总体的调度控制流程略有区别；
2. 任务的执行方式有所区别；
3. 任务队列的选择不同。

### 3.2.3 延时队列

DelayedWorkQueue，该队列和DelayQueue区别不大，只不过队列元素是RunnableScheduledFuture：

**DelayedWorkQueue**是一个无界队列，在队列元素满了以后会自动扩容，它并没有像DelayQueue那样，将队列操作委托给PriorityQueue，而是自己重新实现了一遍堆的核心操作——上浮、下沉。

每次出队元素时，如果队列为空或者队首元素还未到期，线程就会在condition条件队列等待。一般的思路是无限等待，直到出现一个入队线程，入队元素后将一个出队线程唤醒。

为了提升性能，当队列非空时，用`leader`保存第一个到来并尝试出队的线程，并设置它的等待时间为队首元素的剩余期限，这样当元素过期后，线程也就自己唤醒了，不需要入队线程唤醒。这样做的好处就是提升一些性能。

## 3.3 总结

本节介绍了ScheduledThreadPoolExecutor，它是对普通线程池ThreadPoolExecutor的扩展，增加了延时调度、周期调度任务的功能。概括下ScheduledThreadPoolExecutor的主要特点：

1. 对Runnable任务进行包装，封装成`ScheduledFutureTask`，该类任务支持任务的周期执行、延迟执行；
2. 采用`DelayedWorkQueue`作为任务队列。该队列是无界队列，所以任务一定能添加成功，但是当工作线程尝试从队列取任务执行时，只有最先到期的任务会出队，如果没有任务或者队首任务未到期，则工作线程会阻塞；
3. `ScheduledThreadPoolExecutor`的任务调度流程与ThreadPoolExecutor略有区别，最大的区别就是，先往队列添加任务，然后创建工作线程执行任务。

另外，`maximumPoolSize`这个参数对ScheduledThreadPoolExecutor其实并没有作用，因为除非把corePoolSize设置为0，这种情况下ScheduledThreadPoolExecutor只会创建一个属于非核心线程池的工作线程；否则，ScheduledThreadPoolExecutor只会新建归属于核心线程池的工作线程，一旦核心线程池满了，就不再新建工作线程。

# 4 Future模式

## 4.1 Future模式简介

Future模式的主要作用就是异步地执行任务，并在需要的时候获取结果。我们知道，一般调用一个函数，需要等待函数执行完成，调用线程才会继续往下执行，如果是一些计算密集型任务，需要等待的时间可能就会比较长。

**Future模式**可以让调用方立即返回，然后它自己会在后面慢慢处理，此时调用者拿到的仅仅是一个**凭证**，调用者可以先去处理其它任务，在真正需要用到调用结果的场合，再使用凭证去获取调用结果。这个凭证就是这里的**Future**。

## 4.2 J.U.C中的Future模式

### 4.2.1 真实的任务类

我们需要执行的是一个任务，一般需要实现`Runnable`接口.

但是，如果我需要任务的返回结果呢，从Runnable的接口定义来看，并不能满足我们的要求，Runnable一般仅仅用于定义一个可以被线程执行的任务，它的run方法没有返回值：

于是，JDK提供了另一个接口——`Callable`，表示一个具有返回结果的任务：

所以，最终我们自定义的任务类一般都是实现了Callable接口。

### 4.2.2 凭证

第一节讲到，Future模式可以让调用方获取任务的一个凭证，以便将来拿着凭证去获取任务结果，凭证需要具有以下特点：

1. 在将来某个时间点，可以通过凭证获取任务的结果；
2. 可以支持取消。

从以上两点来看，我们首先想到的方式就是对Callable任务进行包装，包装成一个凭证，然后返回给调用方。
J.U.C提供了Future接口和它的实现类——`FutureTask`来满足我们的需求。我们可以像下面这样对之前定义的ComplexTask包装：

```java
ComplexTask task = new ComplexTask();
Future<Double> future = new FutureTask<Double>(task);
```

上面的FutureTask就是真实的“凭证”，Future则是该凭证的接口（从面向对象的角度来讲，调用方应面向接口操作）

Future接口很简单，提供了`isCancelled`和`isDone`两个方法监控任务的执行状态，一个`cancel`方法用于取消任务的执行。两个`get`方法用于获取任务的执行结果，如果任务未执行完成，除非设置超时，否则调用线程将会阻塞。

此外，为了能够被线程或线程池执行任务，凭证还需要实现Runnable接口，所以J.U.C还提供了一个`RunnableFuture`接口，其实就是组合了Runnable和Future接口：

上面提到的**FutureTask**，其实就是实现了**RunnableFuture**接口的“凭证”：

从构造函数可以看到，FutureTask既可以包装Callable任务，也可以包装Runnable任务，但最终都是将Runnable转换成Callable任务，其实是一个适配过程。

### 4.2.3 调用方

最终，调用方可以以下面这种方式使用 Future模式，异步地获取任务的执行结果。

```java
public class Client {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ComplexTask task = new ComplexTask();
        Future<Double> future = new FutureTask<Double>(task);
        // time passed...
        Double result = future.get();
    }
}
```

通过上面的分析，可以看到，整个Future模式其实就三个核心组件：

- **真实任务/数据类**（通常任务执行比较慢，或数据构造需要较长时间），即示例中的ComplexTask
- **Future接口**（调用方使用该凭证获取真实任务/数据的结果），即Future接口
- **Future实现类**（用于对真实任务/数据进行包装），即FutureTask实现类

## 4.3 FutureTask原理

在J.U.C提供的Future模式中，最重要的就是`FutureTask`类，它代表着一个异步任务，这个任务一般提交给Executor执行，当然也可以由调用方直接调用run方法运行。

既然是任务，就有状态，FutureTask一共给任务定义了**7种**状态：

- **NEW：**表示任务的初始化状态；
- **COMPLETING：**表示任务已执行完成（正常完成或异常完成），但任务结果或异常原因还未设置完成，属于中间状态；
- **NORMAL：**表示任务已经执行完成（正常完成），且任务结果已设置完成，属于最终状态；
- **EXCEPTIONAL：**表示任务已经执行完成（异常完成），且任务异常已设置完成，属于最终状态；
- **CANCELLED：**表示任务还没开始执行就被取消（非中断方式），属于最终状态；
- **INTERRUPTING：**表示任务还没开始执行就被取消（中断方式），正式被中断前的过渡状态，属于中间状态；
- **INTERRUPTED：**表示任务还没开始执行就被取消（中断方式），且已被中断，属于最终状态。

各个状态之间的状态转换图如下：

![clipboard.png](https://segmentfault.com/img/bVbiwLO?w=3330&h=2115)

上图需要注意的是两点：

1. FutureTask虽然支持任务的取消（cancel方法），但是只有当任务是初始化（**NEW**状态）时才有效，否则cancel方法直接返回false；
2. 当执行任务时（run方法），无论成功或异常，都会先过渡到**COMPLETING**状态，直到任务结果设置完成后，才会进入响应的终态。

JDK1.7之前，FutureTask通过内部类实现了AQS框架来实现功能。 JDK1.7及以后，则改变为直接通过`Unsafe`类CAS操作`state`状态字段来进行同步。

### 4.3.1 构造

FutureTask在构造时可以接受Runnable或Callable任务，如果是Runnable，则最终包装成Callable：

FutureTask的字段定义非常简单，State标识任务的当前状态，状态之间的转换通过Unsafe来操作，所有操作都基于**自旋+CAS**完成：

注意`waiters`这个字段，waiters指向一个“无锁栈”，该栈保存着所有等待线程，我们知道当调用FutureTask的get方法时，如果任务没有完成，则调用线程会被阻塞，其实就是将线程包装成`WaitNode`结点保存到waiters指向的栈中：

![clipboard.png](https://segmentfault.com/img/bVbiwFZ?w=231&h=422)

### 4.3.2 任务的运行

FutureTask的运行就是调用了**run**方法

首先判断当前任务的state是否等于NEW,如果不为NEW则说明任务或者已经执行过，或者已经被取消，直接返回。

正常执行完成后，会调用`set`方法设置任务执行结果：

如果任务执行过程中抛出异常，则调用`setException`设置异常信息：

### 4.3.3 任务的取消

**cancel**方法用于取消任务，参数`mayInterruptIfRunning`如果为true，表示中断正在执行任务的线程，否则仅仅是将任务状态置为**CANCELLED** ：

任务取消后，最终调用`finishCompletion`方法，释放所有在栈上等待的线程：

### 4.3.4 结果获取

FutureTask可以通过get方法获取任务结果，如果需要限时等待，可以调用`get(long timeout, TimeUnit unit)`。

可以看到，如果当前任务的状态是**NEW**或**COMPLETING**，会调用`awaitDone`阻塞线程。否则会认为任务已经完成，直接通过`report`方法映射结果：

report会根据任务的状态进行映射，如果任务是Normal状态，说明正常执行完成，则返回任务结果；如果任务被取消（CANCELLED或INTERRUPTED），则抛出CancellationException；其它情况则抛出ExecutionException。

![å¾çåèèªhttp://www.importnew.com/25286.html](https://segmentfault.com/img/bVbiwbX?w=495&h=368)

## 4.4 ScheduledFutureTask

ScheduledFutureTask是**ScheduledThreadPoolExecutor**这个线程池的默认调度任务类。

ScheduledFutureTask在普通FutureTask的基础上增加了周期执行/延迟执行的功能。通过下面的类图可以看到，它其实是通过继承FutureTask和Delayed接口来实现周期/延迟功能的。

ScheduledFutureTask的源码非常简单，基本都是委托FutureTask来实现的，关键是看下运行任务的方法：

FutureTask的`runAndReset`方法与run方法的区别就是当任务正常执行完成后，不会设置任务的最终状态（即保持NEW状态），以便任务重复执行：

## 4.5 总结

本章我们从源头开始，讲解了Future模式的来龙去脉，并以J.U.C中的Future模式为例，分析了Future模式的组件以及核心实现类——`FutureTask`，最后回顾了ScheduledFutureTask中定义的内部异步任务类——`ScheduledFutureTask`。

理解Future模式的关键就是理解它的两个核心组件，可以类比生活中的凭证来理解这一概念，不必拘泥于Java多线程设计模式中Future模式的类关系图。

- 真实任务类
- 凭证

# 5 Fork/Join框架

## 5.1 引言

算法领域有一种基本思想叫做“**分治**”，所谓“分治”就是将一个难以直接解决的大问题，分割成一些规模较小的子问题，以便各个击破，分而治之。

比如：对于一个规模为N的问题，若该问题可以容易地解决，则直接解决；否则将其分解为K个规模较小的子问题，这些子问题互相独立且与原问题性质相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解，这种算法设计策略叫做分治法。

许多基础算法都运用了“分治”的思想，比如二分查找、快速排序等等。

基于“分治”的思想，J.U.C在JDK1.7时引入了一套**Fork/Join**框架。Fork/Join框架的基本思想就是将一个大任务分解（**Fork**）成一系列子任务，子任务可以继续往下分解，当多个不同的子任务都执行完成后，可以将它们各自的结果合并（**Join**）成一个大结果，最终合并成大任务的结果：

![å¾çåèèªãJavaå¹¶åç¼ç¨çèºæ¯ã](https://segmentfault.com/img/bVbiVVn?w=813&h=433)

## 5.2 工作窃取算法

从上述Fork/Join框架的描述可以看出，我们需要一些线程来执行Fork出的任务，在实际中，如果每次都创建新的线程执行任务，对系统资源的开销会很大，所以Fork/Join框架利用了线程池来调度任务。

另外，这里可以思考一个问题，既然由线程池调度，根据我们之前学习线程池的经验，必然存在两个要素：

- 工作线程
- 任务队列

一般的线程池只有一个任务队列，但是对于Fork/Join框架来说，由于Fork出的各个子任务其实是平行关系，为了提高效率，减少线程竞争，应该将这些平行的任务放到不同的队列中去，如上图中，大任务分解成三个子任务：子任务1、子任务2、子任务3，那么就创建三个任务队列，然后再创建3个工作线程与队列一一对应。

由于线程处理不同任务的速度不同，这样就可能存在某个线程先执行完了自己队列中的任务的情况，这时为了提升效率，我们可以让该线程去“窃取”其它任务队列中的任务，这就是所谓的**工作窃取算法**。

“工作窃取”的示意图如下，当线程1执行完自身任务队列中的任务后，尝试从线程2的任务队列中“窃取”任务：

![å¾çåèèªãJavaå¹¶åç¼ç¨çèºæ¯ã](https://segmentfault.com/img/bVbiVVo?w=844&h=294)

对于一般的队列来说，入队元素都是在“队尾”，出队元素在“队首”，要满足“工作窃取”的需求，任务队列应该支持从“队尾”出队元素，这样可以减少与其它工作线程的冲突（因为正常情况下，其它工作线程从“队首”获取自己任务队列中的任务），满足这一需求的任务队列其实就是我们在juc-collections框架中介绍过的双端阻塞队列——LinkedBlockingDeque。出于性能考虑，J.U.C中的Fork/Join框架并没有直接利用LinkedBlockingDeque作为任务队列，而是自己重新实现了一个。

**注意：**ForkJoinTask在执行的时候可能会抛出异常，但是没办法在主线程里直接捕获异常，所以ForkJoinTask提供了`isCompletedAbnormally()`方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的`getException`方法获取异常.

## 5.3 核心组件

主要涉及三大核心组件：`ForkJoinPool`（线程池）、`ForkJoinTask`（任务）、`ForkJoinWorkerThread`（工作线程），外加`WorkQueue`（任务队列）：

- **ForkJoinPool**：ExecutorService的实现类，负责工作线程的管理、任务队列的维护，以及控制整个任务调度流程；
- **ForkJoinTask**：Future接口的实现类，fork是其核心方法，用于分解任务并异步执行；而join方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果；
- **ForkJoinWorkerThread**：Thread的子类，作为线程池中的工作线程（Worker）执行任务；
- **WorkQueue**：任务队列，用于保存任务；

### 5.3.1 ForkJoinPool

ForkJoinPool是ExecutorService的一个实现类.

ForkJoinPool的主要工作如下：

1. 接受外部任务的提交（外部调用ForkJoinPool的`invoke`/`execute`/`submit`方法提交任务）；
2. 接受ForkJoinTask自身**fork**出的子任务的提交；
3. 任务队列数组（`WorkQueue[]`）的初始化和管理；
4. 工作线程（Worker）的创建/管理。

**注意：**ForkJoinPool提供了3类外部提交任务的方法：**invoke**、**execute**、**submit**，它们的主要区别在于任务的执行方式上。

- 通过**invoke**方法提交的任务，调用线程直到任务执行完成才会返回，也就是说这是一个**同步**方法，且**有返回结果**；
- 通过**execute**方法提交的任务，调用线程会立即返回，也就是说这是一个**异步**方法，且**没有返回结果**；
- 通过**submit**方法提交的任务，调用线程会立即返回，也就是说这是一个**异步**方法，且**有返回结果**（返回Future实现类，可以通过get获取结果）。

ForkJoinPool对象的构建有两种方式：

1. 通过3种构造器的任意一种进行构造；
2. 通过`ForkJoinPool.commonPool()`静态方法构造。

JDK8以后，ForkJoinPool又提供了一个静态方法commonPool()，这个方法返回一个ForkJoinPool内部声明的静态ForkJoinPool实例，主要是为了简化线程池的构建，这个ForkJoinPool实例可以满足大多数的使用场景：

ForkJoinPool对外提供的3种构造器，其实最终都调用了下面这个构造器：

```java
/**
 * @param parallelism      并行级别, 默认为CPU核心数
 * @param factory          工作线程工厂
 * @param handler          异常处理器
 * @param mode             调度模式: true表示FIFO_QUEUE; false表示LIFO_QUEUE
 * @param workerNamePrefix 工作线程的名称前缀
 */
private ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler,
                     int mode, String workerNamePrefix)
```

- **parallelism**：默认值为CPU核心数，ForkJoinPool里工作线程数量与该参数有关，但它不表示最大线程数；
- **factory**：工作线程工厂，默认是DefaultForkJoinWorkerThreadFactory，其实就是用来创建工作线程对象——ForkJoinWorkerThread；
- **handler**：异常处理器；
- **config**：保存parallelism和mode信息，供后续读取；
- **ctl**：线程池的核心控制字段

这些入参目前不用关注，我们重点是`mode`这个字段，ForkJoinPool支持两种模式：

1. 同步模式（默认方式）
2. 异步模式

`mode = asyncMode ? FIFO_QUEUE : LIFO_QUEUE`

**注意：**这里的同步/异步并不是指F/J框架本身是采用同步模式还是采用异步模式工作，而是指其中的工作线程的工作方式。在F/J框架中，每个工作线程（Worker）都有一个属于自己的任务队列（WorkQueue），这是一个底层采用数组实现的**双向队列**。

同步是指：对于工作线程（Worker）自身队列中的任务，采用**后进先出（LIFO）**的方式执行；异步是指：对于工作线程（Worker）自身队列中的任务，采用**先进先出（FIFO）**的方式执行。

### 5.3.2 ForkJoinTask

从Fork/Join框架的描述上来看，“任务”必须要满足一定的条件：

1. 支持Fork，即任务自身的分解
2. 支持Join，即任务结果的合并

因此，J.U.C提供了一个抽象类——**ForkJoinTask**，来作为该类Fork/Join任务的抽象定义

ForkJoinTask实现了Future接口，是一个异步任务，我们在使用Fork/Join框架时，一般需要使用线程池来调度任务，线程池内部调度的其实都是ForkJoinTask任务（即使提交的是一个Runnable或Callable任务，也会被适配成ForkJoinTask）。

除了ForkJoinTask，Fork/Join框架还提供了两个它的抽象实现，我们在自定义ForkJoin任务时，一般继承这两个类：

- **RecursiveAction**：表示具有返回结果的ForkJoin任务
- **RecursiveTask**：表示没有返回结果的ForkJoin任务

ForkJoinTask除了和ForkJoinPool 结合使用外，也可以单独使用，当我们调用ForkJoinTask的fork方法时，其内部会通过`ForkJoinPool.commonPool()`方法创建线程池，然后将自己作为任务提交给线程池。

### 5.3.3 ForkJoinWorkerThread

Fork/Join框架中，每个工作线程（Worker）都有一个自己的任务队列（WorkerQueue）， 所以需要对一般的Thread做些特性化处理，J.U.C提供了**ForkJoinWorkerThread**类作为ForkJoinPool中的工作线程.

```java
public class ForkJoinWorkerThread extends Thread {
    
    final ForkJoinPool pool;                    // 该工作线程归属的线程池
    final ForkJoinPool.WorkQueue workQueue;     // 对应的任务队列
 
    protected ForkJoinWorkerThread(ForkJoinPool pool) {
        super("aForkJoinWorkerThread");         // 指定工作线程名称
        this.pool = pool;
        this.workQueue = pool.registerWorker(this);
    }
    // ...
}
```

ForkJoinWorkerThread 在构造过程中，会保存**所属线程池**信息和与自己**绑定的任务队列**信息。同时，它会通过ForkJoinPool的`registerWorker`方法将自己注册到线程池中。

线程池中的每个工作线程（ForkJoinWorkerThread）都有一个自己的任务队列（WorkQueue），工作线程优先处理自身队列中的任务（LIFO或FIFO顺序，由线程池构造时的参数 `mode` 决定），自身队列为空时，以FIFO的顺序随机窃取其它队列中的任务。

### 5.3.4 WorkQueue

任务队列（**WorkQueue**）是ForkJoinPool与其它线程池区别最大的地方，在ForkJoinPool内部，维护着一个`WorkQueue[]`数组，它会在外部首次提交任务时进行初始化：

当通过线程池的外部方法（**submit**、**invoke**、**execute**）提交任务时，如果`WorkQueue[]`没有初始化，则会进行初始化；然后根据数组大小和线程随机数（`ThreadLocalRandom.probe`）等信息，计算出任务队列所在的数组索引（这个索引一定是**偶数**），如果索引处没有任务队列，则初始化一个，再将任务入队。也就是说，通过外部方法提交的任务一定是在偶数队列，没有绑定工作线程。

**WorkQueue**作为ForkJoinPool的内部类，表示一个**双端队列**。双端队列既可以作为**栈**使用(LIFO)，也可以作为**队列**使用(FIFO)。ForkJoinPool的“工作窃取”正是利用了这个特点，当工作线程从自己的队列中获取任务时，**默认**总是以栈操作（LIFO）的方式从栈顶取任务；当工作线程尝试窃取其它任务队列中的任务时，则是FIFO的方式。

我们在ForkJoinPool一节中曾讲过，可以指定线程池的同步/异步模式（mode参数），其作用就在于此。同步模式就是“栈操作”，异步模式就是“队列操作”，影响的就是工作线程从自己队列中取任务的方式。

ForkJoinPool中的工作队列可以分为两类：

- 有工作线程（Worker）绑定的任务队列：数组下标始终是**奇数**，称为**task queue**，该队列中的任务均由工作线程调用产生（工作线程调用FutureTask.fork方法）；
- 没有工作线程（Worker）绑定的任务队列：数组下标始终是**偶数**，称为**submissions queue**，该队列中的任务全部由其它线程提交（也就是非工作线程调用execute/submit/invoke或者FutureTask.fork方法）。

## 5.4 线程池调度示例

假设有个非常大的long[]数组，通过FJ框架求解数组所有元素的和。

任务类定义，因为需要返回结果，所以继承RecursiveTask，并覆写**compute**方法。任务的fork通过ForkJoinTask的**fork**方法执行，join方法方法用于等待任务执行后返回：

```java
public class ArraySumTask extends RecursiveTask<Long> {
 
    private final int[] array;
    private final int begin;
    private final int end;
 
    private static final int THRESHOLD = 100;
 
    public ArraySumTask(int[] array, int begin, int end) {
        this.array = array;
        this.begin = begin;
        this.end = end;
    }
 
    @Override
    protected Long compute() {
        long sum = 0;
 
        if (end - begin + 1 < THRESHOLD) {      // 小于阈值, 直接计算
            for (int i = begin; i <= end; i++) {
                sum += array[i];
            }
        } else {
            int middle = (end + begin) / 2;
            ArraySumTask subtask1 = new ArraySumTask(this.array, begin, middle);
            ArraySumTask subtask2 = new ArraySumTask(this.array, middle + 1, end);
 
            subtask1.fork();
            subtask2.fork();
 
            long sum1 = subtask1.join();
            long sum2 = subtask2.join();
 
            sum = sum1 + sum2;
        }
        return sum;
    }
}
```

调用方如下：

```java
public class Main {
    public static void main(String[] args) {
        ForkJoinPool executor = new ForkJoinPool();
        ArraySumTask task = new ArraySumTask(new int[10000], 0, 9999);
 
        ForkJoinTask future = executor.submit(task);
 
        // some time passed...
 
        if (future.isCompletedAbnormally()) {
            System.out.println(future.getException());
        }
 
        try {
            System.out.println("result: " + future.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
 
    }
}
```

假设现在通过ForkJoinPool的submit方法提交了一个FuturetTask任务

### 5.4.1 初始

初始状态下，线程池中的任务队列为空，`workQueues == null`，也没有工作线程：

![clipboard.png](https://segmentfault.com/img/bVbiVX8?w=706&h=403)

### 5.4.2 外部提交FutureTask任务

此时会初始化任务队列数组`WorkQueue[]`，大小为**2的幂次**，然后在某个槽位（**偶数**位）初始化一个任务队列（`WorkQueue`），并插入任务：

![clipboard.png](https://segmentfault.com/img/bVbiVYh?w=706&h=403)

注意，由于是非工作线程通过外部方法提交的任务，所以这个任务队列并没有绑定工作线程。

> 之所以是2的幂次，是由于ForkJoinPool采用了一种随机算法，该算法通过线程池随机数（ThreadLocalRandom的probe值）和数组的大小计算出工作线程所映射的数组槽位，这种算法要求数组大小为2的幂次。

### 5.4.3 创建工作线程

首次提交任务后，由于没有工作线程，所以会创建一个工作线程，同时在某个**奇数**槽的位置创建一个与它绑定的任务队列，如下图：

![clipboard.png](https://segmentfault.com/img/bVbiVYp?w=706&h=403)

### 5.4.4 窃取任务

ForkJoinWorkThread_1会随机扫描workQueues中的队列，直到找到一个可以窃取的队列——`workQueues[2]`，然后从该队列的`base`端获取任务并执行，并将`base`加1：

![clipboard.png](https://segmentfault.com/img/bVbiVYu?w=706&h=403)

窃取到的任务是FutureTask，ForkJoinWorkThread_1最终会调用它的`compute`方法（子类继承ForkJoinTask，覆写compute），该方法中会新建两个子任务，并执行它们的`fork`方法：

之前说过，由于是由工作线程ForkJoinWorkThread_1来调用FutureTask的`fork`方法，所以会将这两个子任务放入ForkJoinWorkThread_1自身队列中：

![clipboard.png](https://segmentfault.com/img/bVbiVYB?w=706&h=403)

然后，ForkJoinWorkThread_1会阻塞等待任务1和任务2的结果（先在`subtask1.join`等待）

```java
long sum1 = subtask1.join();
long sum2 = subtask2.join();
```

从这里也可以看出，任务放到哪个队列，其实是**由调用线程来决定**的（根据线程探针值probe计算队列索引）。如果调用线程是工作线程，则必然有自己的队列（**task queue**），则任务都会放到自己的队列中；如果调用线程是其它线程（如主线程），则创建没有工作线程绑定的任务队列（**submissions queue**），然后存入任务。

### 5.4.5 新的工作线程

ForkJoinWorkThread_1调用两个子任务1和2的`fork`方法，除了将它们放入自己的任务队列外，还会导致新增一个工作线程ForkJoinWorkThread_2：

![clipboard.png](https://segmentfault.com/img/bVbiVYG?w=749&h=403)

ForkJoinWorkThread_2运行后会像ForkJoinWorkThread_1那样从其它队列窃取任务，如下图，从ForkJoinWorkThread_1队列的`base`端窃取一个任务（直接执行，并不会放入自己队列）：

![clipboard.png](https://segmentfault.com/img/bVbiVYI?w=749&h=403)

窃取完成后，ForkJoinWorkThread_2会直接执行任务1，又回到了FutureTask子类的`compute`方法，假设此时又`fork`出两个任务——任务3、任务4，则ForkJoinWorkThread_2最终会在任务3的`join`方法上等待：

![clipboard.png](https://segmentfault.com/img/bVbiVYL?w=749&h=403)

如果此时还有其它工作线程，则重复上述步骤：`窃取、执行、入队、join阻塞、返回`。ForkJoinTask的join方法内部逻辑非常复杂，上述ForkJoinWorkThread_1和ForkJoinWorkThread_2目前都在等待任务的完成，但事实上，ForkJoinTask存在一种**互助机制**，即工作线程之间可以互相帮助执行任务，这里不详细展开，只需要知道，ForkJoinWorkThread_1和ForkJoinWorkThread_2可能会被其它工作线程唤醒。

我们这里假设ForkJoinWorkThread_2被其它某个工作线程唤醒，任务3和任务4的join方法依次返回了结果，那么任务1的结果也会返回，于是ForkJoinWorkThread_1也被唤醒（它在任务1的join上等待），然后ForkJoinWorkThread_1会继续执行任务2的join方法，如果任务2不再分解，则最终返回任务1和任务2的合并结果，计算结束。

### 5.4.6 自身队列的任务执行

ForkJoinWorkThread_1和ForkJoinWorkThread_2唤醒执行完窃取到的任务后，还没有结束，它们还会去看看自身队列中有无任务可以执行。

我们假设此时的线程池是下面这种状态：

![clipboard.png](https://segmentfault.com/img/bVbiVYY?w=706&h=403)

工作线程ForkJoinWorkThread_1调用**execLocalTasks**方法一次性执行自己队列中的所有任务，这时分成两种情况：

**1.异步模式（asyncMode==true）**

如果构造线程池时，asyncMode为true，表示以异步模式执行工作线程自身队列中的任务，此时会从 `base -> top`遍历并执行所有任务。

**2.同步模式（asyncMode==false）**

如果构造线程池时，asyncMode为false（默认情况），表示以同步模式执行工作线程自身队列中的任务，此时会从 `top -> base` 遍历并执行所有任务。

任务的入队总是在`top`端，所以当以同步模式遍历时，其实相当于栈操作（从栈顶pop元素）；
如果是异步模式，相当于队列的出队操作（从base端poll元素）。

**异步模式比较适合于那些不需要返回结果的任务**。其实如果将队列中的任务看成一棵树（无环连通图）的话，异步模式类似于图的广度优先遍历，同步模式类似于图的深度优先遍历

假设此处以默认的**同步模式**遍历，ForkJoinWorkThread_1从栈顶开始执行并移除任务，先执行任务2并移除，再执行任务1并：

![clipboard.png](https://segmentfault.com/img/bVbiVY9?w=706&h=403)

![clipboard.png](https://segmentfault.com/img/bVbiVYu?w=706&h=403)

## 5.5 任务调度流程

![å¾çæè¿°](https://segmentfault.com/img/bVbiYFp?w=9191&h=4681)

F/J框架调度任务的流程一共可以分为四大部分。

### 5.5.1 任务提交

任务提交是整个调度流程的第一步，F/J框架所调度的任务来源有两种：

**①外部提交任务**

所谓外部提交任务，是指通过**ForkJoinPool**的`execute`/`submit`/`invoke`方法提交的任务，或者非工作线程（**ForkJoinWorkerThread**）直接调用**ForkJoinTask**的`fork`/`invoke`方法提交的任务：

外部提交的任务的特点就是**调用线程是非工作线程**。

**②工作线程fork任务**

所谓工作线程fork任务，是指由ForkJoinPool所维护的工作线程（ForkJoinWorkerThread）从自身任务队列中获取任务（或从其它任务队列窃取），然后执行任务。

工作线程fork任务的特点就是**调用线程是工作线程**。

### 5.5.2 创建工作线程

任务提交完成后，ForkJoinPool会根据情况创建或唤醒工作线程，以便执行任务。

ForkJoinPool并不会为每个任务都创建工作线程，而是根据实际情况（构造线程池时的参数）确定是唤醒已有空闲工作线程，还是新建工作线程。这个过程还是涉及任务队列的绑定、工作线程的注销等过程

### 5.5.3 任务执行

任务入队后，由工作线程开始执行，这个过程涉及任务窃取、工作线程等待等过程

### 5.5.4 任务结果获取

任务结果一般通过**ForkJoinTask**的`join`方法获得，其主要流程如下图：

![clipboard.png](https://segmentfault.com/img/bVbiYG5?w=627&h=395)

任务结果获取的核心涉及两点：

- 互助窃取：`ForkJoinPool.helpStealer`
- 算力补偿：`ForkJoinPool.tryCompensate`

## 5.6 总结

本章简要概述了Fork/Join框架的思想、主要组件及基本使用，Fork/Join框架的核心包含四大组件：**ForkJoinTask**任务类、**ForkJoinPool**线程池、**ForkJoinWorkerThread**工作线程、**WorkQueue**任务队列。

本章通过示例，描述了各个组件的关系以及ForkJoin线程池的整个调度流程，F/J框架的核心来自于它的工作窃取及调度策略，可以总结为以下几点：

1. 每个Worker线程利用它自己的任务队列维护可执行任务；
2. 任务队列是一种双端队列，支持LIFO的**push**和**pop**操作，也支持FIFO的**take**操作；
3. 任务fork的子任务，只会push到它所在线程（调用fork方法的线程）的队列；
4. 工作线程既可以使用LIFO通过pop处理自己队列中的任务，也可以FIFO通过poll处理自己队列中的任务，具体取决于构造线程池时的asyncMode参数；
5. 当工作线程自己队列中没有待处理任务时，它尝试去随机读取（窃取）其它任务队列的base端的任务；
6. 当线程进入join操作，它也会去处理其它工作线程的队列中的任务（自己的已经处理完了），直到目标任务完成（通过isDone方法）；
7. 当一个工作线程没有任务了，并且尝试从其它队列窃取也失败了，它让出资源（通过使用yields, sleeps或者其它优先级调整）并且随后会再次激活，直到所有工作线程都空闲了——此时，它们都阻塞在等待另一个顶层线程的调用。zhix