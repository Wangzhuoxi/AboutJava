| 同步器名称     | 作用                                                         |
| :------------- | :----------------------------------------------------------- |
| CountDownLatch | 倒数计数器，构造时设定计数值，当计数值归零后，所有阻塞线程恢复执行；其内部实现了AQS框架 |
| CyclicBarrier  | 循环栅栏，构造时设定等待线程数，当所有线程都到达栅栏后，栅栏放行；其内部通过ReentrantLock和Condition实现同步 |
| Semaphore      | 信号量，类似于“令牌”，用于控制共享资源的访问数量；其内部实现了AQS框架 |
| Exchanger      | 交换器，类似于双向栅栏，用于线程之间的配对和数据交换；其内部根据并发情况有“单槽交换”和“多槽交换”之分 |
| Phaser         | 多阶段栅栏，相当于CyclicBarrier的升级版，可用于分阶段任务的并发控制执行；其内部比较复杂，支持树形结构，以减少并发带来的竞争 |

# 1 CountDownLatch

`CountDownLatch`是一个辅助同步器类，用来作计数使用，它的作用有点类似于生活中的倒数计数器，先设定一个计数初始值，当计数降到0时，将会触发一些事件，如火箭的倒数计时。

初始计数值在构造CountDownLatch对象时传入，每调用一次 **countDown()** 方法，计数值就会减1。

线程可以调用CountDownLatch的**await**方法进入阻塞，当计数值降到0时，所有之前调用**await**阻塞的线程都会释放。

**注意：**CountDownLatch的初始计数值一旦降到0，无法重置。如果需要重置，可以考虑使用CyclicBarrier。

ContDownLatch一般有以下几种用法：

1. 将初始计数值为1的 CountDownLatch 作为一个的开关或入口：在调用 **countDown()** 的线程打开入口前，所有调用 **await** 的线程都一直在入口处等待。
2. 将初始计数值为N的 CountDownLatch作为一个完成信号点：使某个线程在其它N个线程完成某项操作之前一直等待。

# 2 CyclicBarrier

## 2.1 CyclicBarrier简介

`CyclicBarrier`是一个辅助同步器类，在JDK1.5时随着J.U.C一起引入。

这个类的功能和CountDownLatch有些类似。我们知道，`CountDownLatch`是一个倒数计数器，在计数器不为0时，所有调用await的线程都会等待，当计数器降为0，线程才会继续执行，且计数器一旦变为0，就不能再重置了。

`CyclicBarrier`可以认为是一个栅栏，栅栏的作用是什么？就是阻挡前行。

顾名思义，CyclicBarrier是一个可以循环使用的栅栏，它做的事情就是：

**让线程到达栅栏时被阻塞(调用await方法)，直到到达栅栏的线程数满足指定数量要求时，栅栏才会打开放行。**

这其实有点像军训报数，报数总人数满足教官认为的总数时，教官才会安排后面的训练。

可以看下面这个图来理解下:
一共4个线程A、B、C、D，它们到达栅栏的顺序可能各不相同。当A、B、C到达栅栏后，由于没有满足总数【4】的要求，所以会一直等待，当线程D到达后，栅栏才会放行。

![clipboard.png](https://segmentfault.com/img/bVbeQv6?w=1076&h=380)

从CyclicBarrier的构造器，我们也可以看出关于这个类的一些端倪，CyclicBarrier有两个构造器：

构造器一：参数`parties`就是之前说的需要满足的计数总数。

构造器二：除了指定了计数总数外，传入了一个`Runnable`任务，Runnable任务其实就是当最后一个线程到达栅栏时，后续立即要执行的任务。

比如，军训报数完毕后，总人数满足了要求，教官就会开始命令大家执行下一个任务，这个【下一个任务】就是这里的Runnable。

5个运动员准备跑步比赛，运动员在赛跑前会准备一段时间，当裁判发现所有运动员准备完毕后，就举起发令枪，比赛开始。这里的起跑线就是屏障，运动员必须在起跑线等待其他运动员准备完毕。

## 2.2 CyclicBarrier对异常的处理

我们知道，线程在阻塞过程中，可能被中断，那么既然**CyclicBarrier**放行的条件是等待的线程数达到指定数目，万一线程被中断导致最终的等待线程数达不到栅栏的要求怎么办？

CyclicBarrier一定有考虑到这种异常情况，不然其它所有等待线程都会无限制地等待下去。

我们看下CyclicBarrier的`await()`方法：

```java
public int await() throws InterruptedException, BrokenBarrierException {
    //...
}
```

可以看到，这个方法除了抛出**InterruptedException**异常外，还会抛出`BrokenBarrierException`。

**BrokenBarrierException**表示当前的**CyclicBarrier**已经损坏了，可能等不到所有线程都到达栅栏了，所以已经在等待的线程也没必要再等了，可以散伙了。

出现以下几种情况之一时，当前等待线程会抛出**BrokenBarrierException**异常：

1. 其它某个正在await等待的线程被中断了
2. 其它某个正在await等待的线程超时了
3. 某个线程重置了**CyclicBarrier**(调用了**reset**方法，后面会讲到)

另外，只要正在Barrier上等待的任一线程抛出了异常，那么Barrier就会认为肯定是凑不齐所有线程了，就会将栅栏置为损坏（Broken）状态，并传播**BrokenBarrierException**给其它所有正在等待（await）的线程。

**注意：**使用`CyclicBarrier`时，对异常的处理一定要小心，比如线程在到达栅栏前就抛出异常，此时如果没有重试机制，其它已经到达栅栏的线程会一直等待（因为没有还没有满足总数），最终导致程序无法继续向下执行。

## 2.3 CyclicBarrier原理

### 2.3.1 CyclicBarrier的构造

**CyclicBarrier**有两个构造器：

![clipboard.png](https://segmentfault.com/img/bVbeUmj?w=675&h=225)

构造器内部的各个字段含义如下：

| 字段名         | 作用                         |
| :------------- | :--------------------------- |
| parties        | 栅栏开启需要的到达线程总数   |
| count          | 剩余未到达的线程总数         |
| barrierCommand | 最后一个线程到达后执行的任务 |

### 2.3.2 CyclicBarrier的内部结构

**CyclicBarrier** 并没有自己去实现AQS框架的API，而是利用了`ReentrantLock`和`Condition`。

![clipboard.png](https://segmentfault.com/img/bVbeUmJ?w=806&h=348)

我们知道，**CyclicBarrier** 是可以循环复用的，所以**CyclicBarrier** 的每一轮任务都需要对应一个generation 对象。
generation 对象内部有个**broken**字段，用来标识当前轮次的**CyclicBarrier** 是否已经损坏。
**nextGeneration**方法用来创建一个新的generation 对象，并唤醒所有等待线程，重置内部参数。

### 2.3.3 CyclicBarrier的核心方法

我们先来看下**await**方法：

可以看到，无论有没有超时功能，内部都是调了**dowait**这个方法：

**dowait**方法并不复杂，一共有3部分：

1. 判断栅栏是否已经损坏或当前线程已经被中断，如果是会分别抛出异常；
2. 如果当前线程是最后一个到达的线程，会尝试执行最终任务（如果构造**CyclicBarrier**对象时有传入**Runnable**的话），执行成功即返回，失败会破坏栅栏；
3. 对于不是最后一个到达的线程，会在**Condition**队列上等待，为了防止被意外唤醒，这里用了一个自旋操作。

破坏栅栏用的是**breakBarrier**方法：

再来看下**CyclicBarrier**的**reset**方法：该方法先破坏栅栏，然后开始下一轮（新建一个generation对象）。

# 3 Semaphore

## 3.1 Semaphore简介

`Semaphore`，又名信号量，这个类的作用有点类似于“许可证”。有时，我们因为一些原因需要控制同时访问共享资源的最大线程数量，比如出于系统性能的考虑需要限流，或者共享资源是稀缺资源，我们需要有一种办法能够协调各个线程，以保证合理的使用公共资源。

Semaphore维护了一个许可集，其实就是一定数量的“许可证”。当有线程想要访问共享资源时，需要先获取(acquire)的许可；如果许可不够了，线程需要一直等待，直到许可可用。当线程使用完共享资源后，可以归还(release)许可，以供其它需要的线程使用。

另外，Semaphore支持公平/非公平策略，这和ReentrantLock类似，后面讲Semaphore原理时会看到，它们的实现本身就是类似的。

当有线程尝试使用共享资源时，我们要求线程先获得“许可”（调用**Semaphore** 的**acquire**方法），这样线程就拥有了权限，否则就需要等待。当使用完资源后，线程需要调用**Semaphore** 的**release**方法释放许可。

**注意：**对于共享资源访问需要由锁来控制，Semaphore仅仅是保证了线程由权限使用共享资源，至于使用过程中是否由并发问题，需要通过锁来保证。

**总结一下，许可数 ≤ 0代表共享资源不可用。许可数 ＞ 0，代表共享资源可用，且多个线程可以同时访问共享资源。**

**这是不是和CountDownLatch有点像？**
我们来比较下：

| 同步器         | 作用                                                         |
| :------------- | :----------------------------------------------------------- |
| CountDownLatch | 同步状态`State > 0`表示资源不可用，所有线程需要等待；`State == 0`表示资源可用，所有线程可以同时访问 |
| Semaphore      | `剩余许可数 < 0`表示资源不可用，所有线程需要等待； `许可剩余数 ≥ 0`表示资源可用，所有线程可以同时访问 |

这其实就是对同步状态的定义不同。

## 3.2 Semaphore原理

可以看到，Semaphore果然是通过内部类实现了AQS框架提供的接口，而且基本结构几乎和ReentrantLock完全一样，通过内部类分别实现了公平/非公平策略。

**Semaphore**有两个构造器，一个指定许可数量，一个指定许可数量和是否采用公平策略，默认是非公平的。

## 3.3 Semaphore的公平策略分析

假设现在一共3个线程：**ThreadA**、**ThreadB**、**ThreadC**。一个许可数为2的公平策略的**Semaphore**。线程的调用顺序如下：

```java
Semaphore sm = new Semaphore (2, true);

// ThreadA: sm.acquire()
// ThreadB: sm.acquire(2)
// ThreadC: sm.acquire()
// ThreadA: sm.release()
// ThreadB: sm.release(2)
```

### 3.3.1 创建公平策略的Semaphore对象

可以看到，内部创建了一个**FairSync**对象，并传入许可数**permits**：

**Sync**是**Semaphore**的一个内部抽象类，公平策略的**FairSync**和非公平策略的**NonFairSync**都继承该类。

可以看到，构造器传入的permits值就是同步状态的值，这也体现了我们在AQS系列中说过的：

AQS框架的设计思想就是分离构建同步器时的一系列关注点，它的所有操作都围绕着资源——*同步状态（synchronization state）*来展开，并将资源的定义和访问留给用户解决：

### 3.3.2 ThreadA调用acqure方法

**Semaphore**的**acquire**方法内部调用了AQS的方法，入参"1"表示尝试获取1个许可：

AQS的**acquireSharedInterruptibly**方式是共享功能的一部分，我们在AQS系列中就已经对它很熟悉了：

关键来看下**Semaphore**是如何实现**tryAcquireShared**方法的：

![clipboard.png](https://segmentfault.com/img/bVbe2aQ?w=1032&h=550)

对于**Semaphore**来说，线程是可以一次性尝试获取多个许可的，此时只要剩余的许可数量够，最终会通过自旋操作更新成功。如果剩余许可数量不够，会返回一个负数，表示获取失败。

显然，**ThreadA**获取许可成功。此时，同步状态值`State == 1`，等待队列的结构如下：

![clipboard.png](https://segmentfault.com/img/bVbetLZ?w=120&h=176)

### 3.3.3 ThreadB调用acqure(2)方法

带入参的**aquire**方法内部和无参的一样，都是调用了AQS的acquireSharedInterruptibly方法：

此时，ThreadB一样进入**tryAcquireShared**方法。不同的是，此时剩余许可数不足，因为ThreadB一次性获取2个许可，**tryAcquireShared**方法返回一个负数，表示获取失败：

ThreadB会调用**doAcquireSharedInterruptibly**方法：

![clipboard.png](https://segmentfault.com/img/bVbe2Yk?w=1266&h=511)

上述方法首先通过**addWaiter**方法将ThreadB包装成一个共享结点，加入等待队列：

![clipboard.png](https://segmentfault.com/img/bVbetM7?w=427&h=271)

然后会进入自旋操作，先尝试获取一次资源，显然此时是获取失败的，然后通过**shouldParkAfterFailedAcquire**判断是否要进入阻塞

上述方法会先将前驱结点的状态置为**SIGNAL**，表示ThreadB需要阻塞，但在阻塞之前需要将前驱置为**SIGNAL**，以便将来可以唤醒ThreadB。

最终ThreadB会在**parkAndCheckInterrupt**中进入阻塞：

此时，同步状态值依然是`State == 1`，等待队列的结构如下：

![clipboard.png](https://segmentfault.com/img/bVbetM3?w=427&h=271)

### 3.3.4 ThreadC调用acqure()方法

流程和步骤3完全相同，ThreadC被包装成结点加入等待队列后：（因为是公平策略，它前面还有阻塞的线程，他不能获得）

![clipboard.png](https://segmentfault.com/img/bVbe4hj?w=686&h=265)

同步状态：`State == 1`

### 3.3.5 ThreadA调用release()方法

**Semaphore**的**realse**方法调用了AQS的**releaseShared**方法，默认入参为"1"，表示归还一个许可：

来看下**Semaphore**是如何实现**tryReleaseShared**方法的，**tryReleaseShared**方法是一个自旋操作，直到更新State成功：

更新完成后，`State == 2`,ThreadA会进入**doReleaseShared**方法，先将头结点状态置为0，表示即将唤醒后继结点：

此时，等待队列结构：

![clipboard.png](https://segmentfault.com/img/bVbe4i3?w=686&h=265)

然后调用**unparkSuccessor**方法唤醒后继结点：

此时，ThreadB被唤醒，会从原阻塞处继续向下执行：

![clipboard.png](https://segmentfault.com/img/bVbe4jd?w=686&h=265)

此时，同步状态：`State == 2`

### 3.3.6 ThreadB从原阻塞处继续执行

ThreadB被唤醒后，从下面开始继续往下执行，进入下一次自旋：

在下一次自旋中，ThreadB调用**tryAcquireShared**方法成功获取到共享资源（State修改为0），**setHeadAndPropagate**方法把ThreadB变为头结点，

并根据传播状态判断是否要唤醒并释放后继结点：

![clipboard.png](https://segmentfault.com/img/bVbe4jT?w=427&h=264)

同步状态：`State == 0`

ThreadB会调用**doReleaseShared**方法，继续尝试唤醒后继的共享结点（也就是ThreadC），这个过程和ThreadB被唤醒完全一样：

![clipboard.png](https://segmentfault.com/img/bVbe4j7?w=427&h=264)

同步状态：`State == 0`

### 3.3.7 ThreadC从原阻塞处继续执行

由于目前共享资源仍为0，所以ThreadC被唤醒后，在经过尝试获取资源失败后，又进入了阻塞：

![clipboard.png](https://segmentfault.com/img/bVbe4kn?w=427&h=264)

### 3.3.8 ThreadB调用release(2)方法

内部和无参的release方法一样：

更新完成后，`State == 2`,ThreadB会进入**doReleaseShared**方法，唤醒后继结点：

此时，等待队列结构：

![clipboard.png](https://segmentfault.com/img/bVbe4j7?w=427&h=264)

同步状态：`State == 2`

### 3.3.9 ThreadC从原阻塞处继续执行

由于目前共享资源为2，所以ThreadC被唤醒后，获取资源成功：

最终同步队列的结构如下：

![clipboard.png](https://segmentfault.com/img/bVbeun4?w=167&h=231)

同步状态：`State == 0`

## 3.4 总结

**Semaphore**其实就是实现了AQS共享功能的同步器，对于**Semaphore**来说，资源就是许可证的数量：

- 剩余许可证数（State值） - 尝试获取的许可数（**acquire**方法入参） ≥ 0：资源可用
- 剩余许可证数（State值） - 尝试获取的许可数（**acquire**方法入参） < 0：资源不可用

这里共享的含义是多个线程可以同时获取资源，当计算出的剩余资源不足时，线程就会阻塞。

**注意：**Semaphore不是锁，只能限制同时访问资源的线程数，至于对数据一致性的控制，Semaphore是不关心的。当前，如果是只有一个许可的Semaphore，可以当作锁使用。

### 3.4.1 Semaphore的非公平策略

另外，上述我们讨论的是**Semaphore**的公平策略，非公平策略的差异并不大：

可以看到，非公平策略不会去查看等待队列的队首是否有其它线程正在等待，而是直接尝试修改State值。

### 3.4.2 Semaphore的其它方法

**Semaphore**还有两个比较特殊的方法，这两个方法的特点是采用自旋操作State变量，直到成功为止。所以，并不会阻塞调用线程。

**reducePermits** ：立即减少指定数目的可用许可数。

**drainPermits**：用于将可用许可数清零，并返回清零前的许可数

# 4 Exchanger

## 4.1 Exchanger简介

`Exchanger`——交换器，是JDK1.5时引入的一个同步器，从字面上就可以看出，这个类的主要作用是交换数据。

Exchanger有点类似于`CyclicBarrier`，我们知道CyclicBarrier是一个栅栏，到达栅栏的线程需要等待其它一定数量的线程到达后，才能通过栅栏。

Exchanger可以看成是一个双向栅栏，如下图：

![clipboard.png](https://segmentfault.com/img/bVbfdci?w=1136&h=508)

Thread1线程到达栅栏后，会首先观察有没其它线程已经到达栅栏，如果没有就会等待，如果已经有其它线程（Thread2）已经到达了，就会以成对的方式交换各自携带的信息，因此Exchanger非常适合用于两个线程之间的数据交换。

## 4.2 Exchanger原理

### 4.2.1 Exchanger的构造

我们先来看下**Exchanger**的构造，**Exchanger**只有一个空构造器：

构造时，内部创建了一个**Participant**对象，**Participant**是Exchanger的一个内部类，本质就是一个ThreadLocal，用来保存线程本地变量**Node**：

我们可以把**Node**对象理解成每个线程自身携带的交换数据，：

![clipboard.png](https://segmentfault.com/img/bVbfdc8?w=1320&h=582)

### 4.2.2 Exchanger的单槽位交换

**Exchanger**有两种数据交换的方式，当并发量低的时候，内部采用“**单槽位交换**”；并发量高的时候会采用“**多槽位交换**”。

我们先来看下**exchange**方法：

![clipboard.png](https://segmentfault.com/img/bVbfddh?w=1384&h=438)

可以看到exchange其实就是一个用于判断数据交换方式的方法，它的内部会根据**Exchanger**的某些字段状态来判断当前应该采用**单槽交换**（**slotExchange**）还是**多槽交换**（**arenaExchange**），整个判断的流程图如下：

![clipboard.png](https://segmentfault.com/img/bVbfla0?w=3171&h=3091)

**Exchanger**的**arena**字段是一个**Node**类型的数组，代表了一个槽数组，只在多槽交换时会用到。此外，Exchanger还有一个**slot**字段，表示单槽交换结点，只在单槽交换时使用。

**slot**字段最终会指向首个到达的线程的自身Node结点，表示线程占用了槽位。

![clipboard.png](https://segmentfault.com/img/bVbfddw?w=536&h=286)

单槽交换示意图：

![clipboard.png](https://segmentfault.com/img/bVbflds?w=4366&h=2481)

我们来看下**Exchanger**具体是如何实现单槽交换的，单槽交换方法**slotExchange**并不复杂，**slotExchange**的入参**item**表示当前线程携带的数据，返回值正常情况下为配对线程携带的数据：

**首先到达的线程：**

1. 如果当前线程是首个到达的线程，会将**slot**字段指向自身的**Node**结点，表示槽位被占用；
2. 然后，线程会自旋一段时间，如果经过一段时间的自旋还是等不到配对线程到达，就会进入阻塞。（**这里之所以不直接阻塞，而是自旋，是出于线程上下文切换开销的考虑，属于一种优化手段**）

**稍后到达的配对线程：**

如果当前线程（配对线程）不是首个到达的线程，则到达时槽（**slot**）已经被占用，此时**slot**指向首个到达线程自身的**Node**结点。配对线程会将**slot**置空，并取Node中的**item**作为交换得到的数据返回，另外，配对线程会把自身携带的数据存入**Node**的**match**字段中，并唤醒`Node.parked`所指向的线程（也就是先到达的线程）。

**首先到达的线程被唤醒：**

线程被唤醒后，由于**match**不为空（存放了配对线程携带过来的数据），所以会退出自旋，然后将**match**对应的值返回。

这样，线程A和线程B就实现了数据交换，**整个过程都没有用到同步操作**。

### 4.2.3 Exchanger的多槽位交换

**Exchanger**最复杂的地方就是它的**多槽位交换（arenaExchange）**，我们先看下，什么时候会触发多槽位交换？
我们之前说了，并发量大的时候会触发多槽交换，这个说法并不准确。

如果在单槽交换中，同时出现了**多个配对线程竞争修改slot槽位，导致某个线程CAS修改slot失败时，就会初始化arena多槽数组，后续所有的交换都会走arenaExchange**：

多槽交换方法**arenaExchange**的整体流程和**slotExchange**类似，**主要区别在于它会根据当前线程的数据携带结点Node中的index字段计算出命中的槽位**。

如果槽位被占用，说明已经有线程先到了，之后的处理和**slotExchange**一样；

如果槽位有效且为null，说明当前线程是先到的，就占用槽位，然后按照：`spin->yield->block`这种锁升级的顺序进行优化的等待，等不到配对线程就会进入阻塞。

另外，由于**arenaExchange**利用了槽数组，所以涉及到槽数组的扩容和缩减问题，读者可以自己去研读源码。

其次，在定位**arena**数组的有效槽位时，需要考虑缓存行的影响。由于高速缓存与内存之间是以缓存行为单位交换数据的，根据局部性原理，相邻地址空间的数据会被加载到高速缓存的同一个数据块上（缓存行），而数组是连续的（逻辑，涉及到虚拟内存）内存地址空间，因此，多个**slot**会被加载到同一个缓存行上，当一个**slot**改变时，会导致这个**slot**所在的缓存行上所有的数据（包括其他的**slot**）无效，需要从内存重新加载，影响性能。

# 5 Phaser

## 5.1 Phaser简介

`Phaser`是**JDK1.7**开始引入的一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 **CyclicBarrier**和**CountDownLatch**有些类似，类似于一个多阶段的栅栏，并且功能更强大，我们来比较下这三者的功能：

| 同步器         | 作用                                                         |
| :------------- | :----------------------------------------------------------- |
| CountDownLatch | 倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归0后，所有等待的线程继续执行 |
| CyclicBarrier  | 循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行 |
| Phaser         | 多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance） |

**Phaser**中有一些比较重要的概念，理解了这些概念才能理解Phaser的功能。

### 5.1.1 phase(阶段)

我们知道，在**CyclicBarrier**中，只有一个栅栏，线程在到达栅栏后会等待其它线程的到达。

Phaser也有栅栏，在Phaser中，栅栏的名称叫做**phase(阶段)**，在任意时间点，Phaser只处于某一个**phase(阶段)**，初始阶段为0，最大达到`Integerr.MAX_VALUE`，然后再次归零。当所有**parties**参与者都到达后，**phase**值会递增。

Phaser中的phase(阶段)这个概念其实和**CyclicBarrier**中的**Generation**很相似，只不过**Generation**没有计数。

### 5.1.2 parties(参与者)

**parties(参与者)**其实就是**CyclicBarrier**中的参与线程的概念。

**CyclicBarrier**中的参与者在初始构造指定后就不能变更，而Phaser既可以在初始构造时指定参与者的数量，也可以中途通过`register`、`bulkRegister`、`arriveAndDeregister`等方法注册/注销参与者。

### 5.1.3 arrive(到达) / advance(进阶)

Phaser注册完**parties（参与者）**之后，参与者的初始状态是**unarrived**的，当参与者**到达（arrive）**当前阶段（phase）后，状态就会变成**arrived**。当阶段的到达参与者数满足条件后（注册的数量等于到达的数量），阶段就会发生**进阶（advance）**——也就是phase值+1。

![clipboard.png](https://segmentfault.com/img/bVbfk33?w=335&h=526)

### 5.1.4 Termination（终止）

代表当前**Phaser**对象达到终止状态，有点类似于**CyclicBarrier**中的栅栏被破坏的概念。

### 5.1.5 Tiering（分层）

Phaser支持**分层（Tiering）** —— 一种树形结构，通过构造函数可以指定当前待构造的Phaser对象的父结点。之所以引入**Tiering**，是因为当一个Phaser有大量**参与者（parties）**的时候，内部的同步操作会使性能急剧下降，而分层可以降低竞争，从而减小因同步导致的额外开销。

在一个分层Phasers的树结构中，注册和撤销子Phaser或父Phaser是自动被管理的。当一个Phaser的**参与者（parties）**数量变成0时，如果有该Phaser有父结点，就会将它从父结点中溢移除。

## 5.2 Phaser原理

### 5.2.1 Phaser的内部结构

之前我们说过，Phaser支持树形结构，一个复杂分层结构的Phaser树的内部结构如下图所示：

![clipboard.png](https://segmentfault.com/img/bVbfzuU?w=1422&h=846)

上面图中的几点关键点：

1. 树的根结点root链接着两个“无锁栈”——Treiber Stack，用于保存等待线程（比如当线程等待Phaser进入下一阶段时，会根据当前阶段的奇偶性，把自己挂到某个栈中），所有Phaser对象都共享这两个栈。
2. 当首次将某个Phaser结点链接到树中时，会同时向该结点的父结点注册一个参与者。

为什么需要向父结点注册参与者？

首先我们要明白对于Phaser来说，什么时候会发生跃迁（advance）进入下一阶段？

废话，当然是等它所有参与者都到达的时候。那么它所等待的参与者都包含那几类呢？

**①对于一个孤立的Phaser结点**（也可以看成是只有一个根结点的树）

其等待的参与者，就是显式注册的参与者，这也是最常见的情况。

比如下图，如果有10个Task共用这个Phaser，那等待的参与者数就是10，当10个线程都到达后，Phaser就会跃迁至下一阶段。

![clipboard.png](https://segmentfault.com/img/bVbfzu4?w=796&h=282)

②**对于一个非孤立的Phaser叶子结点**，比如下图中标绿的叶子结点

这种情况和①一样，子Phaser1和子Phaser2等待的参与者数是4，子Phaser3等待的参与者数是2。

![clipboard.png](https://segmentfault.com/img/bVbfzu6?w=1085&h=435)

③**对于一个非孤立非叶子的Phaser结点**，比如上图中标蓝色的结点

这是最特殊的一种情况，这也是Phaser同步器关于分层的主要设计思路。

这种情况，结点所等待的参与者数目包含两部分：

1. 直接显式注册的参与者（通过构造器或register方法）。——等于0
2. 子结点的数目。——等于3

也就是说在上图中，当左一的**子Phaser1**的4个参与者都到达后，它会通知父结点**Phaser**，自己的状态已经OK了，这时**Phaser**会认为**子Phaser1**已经准备就绪，会将自己的到达者数量加1，同理，当**子Phaser2**和**子Phaser3**的所有参与者分别到达后，它们也会依次通知**Phaser**，只有当Phaser（根结点）的到达者数量为3时，才会释放“无锁栈”中等待着的线程，并将阶段数phase增加1。

这是一种层层递归的设计，**只要当根结点的所有参与者都到达后（也就是到达参数者数等于其子结点数），所有等待线程才会放行，栅栏才会进入下一阶段。**

