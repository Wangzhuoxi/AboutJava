## 1 前言

1. 分布式锁，是控制分布式系统之间同步访问共享资源的一种方式
2. 在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。
3. 这里主要简单介绍三种方式：基于数据库实现方式、基于redis实现方式、基于ZooKeeper实现方式。

## 2 场景举例

1. 假设有一个进程A，每小时准点给用户发送一条短信"Hello world"，为了高可用，就必须在多台机器上面部署多个进程，避免宕机的情况；
2. 假设部署在两台机器，那么问题来了，用户每个小时就会收到两条"Hello world"，信息就重复了；
3. 我们希望只发送一条"Hello world"，那么就可以引入分布式锁的概念了；
4. 进程A和进程B发送短信前先去注册一个锁，假设进程A抢到了锁，进程B就等待结果，如果发送成功了，那么B就放弃此次任务，等待下一个小时。
5. 问题的核心就在于怎么注册锁，检查锁的存在和注册锁是一个原子性操作，类似mysql的主键，存在则不能insert，就是说你不能把我的锁覆盖了，你得等着；
6. 我们有多种方式可以实现分布式锁，最简单的就是以每小时准点这个时间作为主键，到mysql写入一条数据，利用数据库来维持一致性。

## 3 为什么要使用分布式锁

1. 我们在开发应用的时候，如果需要对某一个共享变量进行多线程同步访问的时候，可以使用我们学到的java多线程解决。

2. 注意这是单机应用，也就是所有的请求都会分配到当前服务器的jvm内部，然后映射为操作系统的线程进行处理，而这个共享变量只是在这个jvm内部的一块内存空间。

3. 后来业务发展，需要做集群，一个应用需要部署到几台机器上然后做负载均衡，大致如下图：

   ![å¾çæè¿°](https://segmentfault.com/img/bVbgLKW?w=1042&h=920)

4. 上图分析：

   1）变量A存在JVM1、JVM2、JVM3三个JVM内存中（这个变量A主要体现是在一个类中的一个成员变量，是一个有状态的对象），如果不加任何控制的话，变量A同时都会在JVM1、JVM2、JVM3中分配一块内存；

   2）三个请求发过来同时对这个变量进行操作，显然结果是不同的。

   3）即使不是同时发过来，三个请求分别操作三个不同JVM内存区域的数据，变量A之间不存在共享，也不具有可性，处理的结果也是不对的。

   4）如果我们业务中存在这种场景的话，我们就需要一种方法解决这个问题。

5. 为了保证一个方法或者属性在高并发情况下的同一时间只能被同一个线程执行，在传统单机应用单机部署的情况下，可以使用java并发处理的相关API进行互斥控制（如ReentrantLock或Synchronized）。

6. 在单机环境中，java中提供了很多并发处理相关的API。

7. 但是随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的java API并不能提供分布式锁的能力。

8. 为了解决这个问题，就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。

## 4 分布式锁应该具备的条件

1. 在分布式系统环境下，一个方法在同一时间只能被一个机器的的一个线程执行；
2. 高可用的获取锁与释放锁；
3. 高性能的获取锁与释放锁；
4. 具备可重入特性；
5. 具备锁失效机制，防止死锁；
6. 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

## 5 分布式锁实现方式-前言

1. 目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。
2. 分布式的CAP理论告诉我们，任何一个分布式系统都无法同时满足一致性、可用性、和分区容错性，最多只能同时满足两项。
3. 所以，很多系统在设计之初就对这三项做了取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性，只要这个最终时间实在用户可以接受的范围内即可。
4. 在很多场景中，我们为例保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等，有时候我们需要保证一个方法在同一个线程执行。
5. 基于数据库实现分布式锁；基于缓存redis等实现分布式锁；基于Zookeeper实现分布式锁。

## 6 基于数据库的实现方式

1. 基于数据库的实现方式核心思想：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。

2. 创建一个表：

   ```sql
   DROP TABLE IF EXISTS `method_lock`;
   CREATE TABLE `method_lock` (
    `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
    `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
    `desc` varchar(255) NOT NULL COMMENT '备注信息',
    `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`id`),
    UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
   ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=‘锁定中的方法';
   ```

3. 想要执行某个方法，就使用这个方法名向表中插入数据：

   ```sql
   INSERT INTO method_lock (method_name, desc) VALUES ('methodName', ‘测试的methodName');
   ```

4. 因为我们对method_name做了唯一约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

5. 成功插入则获取锁，执行完成后删除对应的行数据释放锁：

   ```sql
   delete from method_lock where method_name ='methodName';
   ```

6. 使用基于数据库的这种实现方式很简单，但是对于分布式锁应该具备的条件来说，它有一些问题需要解决及优化：

   （1）因为是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性及性能，所以，数据库需要双机部署、数据同步、主备切换。
   （2）不具备可重入的特性，因为同一个线程在释放锁之前，行数据一直存在，无法再次成功插入数据，所以，需要在表中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息是否和当前机器和线程信息相同，若相同则直接获取锁；
   （3）没有锁失效机制，因为有可能出现成功插入数据后，服务器宕机了，对应的数据没有被删除，当服务恢复后一直获取不到锁，所以，需要在锁中新增一列，用于记录失效时间，并且需要有定时任务清除这些失效的数据；
   （4）不具备阻塞锁特性，获取不到锁直接返回失败，所以需要优化获取逻辑，循环多次去获取。

7. 在实施过程中会遇到各种不同问题，为了解决这些问题，实现方式将会越来越复杂；依赖数据库需要一定的资源开销，性能问题需要考虑。

## 7 基于redis的实现方式

1. 选择redis分布式锁的原因：

   （1）redis有很高的性能；

   （2）redis对此支持的命令较好，实现起来比较方便

2. 使用分布式锁的时候主要用到的命令介绍：

   ```
   （1）SETNX
   	SETNX key val：当且仅当key不存在时，set一个key为val的字符串，返回1；若key存在，则什么都不做，返回0。
   （2）expire
       expire key timeout：当key设置一个超时时间，单位为second，超过这个时间锁会自动释放，避免死锁。
   （3）delete
       delete key：删除key
   ```

3. 实现思想：

   （1）获取锁的时候，使用setnx加锁，并使用expire命令给锁加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。

   （2）获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。

   （3）释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

## 8 基于ZooKeeper的实现方式

1. ZooKeeper是一个为分布式应用提供一致性服务的开源组件，它内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一文件名。

2. 基于ZooKeeper实现分布式锁的步骤如下：

   （1）创建一个目录mylock；

   （2）线程A想获取锁就在mylock目录下创建临时顺序节点；

   （3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；

   （4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己小的节点；

   （5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小节点，如果是则获得锁。

3. 这里推荐一个Apache的开源库Curator，它是一个ZooKeeper客户端，Curator提供的InterProcessMutex是分布式锁的实现，acquire方法用于获取锁，release用于释放锁。

4. 优点：具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。

5. 缺点：因为需要频繁的创建和删除节点，性能上不如redis方式。

## 9 总结

1. 上面的三种方式，没有在所有场合都是完美的，所以，应根据不同的应用场景选择最适合的实现方式。
2. 分布式环境中，对资源进行上锁有时候是很重要的，比如抢购某一资源，这时候使用分布式锁就可以很好的控制资源。