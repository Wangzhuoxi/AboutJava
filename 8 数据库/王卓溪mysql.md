索引：

通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件。

磁盘IO与预读 
 磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分

考虑到磁盘IO是非常高昂的操作，计算机[操作系统](http://lib.csdn.net/base/operatingsystem)做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区中



![image-20200609144309806](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609144309806.png)

找数据时：
先从磁盘取出数据到内存，然后用cpu处理看是否符合条件。

局部性原理：
当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区中，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据 我们成之为一页（page）。



具体一页有多[大数据](http://lib.csdn.net/base/hadoop)跟操作系统有关，一般为4k或8k,也就是我们读取一页内的数据时候，实际上才发生一次IO。



在InnoDB中，

数据会存储到磁盘上，在真正处理数据时需要先将数据加载到内存，表中读取某些记录时，InnoDB存储引擎不需要一条一条的把记录从磁盘上读出来，InnoDB采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，**<u>InnoDB中页的大小一般为 16 KB</u>**，也就是说，当需要从磁盘中读数据时
每一次最少将从磁盘中读取16KB的内容到内存中，每一次最少也会把内存中的16KB内容写到磁盘中。  

innoDB页结构

![image-20200609145517475](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609145517475.png)

![image-20200609145542593](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609145542593.png)

User Records真正记录数据

innoDB行格式

一行记录可以以不同的格式存在InnoDB中，行格式分别是Compact、 Redundant、 Dynamic和Compressed行格
式。
我们可以在创建或修改表的语句中指定行格式  

![image-20200609150721642](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609150721642.png)

MySQL支持一些变长的数据类型，比如VARCHAR(M)、 VARBINARY(M)、 TEXT类型，BLOB类型，这些数据类型
修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。

在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表。
CHAR是一种固定长度的类型，VARCHAR则是一种可变长度的类型。
VARCHAR(M)，M代表最大能存多少个字符。 ( MySQL5.0.3以前是字节，以后就是字符)  

在数据库中，大多数时，表的“列”称为“字段” ，每个字段包含某一专题的信息。

记录数据大小溢出：

一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这
样就可能出现一个页存放不了一条记录。
在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分
数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址（当
然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页  

innodb会默认根据主键排序并且通过指针连接：查找某一条时方便。

页目录：将该页建立分组，对每一组的第一条数据建立目录。

可以用二分法进行页目录的优化

当对于一个表，要分多个页时，

![image-20200609153736822](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609153736822.png)

新开辟一个目录页

![image-20200609153931123](C:\Users\wangdamei\AppData\Roaming\Typora\typora-user-images\image-20200609153931123.png)

形式其实就是b+树的形式

b+树：
innoDB如果你没有指定主键时，会看你是否有唯一索引

如果也没有，innodb会建立一个row_id。

那么innodb到底如何建立索引的呢？

当有数据时，建立一页，放入该页中

当该页满了，copy该页到新的一页，建立新的一页记录新的数据，再把原页修改为目录页



聚集索引：物理顺序与索引的逻辑顺序
数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。



辅助索引，也叫非聚集索引。

该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。



和聚集索引相比，叶子节点中并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点的索引行还包含了一个书签（bookmark），该书签用来告诉InnoDB哪里可以找到与索引相对应的行数据。

以看到辅助索引idx_c的叶子节点中包含了列c的值和主键的值。

其实按照定义，除了聚集索引以外的索引都是非聚集索引，只是人们想细分一下非聚集索引，分成普通索引，唯一索引，全文索引。如果非要把非聚集索引类比成现实生活中的东西，那么非聚集索引就像新华字典的偏旁字典，他结构顺序与实际存放顺序不一定一致。

InnoDB存储引擎支持覆盖索引，即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。  

**覆盖索引（Covering index）**

使用覆盖索引有啥好处？

- 可以减少大量的IO操作 

- 如果要查询的字段值在辅助索引上就有，就不用再查聚集索引了，这显然会减少IO操作。

  

  比如上图中，以下sql可以直接使用辅助索引，

  

  ```
  select a from where c = -2;
  ```

有助于统计

假设存在如下表：

  CREATE TABLE `student` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) NOT NULL,
  `age` varchar(255) NOT NULL,
  `school` varchar(255) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name` (`name`),
  KEY `idx_school_age` (`school`,`age`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;123456789

如果在该表上执行：



select count(*) from student1

优化器会怎么处理？  

遍历聚集索引和辅助索引都可以统计出结果，但辅助索引要远小于聚集索引，所以优化器会选择辅助索引来统计。

# 联合索引



联合索引是指对表上的多个列进行索引。

# Mysql 中 MyISAM 和 InnoDB 的区别



\1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

\2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  

\3. InnoDB 是聚集索引，MyISAM 是非聚集索引。**<u>聚簇索引的文件存放在主键索引的叶子节点上，</u>**因此 InnoDB 必须要有主键，通过主键索引效率很高。**但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据**。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 



\4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    

\5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；

**如何选择：**

\1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM；

\2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB。

\3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB；

